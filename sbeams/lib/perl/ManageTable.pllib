#!/perl

###############################################################################
# Program     : ManageTable.pllib
# Author      : Eric Deutsch <edeutsch@systemsbiology.org>
# $Id$
#
# Description : This is a common code section for the ManageTable scripts
#               Why isn't this in SBEAMS::Core ??
#
# SBEAMS is Copyright (C) 2000-2002 by Eric Deutsch
# This program is governed by the terms of the GNU General Public License (GPL)
# version 2 as published by the Free Software Foundation.  It is provided
# WITHOUT ANY WARRANTY.  See the full description of GPL terms in the
# LICENSE file distributed with this software.
#
###############################################################################

use strict;


###############################################################################
# Print Options Page
###############################################################################
sub printOptions {
  my %args = @_;

  #### Process the arguments list


  #### Print the current user context information
  $sbeams->printUserContext();

  #### Read in the default input parameters
  my %parameters;
  my $n_params_found = $sbeams->parse_input_parameters(
    q=>$q,parameters_ref=>\%parameters);


  #### If we're in HTML mode, print a list of option links for the user
  if ($sbeams->output_mode() eq 'html') {
    print qq~
	<BR>
	<H2>$DBTITLE $CATEGORY Maintenance</H2>
	$LINESEPARATOR
    ~;

    #### Loop over all the menu options, printing them
    for (my $option=0; $option<$#MENU_OPTIONS; $option+=2) {
      print qq~
	$OPTIONARROW
	<A HREF="@MENU_OPTIONS[$option+1]">@MENU_OPTIONS[$option]</A>
      ~;
    }

    print "$LINESEPARATOR<P>";

  }


  #### Close the upper portion of the page and get ready for data table
  #$sbeamsMOD->printPageFooter(close_table=>"YES",display_footer=>"NO");

  #### Display the data table
  showTable(with_options=>'YES',parameters_ref=>\%parameters);

  #### Close the upper portion of the page and get ready for data table
  $sbeamsMOD->printPageFooter(close_table=>"YES",display_footer=>"NO");


} # end printOptions



###############################################################################
# Print Entry Form
###############################################################################
sub printEntryForm {
  my %args = @_;

  #### Process the arguments list


  #### Define popular variables
  my ($i,$element,$key,$value,$line,$result,$sql);
  my ($username,$row);


  #### Get the columns for this table
  my @columns = $sbeamsMOD->returnTableInfo($TABLE_NAME,"ordered_columns");
  my %input_types = $sbeamsMOD->returnTableInfo($TABLE_NAME,"input_types");
  my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";


  #### Read the input parameters for each column
  my %parameters;
  my $n_params_found = $sbeams->parse_input_parameters(
    q=>$q,parameters_ref=>\%parameters,
    columns_ref=>\@columns,input_types_ref=>\%input_types);


  #### Get the action values that triggered this
  my $apply_action = $q->param('apply_action') || $q->param('action');
  my $apply_action_hidden  = $q->param('apply_action_hidden');
  if ($apply_action_hidden gt "") { $apply_action = $apply_action_hidden; }


  #### If a specific PK row was referenced and this is not a REFRESH of an
  #### existing form, then load data from it into hash
  if ($parameters{$PK_COLUMN_NAME} gt "" && $apply_action ne "REFRESH") {
    my $column_list = join(",",@columns);
    $sql = qq~
      SELECT $column_list
        FROM $DB_TABLE_NAME
       WHERE $PK_COLUMN_NAME='$parameters{$PK_COLUMN_NAME}'
    ~;
    my @rows = $sbeams->selectSeveralColumns($sql);
    my @row = @{$rows[0]};
    for ($element=0; $element<scalar(@row); $element++) {
      $parameters{@columns[$element]}=@row[$element];
    }

  }


  #### Obtain information about the current user
  $current_username = $sbeams->getCurrent_username;
  $current_contact_id = $sbeams->getCurrent_contact_id;
  $current_work_group_id = $sbeams->getCurrent_work_group_id;
  $current_work_group_name = $sbeams->getCurrent_work_group_name;
  $current_project_id = $sbeams->getCurrent_project_id;
  $current_project_name = $sbeams->getCurrent_project_name;


  #### Execute some special code for the current table
  preFormHook(parameters_ref=>\%parameters);


  #### Query to obtain column information about the table being managed
  $sql = qq~
      SELECT column_name,column_title,is_required,input_type,input_length,
             is_data_column,is_display_column,column_text,
             optionlist_query,onChange,fk_table
        FROM $TB_TABLE_COLUMN
       WHERE table_name='$TABLE_NAME'
         AND is_data_column='Y'
       ORDER BY column_index
  ~;
  my @columns_data = $sbeams->selectSeveralColumns($sql);


  # First just extract any valid optionlist entries.  This is done
  # first as opposed to within the loop below so that a single DB connection
  # can be used.
  # THIS IS LEGACY AND NO LONGER A USEFUL REASON TO DO SEPARATELY
  my %optionlist_queries;
  my $file_upload_flag = "";
  foreach $row (@columns_data) {
    my @row = @{$row};
    my ($column_name,$column_title,$is_required,$input_type,$input_length,
        $is_data_column,$is_display_column,$column_text,
        $optionlist_query,$onChange,$fk_table) = @row;
    if ($optionlist_query gt "") {
      $optionlist_queries{$column_name}=$optionlist_query;
    }
    if ($input_type eq "file") {
      $file_upload_flag = "ENCTYPE=\"multipart/form-data\"";
    }
  }


  # There appears to be a Netscape bug in that one cannot [BACK] to a form
  # that had multipart encoding.  So, only include form type multipart if
  # we really have an upload field.  IE users are fine either way.
  $sbeams->printUserContext();
  print qq!
      <P>
      <H2>Maintain $CATEGORY</H2>
      $LINESEPARATOR
      <FORM METHOD="post" NAME="MainForm" $file_upload_flag>
      <TABLE>
  !;


  # ---------------------------
  # Build option lists for each optionlist query provided for this table
  my %optionlists;
  foreach $element (keys %optionlist_queries) {

      # If "$contact_id" appears in the SQL optionlist query, then substitute
      # that with either a value of $parameters{contact_id} if it is not
      # empty, or otherwise replace with the $current_contact_id
      if ( $optionlist_queries{$element} =~ /\$contact_id/ ) {
        if ( $parameters{"contact_id"} eq "" ) {
          $optionlist_queries{$element} =~
              s/\$contact_id/$current_contact_id/g;
        } else {
          $optionlist_queries{$element} =~
              s/\$contact_id/$parameters{contact_id}/g;
        }
      }

      # If "$project_id" appears in the SQL optionlist query, then substitute
      # that with either a value of $parameters{project_id} if it is not
      # empty, or otherwise replace with the $current_project_id
      if ( $optionlist_queries{$element} =~ /\$project_id/ ) {
        if ( $parameters{"project_id"} eq "" ) {
          $optionlist_queries{$element} =~
              s/\$project_id/$current_project_id/g;
        } else {
          $optionlist_queries{$element} =~
              s/\$project_id/$parameters{project_id}/g;
        }
      }

      #### Evaluate the $TBxxxxx table name variables if in the query
      if ( $optionlist_queries{$element} =~ /\$TB/ ) {
        my $tmp = $optionlist_queries{$element};
        #### If there are any double quotes, need to escape them first
        $tmp =~ s/\"/\\\"/g;
        my $nonNULL = 0;
        $nonNULL = 1 if ($tmp);
        $optionlist_queries{$element} = eval "\"$tmp\"";
        if ($nonNULL && !($optionlist_queries{$element})) {
          print "WARNING: eval failed for =$tmp=. ".
            "Please report this problem<BR>\n";
	}
      }

      #### Set the MULTIOPTIONLIST flag if this is a multi-select list
      my $method_options;
      $method_options = "MULTIOPTIONLIST"
        if ($input_types{$element} eq "multioptionlist");

      # Build the option list
      if ($input_types{$element} eq "fixedfromlist") {
        my %templist =
          $sbeams->selectTwoColumnHash($optionlist_queries{$element});
        $optionlists{$element} = $templist{$parameters{$element}};
      } else {
        #print "$optionlist_queries{$element}<BR><BR>\n";
        if ($optionlist_queries{$element}) {
          $optionlists{$element}=$sbeams->buildOptionList(
             $optionlist_queries{$element},$parameters{$element},
             $method_options);
        } else {
          print "WARNING: empty SQL statement for option list. ".
            "Please report this problem<BR>\n";
          $optionlist_queries{$element} = "";
        }

      }

  }


  #### Now loop through again and write the HTML
  foreach $row (@columns_data) {
    my @row = @{$row};
    my $mask_description = 0;
    my ($column_name,$column_title,$is_required,$input_type,$input_length,
        $is_data_column,$is_display_column,$column_text,
        $optionlist_query,$onChange,$fk_table) = @row;


    #### If there is a foreign_key table defined, create some HTML
    #### to provide a link to it
    my $jump_to_list_source;
    if ($fk_table) {
      my $subdir = $sbeams->getSBEAMS_SUBDIR();
      $subdir .= "/" if ($subdir);
      $jump_to_list_source = qq~<A TARGET="AddToList" HREF="$CGI_BASE_DIR/${subdir}ManageTable.cgi?TABLE_NAME=$fk_table&ShowEntryForm=1"><IMG
        SRC="$HTML_BASE_DIR/images/greyplus.gif" border=0
        ALT="Add to or view details about this list box" ></A>
      ~;
    }


    #### Set the JavaScript onChange string if supplied
    if ($onChange gt "") {
      $onChange = " onChange=\"$onChange\"";
    }


    #### Write the parameter name, in red if required
    if ($is_required eq "N") {
      print "<TR><TD><B>$column_title:</B></TD>\n";
    } else {
      print "<TR><TD><B><font color=red>$column_title:</font></B></TD>\n";
    }


    if ($input_type eq "text") {
      print qq!
        <TD><INPUT TYPE="$input_type" NAME="$column_name"
         VALUE="$parameters{$column_name}" SIZE=$input_length $onChange></TD>
      !;
    }


    if ($input_type eq "file") {
      print "<TD>";
      my $data_file =
        "$TABLE_NAME/$parameters{$PK_COLUMN_NAME}_$column_name.dat";
      if ($parameters{$column_name}) {
        my $file_size = -s "$PHYSICAL_BASE_DIR/data/$data_file";
        my $file_name = $parameters{$column_name};
        #$file_name =~ s/^.+\///;
        #### Check for legacy names before original names were stored
        if ($file_name eq $data_file) {
          $file_name = 'Original File Name Unknown';
        }
        #### If the file is of non-zero length, provide a link to it
        if ($file_size > 0) {
          my $url = $base_url;
          $url =~ s/\?/\/$file_name?/;
          print "<nowrap>View File: <A HREF=\"$url&".
            "$PK_COLUMN_NAME=$parameters{$PK_COLUMN_NAME}&".
            "GetFile=$column_name\">".
            "$file_name</A> </nowrap><BR>\n";
        }

      }

      print qq~
        <INPUT TYPE="$input_type" NAME="$column_name"
         VALUE="" SIZE=$input_length $onChange>
        </TD>
      ~;
    }


    if ($input_type eq "password") {

      # If we just loaded password data from the database, and it's not
      # a blank field, the replace it with a special entry that we'll
      # look for and decode when it comes time to UPDATE.
      if ($parameters{$PK_COLUMN_NAME} gt "" && $apply_action ne "REFRESH") {
        if ($parameters{$column_name} gt "") {
          $parameters{$column_name}="**********".$parameters{$column_name};
        }
      }

      print qq!
        <TD><INPUT TYPE="$input_type" NAME="$column_name"
         VALUE="$parameters{$column_name}" SIZE=$input_length></TD>
      !;
    }


    if ($input_type eq "fixed") {
      print qq!
        <TD><INPUT TYPE="hidden" NAME="$column_name"
         VALUE="$parameters{$column_name}">$parameters{$column_name}</TD>
      !;
    }

    if ($input_type eq "textarea") {
      print qq~
        <TD COLSPAN=2 BGCOLOR="E0E0E0">$column_text</TD></TR>
        <TR><TD> </TD>
        <TD COLSPAN=2><TEXTAREA NAME="$column_name" rows=$input_length
          cols=80>$parameters{$column_name}</TEXTAREA></TD>
      ~;
      $mask_description = 1;
    }

    if ($input_type eq "textdate") {
      if ($parameters{$column_name} eq "") {
        my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time());
        $year+=1900; $mon+=1;
        $parameters{$column_name} = "$year-$mon-$mday $hour:$min";
      }
      print qq!
        <TD><INPUT TYPE="text" NAME="$column_name"
         VALUE="$parameters{$column_name}" SIZE=$input_length>
        <INPUT TYPE="button" NAME="${column_name}_button"
         VALUE="NOW" onClick="ClickedNowButton($column_name)">
         </TD>
      !;
    }

    if ($input_type eq "optionlist") {
      print qq!
        <TD><SELECT NAME="$column_name" $onChange>
        <OPTION VALUE=""></OPTION>
        $optionlists{$column_name}</SELECT>&nbsp;$jump_to_list_source</TD>
      !;
    }

    if ($input_type eq "scrolloptionlist") {
      print qq!
        <TD><SELECT NAME="$column_name" SIZE=$input_length $onChange>
        <OPTION VALUE=""></OPTION>
        $optionlists{$column_name}</SELECT>&nbsp;$jump_to_list_source</TD>
      !;
    }

    if ($input_type eq "multioptionlist") {
      print qq!
        <TD><SELECT NAME="$column_name" MULTIPLE SIZE=$input_length $onChange>
        $optionlists{$column_name}</SELECT>&nbsp;$jump_to_list_source</TD>
      !;
    }

    if ($input_type eq "fixedfromlist") {
      print qq!
        <TD><INPUT TYPE="hidden" NAME="$column_name"
         VALUE="$parameters{$column_name}">
         $optionlists{$column_name}</TD></TD>
      !;
    }

    if ($input_type eq "current_contact_id") {
      if ($parameters{$column_name} eq "") {
          $parameters{$column_name}=$current_contact_id;
          $username=$current_username;
      } else {
          if ( $parameters{$column_name} == $current_contact_id) {
            $username=$current_username;
          } else {
            $username=$sbeams->getUsername($parameters{$column_name});
          }
      }
      print qq~
        <TD><INPUT TYPE="hidden" NAME="$column_name"
         VALUE="$parameters{$column_name}">$username</TD>
      ~;
    }

    unless ($mask_description) {
      print qq~
        <TD BGCOLOR="E0E0E0">$column_text</TD>
      ~;
    }

    print "</TR>\n";


  }


  #### Allow some additional processing here based on current table
  postFormHook(parameters_ref=>\%parameters);



  my $record_status_options =
    $sbeams->getRecordStatusOptions($parameters{"record_status"});

  print qq~
        <TR><TD><B>record_status:</B></TD>
        <TD><SELECT NAME="record_status">
            $record_status_options
            </SELECT></TD>
        </TR><TR>
  ~;


  #### If a specific record was passed, display UPDATE options
  if ($parameters{$PK_COLUMN_NAME} gt "") {

    if ($parameters{date_created}) {
      my $created_by_username =
        $sbeams->getUsername($parameters{created_by_id});
      my $modified_by_username =
        $sbeams->getUsername($parameters{modified_by_id});
      my $date_created = $parameters{date_created}; chop($date_created);
      my $date_modified = $parameters{date_modified}; chop($date_modified);
      print qq~
        <TR><TD><B>Record Created:</B></TD>
        <TD COLSPAN=2>${date_created} by ${created_by_username}</TD></TR>
      ~;
      unless ($date_created eq $date_modified) {
        print qq~
          <TR><TD><B>Record Modified:</B></TD>
          <TD COLSPAN=2>${date_modified} by ${modified_by_username}</TD></TR>
        ~;
      }
    }


    print qq!
       <TR><TD COLSPAN=3 BGCOLOR="#EEEEFF">
       <INPUT TYPE="hidden" NAME="TABLE_NAME" VALUE="$TABLE_NAME">
       <INPUT TYPE="hidden" NAME="$PK_COLUMN_NAME"
         VALUE="$parameters{$PK_COLUMN_NAME}">
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       <INPUT TYPE="submit" NAME="apply_action" VALUE="UPDATE"> this record with this new data<BR>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       <INPUT TYPE="submit" NAME="apply_action" VALUE="INSERT"> new record(s) with this information (uniqueness will be checked)<BR>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       <INPUT TYPE="submit" NAME="apply_action" VALUE="REFRESH"> this form<BR>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       <INPUT TYPE="submit" NAME="apply_action" VALUE="DELETE"> this record<BR>
    !;


  #### Otherwise, just allow INSERT or REFRESH
  } else {
    print qq!
       <TR><TD COLSPAN=3 BGCOLOR="#EEEEFF">
       <INPUT TYPE="hidden" NAME="TABLE_NAME" VALUE="$TABLE_NAME">
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       <INPUT TYPE="submit" NAME="apply_action" VALUE="INSERT"> new record(s) with this information<BR>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       <INPUT TYPE="submit" NAME="apply_action" VALUE="REFRESH"> this form<BR>
    !;
  }


  #### Finish the form
  print qq!
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
       <INPUT TYPE="reset" VALUE="CLEAR"> fields
       <INPUT TYPE="hidden" NAME="apply_action_hidden" VALUE="">
       <INPUT TYPE="hidden" NAME="set_current_work_group" VALUE="">
       <INPUT TYPE="hidden" NAME="set_current_project_id" VALUE="">
    </TR></TABLE>
    </FORM>
  !;


  $sbeamsMOD->printPageFooter(close_tables=>'YES',display_footer=>'NO');

  showTable(with_options=>'',parameters_ref=>\%parameters);

} # end printEntryForm



###############################################################################
# show Table
#
# Displays the Table
###############################################################################
sub showTable {
  my %args = @_;

  #### Process the arguments list
  my $query_parameters_ref = $args{'parameters_ref'};
  my %parameters = %{$query_parameters_ref};
  my $with_options = $args{'with_options'};


  #### Get the specified level of detail or set to BASIC
  my $detail_level = $q->param('detail_level') || "BASIC";
  my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";
  my $apply_action  = $parameters{'action'} || $parameters{'apply_action'};


  #### Get the query to show this table
  my ($main_query_part) =
    $sbeamsMOD->returnTableInfo($TABLE_NAME,$detail_level."Query",
    $query_parameters_ref);

  #### Display the table controls
  my ($full_where_clause,$full_orderby_clause) = 
    $sbeams->processTableDisplayControls($TABLE_NAME);


  #### If a new ORDER BY clause is specified, remove the default one
  if ($full_orderby_clause) {
    $main_query_part =~ s/\s*ORDER BY.*//i;
  }


  #### Build the final query
  my $sql_query = qq~
      $main_query_part
      $full_where_clause
      $full_orderby_clause
  ~;
  #print "<PRE>$sql_query\n\n</PRE>";


  #### Get the url link data
  my %url_cols = $sbeamsMOD->returnTableInfo($TABLE_NAME,"url_cols");


  #### Define some variables for the resultset
  my %resultset = ();
  my $resultset_ref = \%resultset;

  #### If the apply action was to recall a previous resultset, do it
  my %rs_params = $sbeams->parseResultSetParams(q=>$q);
  if ($apply_action eq "VIEWRESULTSET") {
    $sbeams->readResultSet(
       resultset_file=>$rs_params{set_name},
       resultset_ref=>$resultset_ref,
       query_parameters_ref=>\%parameters
    );


  #### Otherwise fetch the results from the database server
  } else {

    #### Fetch the results from the database server
    $sbeams->fetchResultSet(sql_query=>$sql_query,
      resultset_ref=>$resultset_ref);

    #### Store the resultset and parameters to disk resultset cache
    $rs_params{set_name} = "SETME";
    $sbeams->writeResultSet(
      resultset_file_ref=>\$rs_params{set_name},
      resultset_ref=>$resultset_ref,
      query_parameters_ref=>\%parameters
    );
  }


  #### Display the resultset
  $sbeams->displayResultSet(
    rs_params_ref=>\%rs_params,
    url_cols_ref=>\%url_cols,
    #hidden_cols_ref=>\%hidden_cols,
    #max_widths=>\%max_widths,
    resultset_ref=>$resultset_ref,
    #column_titles_ref=>\@column_titles,
    base_url=>$base_url,
    query_parameters_ref=>\%parameters,
  );


  #### Display the resultset controls
  $sbeams->displayResultSetControls(
    rs_params_ref=>\%rs_params,
    resultset_ref=>$resultset_ref,
    query_parameters_ref=>\%parameters,
    base_url=>$base_url
  );


} # end showTable



###############################################################################
# Process Entry Form
#
###############################################################################
sub processEntryForm {
    my $element;
    my $sql_query;
    my @returned_information;
    my $tmp;

    #### Get the columns for this table
    my @columns = $sbeamsMOD->returnTableInfo($TABLE_NAME,"ordered_columns");
    my %input_types = $sbeamsMOD->returnTableInfo($TABLE_NAME,"input_types");


    # Check to see if there is a column which will allow a range of numbers
    # over which a multi-insert could be performed
    my ($multi_insert_column) = 
      $sbeamsMOD->returnTableInfo($TABLE_NAME,"MULTI_INSERT_COLUMN");


    #### Read the form values for each column
    my %parameters;
    my $n_params_found = $sbeams->parse_input_parameters(
      q=>$q,parameters_ref=>\%parameters,
      columns_ref=>\@columns,input_types_ref=>\%input_types);

    my $apply_action  = $parameters{apply_action};


    #### Obtain information about the current user
    $current_username = $sbeams->getCurrent_username;
    $current_contact_id = $sbeams->getCurrent_contact_id;
    $current_work_group_id = $sbeams->getCurrent_work_group_id;
    $current_work_group_name = $sbeams->getCurrent_work_group_name;
    $current_project_id = $sbeams->getCurrent_project_id;
    $current_project_name = $sbeams->getCurrent_project_name;


    # Check for missing required information
    my @required_columns = 
      $sbeamsMOD->returnTableInfo($TABLE_NAME,"required_columns");
    if (@required_columns) {
      my $error_message;
      foreach $element (@required_columns) {
        $error_message .= "<LI> You must provide a <B>$element</B>."
          unless $parameters{$element};
      }

      $error_message .= preUpdateDataCheck(parameters_ref=>\%parameters);

      if ($error_message) {
          $sbeams->printIncompleteForm($error_message);
          return 0;
      }
    }


    my @data_columns = 
      $sbeamsMOD->returnTableInfo($TABLE_NAME,"data_columns");
    my %input_types = 
      $sbeamsMOD->returnTableInfo($TABLE_NAME,"input_types");


    # Multi-Insert logic.  In certain cases, we'll allow the user to specify
    # a range like "15-20,22-23" for exactly one field, and this triggers
    # INSERTion of multiple rows.
    my @series;
    if ($multi_insert_column) {
      my $input = $parameters{$multi_insert_column};
      $input =~ s/\-/\.\./g;

      # Replace any characters which are NOT 0-9 or , or . which a space
      # before we let it go into eval!!
      $input =~ tr/0-9\,\./ /cs;

      @series = eval $input;

      if (@series) { }
      else {
        $input =~ /(\d*)/;
        @series = ($1);
      }

      if (@series) { }
      else {
        push (@returned_information,"NOT ACCEPTED");
        push (@returned_information,
          "Unable to parse your input '$parameters{$multi_insert_column}'
           into a series of numbers.");
        printAttemptedChangeResult($apply_action,@returned_information);
        return;
      }

      if ( ($#series > 0) && $parameters{$PK_COLUMN_NAME} && 
           ($apply_action ne "INSERT") ) {
        push (@returned_information,"NOT ACCEPTED");
        push (@returned_information,
          "Sorry, cannot UPDATE or DELETE multiple records.
           Only INSERT of multiple records permitted.");
        printAttemptedChangeResult($apply_action,@returned_information);
        return;
      }
    } else {
      @series = ( "dummy" );
    }


    my $multi_insert;
    foreach $multi_insert (@series) {
      if ($multi_insert_column) {
        $parameters{$multi_insert_column}=$multi_insert;
        print "Processing record for $multi_insert...<BR>\n";
      }


    # Note the following block has NOT been indented properly for historical
    # reasons of insertion into above foreach statement

    # If a PK has already been provided and action is not INSERT, build
    # SQL statements for DELETE and UPDATE
    if ($parameters{$PK_COLUMN_NAME} && ($apply_action ne "INSERT")) {
        $sql_query = "";
        if ($apply_action eq "DELETE") {

            $sql_query = qq!
                UPDATE $DB_TABLE_NAME SET
                  date_modified=CURRENT_TIMESTAMP,
                  modified_by_id=$current_contact_id,
                  record_status='D'
                WHERE $PK_COLUMN_NAME=$parameters{$PK_COLUMN_NAME}
            !;

        } else {
            $sql_query = "UPDATE $DB_TABLE_NAME SET ";

            foreach $element (@data_columns) {
              $tmp = $parameters{$element};

              # If datatype is password, then decode the ********** to
              # revert back to the original password, or just keep as is if
              # blank, or encrypt it if it's something else
              if ($input_types{$element} eq "password") {
                if ( substr($tmp,0,10) eq "**********" ) {
                  $tmp = substr($tmp,10,50);
                } elsif ( $tmp gt "" ) {
                  my $salt  = (rand() * 220);
                  $tmp = crypt($tmp, $salt);
                }
              }

              #### If the value is blank, put in a NULL value
              if ( $tmp eq '') {

                #### unless it is type file in which case leave alone
                unless ($input_types{$element} eq "file") {
                  $sql_query .= "$element=NULL,\n";
                }

              # Change all ' to '' so that it can go in the INSERT statement
              } else {
                $tmp =~ s/\'/\'\'/g;
                $sql_query .= "$element='$tmp',\n";
              }
            }

            $sql_query .= qq!
                  date_modified=CURRENT_TIMESTAMP,
                  modified_by_id='$current_contact_id',
                  record_status='$parameters{record_status}'
                WHERE $PK_COLUMN_NAME=$parameters{$PK_COLUMN_NAME}
            !;
        }

        if ($sql_query eq "") {
            print "ERROR: Action '$apply_action' not recognized.<BR>\n";
            return;
        }

    # Otherwise, the action is INSERT, so build a SQL statement for that
    } else {

        # Since this is a new INSERT, zero out any previous PK
        $parameters{$PK_COLUMN_NAME}=0;

        # Check for an existing record that this would duplicate
        my @key_columns = 
          $sbeamsMOD->returnTableInfo($TABLE_NAME,"key_columns");
        my %unique_values;
        if (@key_columns) {
          foreach $element (@key_columns) {
            $unique_values{$element} = $parameters{$element};
          }
        }
        my $existing_record = checkForPreexistingRecord(%unique_values);
        if ($existing_record) {
            printPreexistingRecord($existing_record);
            return;
        }


        # Build the column names and VALUES for each data column
        my ($query_part1,$query_part2,$tmp);
        foreach $element (@data_columns) {
          $tmp = $parameters{$element};

          # If datatype is password, then decode the ********** to
          # revert back to the original password, or just keep as is if
          # blank, or encrypt it if it's something else
          if ($input_types{$element} eq "password") {
             if ( substr($tmp,0,10) eq "**********" ) {
               $tmp = substr($tmp,10,50);
             } elsif ( $tmp gt "" ) {
               my $salt  = (rand() * 220);
               $tmp = crypt($tmp, $salt);
             }
          }

          #### If the value is blank, put in a NULL value
          if ( $tmp eq '') {
            #$query_part2 .= "NULL,";

          # Change all ' to '' so that it can go in the INSERT statement
          } else {
            $tmp =~ s/\'/\'\'/g;
            $query_part1 .= "$element,";
            $query_part2 .= "'$tmp',";
          }
        }

        # Build the SQL statement
        $sql_query = qq!
 		INSERT INTO $DB_TABLE_NAME
		  ($query_part1 created_by_id,modified_by_id,
		   owner_group_id,record_status)
		VALUES
		  ($query_part2 $current_contact_id, $current_contact_id,
 		  $current_work_group_id, '$parameters{record_status}')
        !;

    }


    # Execute the SQL statement extract status and PK from result
    @returned_information = $sbeams->applySqlChange(
      $sql_query,
      $current_contact_id,
      $TABLE_NAME,
      "$PK_COLUMN_NAME=$parameters{$PK_COLUMN_NAME}",
      $PK_COLUMN_NAME
    );
    my $returned_request_status = shift @returned_information;
    my $returned_request_PK = shift @returned_information;

    if ($apply_action eq "INSERT") {
      $parameters{$PK_COLUMN_NAME}=$returned_request_PK;
    }

    printAttemptedChangeResult($apply_action,$returned_request_status,
      @returned_information);


    # If change was successful, then check to see if there are any data
    # files to be uploaded, and if so, do so.
    if ($returned_request_status eq "SUCCESSFUL") {
      # Check for any file uploads
      my $filename;
      foreach $element (keys %input_types) {
        if ($input_types{$element} eq "file") {
          $filename = "$parameters{$PK_COLUMN_NAME}_$element.dat";
          if ($parameters{$element}) {
            print "Uploading data for field '$element' from client file ".
              "'$parameters{$element}'<BR>\n";
	    my $fh = $q->upload($element);
            writeDataFile($fh, $TABLE_NAME, $filename);
          } else {
            print "Nothing to upload for field '$element'<BR>\n";
          }

          #### Update the table for the relative local location
          #$sql_query = qq~
          #    UPDATE $DB_TABLE_NAME SET
          #      $element='$TABLE_NAME/$filename'
          #    WHERE $PK_COLUMN_NAME=$parameters{$PK_COLUMN_NAME}
          #~;
          #$sbeams->executeSQL($sql_query);

          #### If there's a Windows path as part of the parameter,
          #### update the table for the name without the path
          if ($parameters{$element} =~ /:\\/) {
            my $file_name = $parameters{$element};
            $file_name =~ s/^.*\\//;
            $file_name =~ s/\'/''/g;
            $sql_query = qq~
              UPDATE $DB_TABLE_NAME SET
                $element='$file_name'
              WHERE $PK_COLUMN_NAME=$parameters{$PK_COLUMN_NAME}
            ~;
            $sbeams->executeSQL($sql_query);
          }

        }

      }

    }



    } # End multi-insert

} # end processAddUser


###############################################################################
# Check For Preexisting Record
#
# Before the record is actually added, we check to see if there
# is already a matching record.
###############################################################################
sub checkForPreexistingRecord {
  my %unique_values = @_;
  my $element;
  my $foundvalue = '';
  my $error_message = '';

  my $sql_query = qq!
	SELECT $PK_COLUMN_NAME
	  FROM $DB_TABLE_NAME
	 WHERE $PK_COLUMN_NAME > 0!;

  foreach $element (keys %unique_values) {
    my $value = $unique_values{$element};
    $value =~ s/\'/\'\'/g;
    $sql_query .= "
         AND $element='$value'";
    $error_message .= "<B>$element</B> = $unique_values{$element}<BR>\n";
  }

  my @rows = $sbeams->selectOneColumn($sql_query);

  if (@rows) {
    print qq~
      The following columns where checked for uniqueness:<BR>
      $error_message<BR>
    ~;
  }

  return($rows[0]);

} # end checkForPreexistingRecord



###############################################################################
# Print Preexisting Record Message
###############################################################################
sub printPreexistingRecord {
    my $record_id = shift;

    my $back_button = $sbeams->getGoBackButton();
    print qq!
        <P>
        <H2>This $CATEGORY already exists</H2>
        $LINESEPARATOR
        <P>
        <TABLE WIDTH=$MESSAGE_WIDTH><TR><TD>
        Another $CATEGORY record already exists that would violate
        uniqueness contraints.  Perhaps you are trying to enter an item
        that already exists.  It is possible that the uniqueness constraints
        are too rigid, and they need to be relaxed a little to allow two
        records that are very similar.  It is also possible that
        there is a deleted item that matches the new entry (flagged as deleted
        but not yet purged from the system).  In that case, click on the
        existing (deleted) record, undelete it, and update as appropriate.
        <CENTER>
        <A HREF="$PROGRAM_FILE_NAME&$PK_COLUMN_NAME=$record_id">Click
          here to see the existing matching record</A><BR><BR>
        $back_button
        </CENTER>
        </TD></TR></TABLE>
        $LINESEPARATOR
        <P>!;
} # end printPreexistingRecord


###############################################################################
# Print Results of the attempted database change
###############################################################################
sub printAttemptedChangeResult {
    my $apply_action = shift || "?????";
    my @returned_result=@_;
    my $error;

    my $subdir = $sbeams->getSBEAMS_SUBDIR();
    $subdir .= "/" if ($subdir);

    # First element is SUCCESSFUL or DENIED.  Rest is additional messages.
    my $result = shift @returned_result;
    my $back_button = $sbeams->getGoBackButton();

    $sbeams->printUserContext();

    print qq!
        <P>
        <H2>Return Status</H2>
        $LINESEPARATOR
        <P>
        <TABLE WIDTH=$MESSAGE_WIDTH><TR><TD>
        $apply_action of your record was <B>$result</B>.
        <P>
        <BLOCKQUOTE>
    !;

    foreach $error (@returned_result) { print "<LI>$error<P>\n"; }

    print qq!
        </BLOCKQUOTE>
        </TD></TR></TABLE>
        $LINESEPARATOR
        <P>
        <CENTER><B>
        You can click on BACK to INSERT/UPDATE another record with similar
        values $back_button
        <BR><BR><BR>
        [ <A HREF="$CGI_BASE_DIR/${subdir}$PROGRAM_FILE_NAME">View $CATEGORY Table</A>]
        </B></CENTER><BR><BR><BR><BR>
    !;

    # See if this table has a next_step property, i.e. a likely next "Add"
    # function.  If so, then print out the link(s) to take the user there.
    my $sql_query = qq~
	SELECT next_step
	  FROM $TB_TABLE_PROPERTY
	 WHERE table_name = '$TABLE_NAME'
    ~;
    my ($next_step) = $sbeams->selectOneColumn($sql_query);
    if ($next_step) {
      my @next_steps = split(",",$next_step);
      foreach $next_step (@next_steps) {
        print qq~
	  <B>Next Step? [ <A HREF="$CGI_BASE_DIR/${subdir}ManageTable.cgi?TABLE_NAME=$next_step&ShowEntryForm=1">Add $next_step</A>
	  ]</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ~;
      }
    }


} # end printAttemptedChangeResult


###############################################################################
# WriteData File
###############################################################################
sub writeDataFile {
    my $data = shift;
    my $subdir  = shift;
    my $filename  = shift;
    my $buffer;


    #### Check that the upload directory is there
    unless (-d "$UPLOAD_DIR") {
      die("CONFIGURATION ERROR: The upload directory '$UPLOAD_DIR' does not exist! ".
        "Please report this problem to your SBEAMS administrator.<BR>");
    }


    #### Check that the directory for this table is there
    unless (-d "$UPLOAD_DIR/$subdir") {
      mkdir("$UPLOAD_DIR/$subdir") ||
      die("SERVER STORAGE ERROR: The upload directory could not be created! ".
        "Please report this problem to your SBEAMS administrator.<BR>");
    }


    #### Open the output file
    open(DATA, ">$UPLOAD_DIR/$subdir/$filename")
      || die("Could not open $filename: $!");


    #### Dump the uploaded data into the output file
    my $byte_count = 0;
    while (read($data, $buffer, 1024)) {
      print DATA $buffer;
      $byte_count += length($buffer);
    }
    close(DATA);


    print "&nbsp;&nbsp;&nbsp;&nbsp;$byte_count bytes uploaded.<BR>\n";


} # end writeDataFile



###############################################################################
# getFile
###############################################################################
sub getFile {

  #### Get the columns for this table
  my @columns = $sbeamsMOD->returnTableInfo($TABLE_NAME,"ordered_columns");
  my %input_types = $sbeamsMOD->returnTableInfo($TABLE_NAME,"input_types");

  #### Read the form values for each column
  my %parameters;
  my $n_params_found = $sbeams->parse_input_parameters(
    q=>$q,
    parameters_ref=>\%parameters,
    columns_ref=>\@columns,
    input_types_ref=>\%input_types,
  );


  #### Load data from this record into hash
  my $column_list = join(",",@columns);
  my $sql = qq~
    SELECT $column_list
      FROM $DB_TABLE_NAME
     WHERE $PK_COLUMN_NAME='$parameters{$PK_COLUMN_NAME}'
  ~;
  my @rows = $sbeams->selectSeveralColumns($sql);
  my @row = @{$rows[0]};
  for (my $element=0; $element<scalar(@row); $element++) {
    $parameters{@columns[$element]}=@row[$element];
  }


  #### Determine the name of the requested file
  my $data_file =
    "$TABLE_NAME/$parameters{$PK_COLUMN_NAME}_".
    "$parameters{GetFile}.dat";

  my $full_file_name = "$PHYSICAL_BASE_DIR/data/$data_file";
  my $file_size = -s $full_file_name;


  #### If the file is nonzero, then send it
  if ($file_size > 0) {

    #### Determine the content type based on the file name
    my $content_type = getContentType(
      file_name => $parameters{$parameters{GetFile}},
    ) || 'text/plain';


    #### Send the HTTP header
    print "Content-type: $content_type\n\n";

    #### Send the contents of the file
    my $buffer;
    open(DATA, $full_file_name) || die("Couldn't open $full_file_name: ".$!);
    while (read(DATA, $buffer, 1024)) {
      print $buffer;
    }

  }


} # end getFile



###############################################################################
# getContentType
###############################################################################
sub getContentType {
  my %args = @_;

  my $file_name = $args{'file_name'};

  #### Return empty string if a non-empty input file name was not provided
  return '' unless ($file_name);

  #### Get the file extension
  my $file_ext = '';
  if ($file_name =~ /\.(.+)?$/) {
    $file_ext = $1;
  }


  #### If we found a valid extention
  if ($file_ext) {

    #### Parse the mime.types file
    my $mime_types_file = '/etc/mime.types';
    my $line;
    my %ext_hash;
    open(DATA,$mime_types_file) || die("Couldn't open $mime_types_file: ".$!);
    while ($line=<DATA>) {
      next if ($line =~ /^\#/);
      $line =~ s/[\r\n]//g;
      $line =~ s/\s+$//;
      next unless ($line);

      #### Split the line into its components
      my @items = split(/\s+/,$line);
      my $n_items = scalar(@items);

      #### If there's more than one item, register each of the file
      #### extensions with the mime type in the hash
      if ($n_items > 1) {
        for (my $i=1;$i<$n_items;$i++) {
          $ext_hash{lc($items[$i])} = $items[0];
        }
      }

    }

    #### If there's a match to this extention, return it
    if ($ext_hash{lc($file_ext)}) {
      return $ext_hash{lc($file_ext)};
    }

  }

  return '';

} # end getContentType



###############################################################################
###############################################################################
###############################################################################
1;

