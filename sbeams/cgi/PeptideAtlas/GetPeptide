#!/usr/local/bin/perl

###############################################################################
# Program     : GetPeptide
# $Id$
#
# Description : Prints summary of a given peptide given selection
#               atlas build, and peptide name or sequence.
#
# SBEAMS is Copyright (C) 2000-2016 Institute for Systems Biology
# This program is governed by the terms of the GNU General Public License (GPL)
# version 2 as published by the Free Software Foundation.  It is provided
# WITHOUT ANY WARRANTY.  See the full description of GPL terms in the
# LICENSE file distributed with this software.
#
###############################################################################


###############################################################################
# Set up all needed modules and objects
###############################################################################
use strict;
use Getopt::Long;
use FindBin;
use Data::Dumper;

use POSIX qw(ceil floor);

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($sbeams $sbeamsMOD $q $current_contact_id $current_username
             $PROG_NAME $USAGE %OPTIONS $QUIET $VERBOSE $DEBUG $DATABASE
             $TABLE_NAME $PROGRAM_FILE_NAME $CATEGORY $DB_TABLE_NAME
             @MENU_OPTIONS);
##use CGI::Carp qw(fatalsToBrowser croak);

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::TabMenu;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;
use SBEAMS::PeptideAtlas::ConsensusSpectrum;
use SBEAMS::PeptideAtlas::ModificationHelper;
use SBEAMS::PeptideAtlas::Utilities;
use SBEAMS::PeptideAtlas::ProtInfo qw(is_uniprot_identifier);

use SBEAMS::Proteomics::Tables;

$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);
my $modification_helper = new SBEAMS::PeptideAtlas::ModificationHelper();
my $htmlmode;
my $current_page = { organism => '', atlas_build_id => '' };

#$q = new CGI;


###############################################################################
# Set program name and usage banner for command like use
###############################################################################
$PROG_NAME = $FindBin::Script;
$USAGE = <<EOU;
Usage: $PROG_NAME [OPTIONS] key=value key=value ...
Options:
  --verbose n         Set verbosity level.  default is 0
  --quiet             Set flag to print nothing at all except errors
  --debug n           Set debug flag

 e.g.:  $PROG_NAME [OPTIONS] [keyword=value],...

EOU

#### Process options
unless (GetOptions(\%OPTIONS,"verbose:s","quiet","debug:s")) {
  print "$USAGE";
  exit;
}

$VERBOSE = $OPTIONS{"verbose"} || 0;
$QUIET = $OPTIONS{"quiet"} || 0;
$DEBUG = $OPTIONS{"debug"} || 0;

if ($DEBUG) {
  print "Options settings:\n";
  print "  VERBOSE = $VERBOSE\n";
  print "  QUIET = $QUIET\n";
  print "  DEBUG = $DEBUG\n";
}


###############################################################################
# Set Global Variables and execute main()
###############################################################################
main();
exit(0);


###############################################################################
# Main Program:
#
# Call $sbeams->Authenticate() and exit if it fails or continue if it works.
###############################################################################
sub main {

  #### Do the SBEAMS authentication and exit if a username is not returned
  exit unless ($current_username = $sbeams->Authenticate(
		 permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
					     'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
		 #connect_read_only=>1,
		 allow_anonymous_access=>1,
    ));

  #### Read in the default input parameters
  my %parameters;
  my $n_params_found = $sbeams->parse_input_parameters(
    q=>$q,
    parameters_ref=>\%parameters
      );
  $htmlmode = ( $sbeams->output_mode() eq 'html' ) ? 1 : 0;
  #### Decide what action to take based on information so far
  if ($parameters{action} eq "???") 
  {
    # Some action
  } else 
  {
    my $project_id = $sbeamsMOD->getProjectID(
      atlas_build_id => $parameters{atlas_build_id}
        );
    # TMF
    processDatabaseActions();
    $sbeamsMOD->display_page_header(project_id => $project_id,
#  onload => 'toggle_plot();',
				    init_tooltip => 1);

    handle_request(ref_parameters=>\%parameters);

    $sbeamsMOD->display_page_footer();
  }
  $sbeams->profile_sql( list => 0 );

} # end main


###############################################################################
# Process insert/update/delete, if any, then redirect
# TMF: copied this sub from ShowObservedSpectrum, then made a few
# changes
###############################################################################
sub processDatabaseActions {
  my $redirect = 0;
  my %parameters;

  $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);
  $sbeams->processStandardParameters(parameters_ref=>\%parameters);

  my $apply_action  = $q->param('apply_action');

  if ($apply_action eq "UPDATE ANNOTATION") {
    my %rowdata = (
      spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
      comment => $parameters{user_spectrum_commment}
    );

    my $PK = $sbeams->updateOrInsertRow(
      update => 1,
      # TMF
      table_name => $TBAT_PEPTIDE_INSTANCE_ANNOTATION,
      rowdata_ref => \%rowdata,
      # TMF next 2 lines
      PK => 'peptide_instance_annotation_id',
      PK_value => $parameters{peptide_instance_annotation_id},
      return_PK => 1,
      add_audit_parameters => 1
    );

    if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been updated." ); }
    else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem updating your annotation record." ); }

    $redirect++;

  } elsif ($apply_action eq "ADD ANNOTATION") {
    my $PK;
    my $error_reason= '';
    if ( ! $parameters{peptide_instance_id} ) {
      $error_reason .= "Need peptide_instance_id for ADD ANNOTATION.";
    } else {
      my %rowdata = (
	annotator_contact_id => $sbeams->getCurrent_contact_id(),
	# TMF
	#spectrum_identification_id => $parameters{spectrum_identification_id},
	peptide_instance_id => $parameters{peptide_instance_id},
	spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
	comment => $parameters{user_spectrum_commment}
      );

      $PK = $sbeams->updateOrInsertRow(
	insert => 1,
	# TMF
	table_name => $TBAT_PEPTIDE_INSTANCE_ANNOTATION,
	rowdata_ref => \%rowdata,
	return_PK => 1,
	add_audit_parameters => 1
      );
    }

    if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been added." ); }
    else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem inserting your annotation record. $error_reason" ); }

    $redirect++;

  } elsif ($apply_action eq "DELETE ANNOTATION") {
    my %rowdata = (
      record_status => 'D'
    );

    my $PK = $sbeams->updateOrInsertRow(
      update => 1,
      #TMF
      table_name => $TBAT_PEPTIDE_INSTANCE_ANNOTATION,
      rowdata_ref => \%rowdata,
      PK => 'peptide_instance_annotation_id',
      PK_value => $parameters{peptide_instance_annotation_id},
      return_PK => 1,
      add_audit_parameters => 1
    );

    if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been deleted." ); }
    else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem deleting your annotation record." ); }

    $redirect++;
  }

  if ($redirect) {
    $q->delete( 'apply_action' );
    print $q->redirect( $q->self_url() );
    exit;
  }

}


###############################################################################
# Handle Request
###############################################################################
sub handle_request {

  my %args = @_;
  $log->debug( "Start page " . time() );

  #### Process the arguments list
  my $ref_parameters = $args{'ref_parameters'}
  || die "ref_parameters not passed";

  my %parameters = %{$ref_parameters};

  #### Show current user context information
  print "<BR>\n" if ($sbeams->output_mode() eq 'html');
  #$sbeams->printUserContext();
  
  #### Get the HTML to display the tabs
  my $tabMenu = $sbeamsMOD->getTabMenu(
    parameters_ref => \%parameters,
    program_name => $PROG_NAME,
  );

  print $tabMenu->asHTML() . '<BR>' if ($sbeams->output_mode() eq 'html');


  #### Define some generic variables
  my ($i,$element,$key,$value,$line,$result,$sql);

  #### Define some variables for a query and resultset
  my %resultset = ();
  my $resultset_ref = \%resultset;
  my (%rs_params,%url_cols,%hidden_cols,%max_widths,$show_sql);

  # Get list of accessible projects
  my @accessible_project_ids = $sbeams->getAccessibleProjects();
  my $project_string = join( ",", @accessible_project_ids ) || '0';
  return unless $project_string;


  #### Read in the standard form values
  my $apply_action  = $parameters{'action'} || $parameters{'apply_action'};

  my $TABLE_NAME = $parameters{'QUERY_NAME'};
    
  #### Set some specific settings for this program
  my $CATEGORY="Get Peptide";
  my $PROGRAM_FILE_NAME = $PROG_NAME;
  my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";
  my $help_url = "$CGI_BASE_DIR/help_popup.cgi";

  # Triage of parameter handling, trying to merge 'searchWithinThis' style
  # params with peptide_name_constraint params, as both may be used in 
  # calling this page.
  # Rules: if peptide_name_constraint is set, use it
  #        else if SWT is Peptide Name, use SFT
  #        else if cookie vals set, use them
  #        else use default.
  #        
  #        if peptide_sequence_constraint is set, use it
  #        else if SWT is Peptide Sequence, us SFT
  #        else if cookie vals set, use them
  #        else use default
  #        
  #        if peptide_name_constraint is set use it,
  #        else if peptide_seq_constraint is set use it
  #        
  #        if atlas_build_id or atlas_build_name is set, use it
  #        else if organism_id or organism_name is set, use it
  #        else if cookie value is set, use it
  #        else use default
  #        
  # example invocations:       
  # GetPeptide?atlas_build_id=117&searchWithinThis=Peptide%2bName&searchForThis=PAp00439490&action=QUERY
  # GetPeptide?atlas_build_name=Yeast_TransitionAtlas_2008-02_P0.9&searchWithinThis=Peptide+Name&searchForThis=PAp00085861&query=QUERY

  my $searchValue = '';
  my $searchKey = '';

  # give me strength...
  $parameters{searchWithinThis} =~ s/\+/\ /;

  if ( $parameters{peptide_name_constraint} ) {
    $searchKey = 'Peptide Name'; 
    $searchValue =  $parameters{peptide_name_constraint};
  } elsif (  $parameters{peptide_sequence_constraint} ) {
    $searchKey = 'Peptide Sequence'; 
    $searchValue =  $parameters{peptide_sequence_constraint};
  } else {
    $searchKey = $parameters{searchWithinThis} || ''; 
    $searchValue = $parameters{searchForThis} || '';
  }

  # Check session if necessary
  unless( $searchValue ) {
    $searchValue = $sbeams->getSessionAttribute( key => 'PeptideAtlas_search_value' );
  }
  unless ($searchKey) {
    $searchKey = $sbeams->getSessionAttribute( key => 'PeptideAtlas_search_key' );
  }

  # Set value to some given peptide for first-time visitors 
  $searchValue ||= 'VSFLSALEEYTK';
  $searchKey ||= 'Peptide Sequence';

  # Everything is set, not cache within cookie/vars.
  $parameters{'searchWithinThis'} = $searchKey;
  $parameters{'searchForThis'}    = $searchValue;
  $parameters{'apply_action'}     = 'GO';

  if ( $parameters{searchWithinThis} eq 'Peptide Name' ) {
    $parameters{peptide_name_constraint} ||= $searchValue; 
  } elsif ( $parameters{searchWithinThis} eq 'Peptide Sequence' ) {
    $parameters{peptide_sequence_constraint} ||= $searchValue; 
  } else {
    $log->warn( "unknown value in searchWithinThis parameter" );
  }

  $sbeams->setSessionAttribute( value => $searchValue,
				  key => 'PeptideAtlas_search_value' );

  $sbeams->setSessionAttribute( value => $searchKey,
                                  key => 'PeptideAtlas_search_key' );

  my $alt_link = '';
  if ( $parameters{searchForThis} ) {
    $alt_link = "<A HREF='Summarize_Peptide?searchForThis=$parameters{searchForThis};query=QUERY'>View a summary </A> for this peptide across all accessible builds";
  }

  my $protein_list_sql = '';
  if ( $parameters{atlas_build_id} && $parameters{searchWithinThis} && $parameters{searchForThis}  ) {

    my $contact_id = $sbeams->getCurrent_contact_id();
    my $peptide_and = 'XXX';
    if ( $parameters{searchWithinThis} =~ /Name/ ) {
      $peptide_and = " AND P.peptide_accession = '$parameters{searchForThis}'\n";
    } else {
      $peptide_and = " AND P.peptide_sequence = '$parameters{searchForThis}'\n";
    }
    $protein_list_sql = qq~  
    SELECT DISTINCT AB.atlas_build_id
    FROM $TBAT_ATLAS_BUILD AB
    JOIN peptideatlas.dbo.protein_list_build PLB 
      ON AB.atlas_build_id = PLB.atlas_build_id
    JOIN peptideatlas.dbo.protein_list PL 
      ON PL.protein_list_id = PLB.protein_list_id
    JOIN peptideatlas.dbo.protein_list_protein PLP
      ON PL.protein_list_id = PLP.protein_list_id
    JOIN $TBAT_BIOSEQUENCE B 
      ON ( B.biosequence_set_id = AB.biosequence_set_id AND
           B.biosequence_accession = PLP.protein_name )
    JOIN $TBAT_PEPTIDE_MAPPING PM 
      ON PM.matched_biosequence_id = B.biosequence_id
    JOIN $TBAT_PEPTIDE_INSTANCE PI 
      ON PI.peptide_instance_id = PM.peptide_instance_id
    JOIN $TBAT_PEPTIDE P 
      ON PI.peptide_id = P.peptide_id
    WHERE PL.contributor_contact_id = $contact_id
      AND AB.atlas_build_id = $parameters{atlas_build_id}
      $peptide_and
    ~;
  }

  #### Get the current atlas_build_id based on parameters or session
  my $atlas_build_id = $sbeamsMOD->getCurrentAtlasBuildID(
    allow_protein_list_login => 1,
    protein_list_sql => $protein_list_sql, 
    parameters_ref => \%parameters,
    alt_link => $alt_link
  );

  if (defined($atlas_build_id) && $atlas_build_id < 0) {
    return;
  }

  # Cache in case we go out of scope later.
  $current_page->{atlas_build_id} = $atlas_build_id;

  # If we've gotten this far, user must have access to specified build
  my ( $extra_project ) = $sbeams->selectrow_array( "Select project_id FROM $TBAT_ATLAS_BUILD WHERE atlas_build_id = $atlas_build_id" );
  $project_string .= ", $extra_project";

  $parameters{atlas_build_id} = $atlas_build_id;

  # Set build_name
  my $atlas_build_name = get_atlas_build_name( atlas_build_id => $atlas_build_id );

  # Validate selected build
  my $validation_error = '';
    
  if ( !$atlas_build_id ) {
    $validation_error = "No build specified";
  } elsif ( $atlas_build_id < 0 ) {
    $validation_error = "Illegal build ID";
  } elsif ( !$sbeamsMOD->isAccessibleBuild( build_id => $atlas_build_id ) ) {
#    $validation_error = "You lack permission to access the specified build";
    $log->debug( "Must have used protein_list authentication" );
  }
  if ( $validation_error ) {
    my $error_string = $sbeams->makeErrorText( $validation_error );
    my $url = $q->self_url();
    my $url_delim = ( $url =~ /\?/ ) ? ';' : '?';
    print qq~
      <BR><BR>
      $error_string
      <BR>
      <BR>Please <A HREF="main.cgi?_tab=2;reset_id=1">choose</A> a valid Atlas Build, 
      or <A HREF="$url${url_delim}force_login=yes"> login </A> as a different user.
    ~;
    exit;
  }

  # Get peptide_instance_id for this atlas build and peptide sequence
  $sql = qq~
  select pi.peptide_instance_id
  from $TBAT_PEPTIDE_INSTANCE pi
  join $TBAT_PEPTIDE p
  on p.peptide_id = pi.peptide_id
  where pi.atlas_build_id = $atlas_build_id
    and p.peptide_sequence = 
  ~;

  # Cache values
  if ($atlas_build_name) {
    $sbeams->setSessionAttribute( value => $atlas_build_name,
                                    key => 'PeptideAtlas_build_name' );
  }
  $parameters{'atlas_build_id'} = $atlas_build_id;
  $parameters{'atlas_build_name'} = $atlas_build_name;
  $parameters{'apply_action'} = 'GO';

  # End parameter handling section

  $log->debug( "end param handling " . time() );

  ## Get and store list of atlases for use with form:  
  my (@atlas_option_id_array, @atlas_option_name_array);  

  ## get accessible atlases:
  my $sql = qq~
      SELECT atlas_build_id,atlas_build_name
      FROM $TBAT_ATLAS_BUILD
      WHERE project_id IN ( $project_string )
      AND record_status!='D'
      ORDER BY atlas_build_name
    ~;

  my @rows = $sbeams->selectSeveralColumns($sql); 
  unless ( @rows ) {
    print qq~
      <BR><BR>
      <FONT COLOR=red>Unable to use specified Atlas, please select a new one </FONT>
      <BR><A HREF="main.cgi?_tab=2">Choose new Atlas Build</A>
      ~;
    exit; 
  }

  foreach my $row (@rows) {
    my ($tmp_id, $tmp_name) = @{$row};

    push(@atlas_option_id_array, $tmp_id);
    push(@atlas_option_name_array, $tmp_name);
  }


  #### Build search options for textbox:
  my @peptide_search_constraint = ( "peptide_name_constraint", 
				    "peptide_sequence_constraint"
    );

  my @textbox_option_tags = ( "Peptide Name", 
			      "Peptide Sequence"
    );


  #### Apply any parameter adjustment logic
  $parameters{display_options} = 'ShowSQL';

  my ($selected_atlas_build_name, $selected_key, $selected_key_search);

  $apply_action=$parameters{'apply_action'};

  unless ( $apply_action eq "QUERY" || $apply_action eq "GO" ) { ## if receive from link, don't assign null

    $apply_action = $parameters{"query"};

  }

  ### if receive $parameters{atlas_build_id} from link, get atlas build name 
  #if ( $parameters{atlas_build_id} ) {
  #    for (my $i=0; $i<=$#atlas_option_id_array; $i++) {
  #        if ( $parameters{atlas_build_id} eq $atlas_option_id_array[$i] ) {
  #            $atlas_build_name = $atlas_option_name_array[$i]
  #        }
  #    }
  #}


  if ($sbeams->output_mode() eq 'html') {

#        print $sbeamsMOD->init_pa_tooltip(); 

    print "<p>";

    print "<nobr>";
    print $q->start_form(-method=>"POST",
			 -action=>"$base_url",
	);
    print $q->popup_menu(-name=> "atlas_build_name",
			 -values=> [@atlas_option_name_array],
			 -default=>$atlas_build_name,
	);
    print "&nbsp;&nbsp;Search&nbsp;";
    print $q->popup_menu(-name=> "searchWithinThis",
			 -values=> [@textbox_option_tags],
			 -default=>$searchKey,
	);
    print "&nbsp;for:&nbsp;";
    print $q->textfield( "searchForThis", $searchValue);
    print $q->submit(-name => "query", 
		     -value => 'QUERY',
		     -label => 'QUERY');
    print $q->end_form;
    print "</nobr>";

    ## xxxx $help_url

    print "</p>";
  } 

  ## store form values in %parameters:
  for (my $i=0; $i<=$#atlas_option_name_array; $i++){
    if ( $atlas_build_name eq $atlas_option_name_array[$i]) {
      $parameters{atlas_build_name} = $atlas_build_name;
      $parameters{atlas_build_id} = $atlas_option_id_array[$i];
    }
  }

  for (my $i=0; $i<=$#textbox_option_tags;$i++){
    if ( $searchKey eq $textbox_option_tags[$i]) {
      $parameters{$peptide_search_constraint[$i]} = $searchValue;
    }
  }



  #########################################################################
  #### Process all the constraints

  #### If atlas_build_id was not selected, stop here
  unless ($parameters{atlas_build_id}) {
    $sbeams->reportException(
      state => 'ERROR',
      type => 'INSUFFICIENT CONSTRAINTS',
      message => 'You must select an Atlas Build',
        );
    return;
  }


  #### Build ATLAS_BUILD constraint
  my $atlas_build_clause = $sbeams->parseConstraint2SQL(
    constraint_column=>"AB.atlas_build_id",
    constraint_type=>"int_list",
    constraint_name=>"Atlas Build",
    constraint_value=>$parameters{atlas_build_id} );
  return if ($atlas_build_clause eq '-1');




  #### Build PEPTIDE_NAME constraint
  my $peptide_name_clause = $sbeams->parseConstraint2SQL(
    constraint_column=>"P.peptide_accession",
    constraint_type=>"plain_text",
    constraint_name=>"Peptide Name",
    constraint_value=>$parameters{peptide_name_constraint} );
  return if ($peptide_name_clause eq '-1');

  #### Build PEPTIDE_SEQUENCE constraint
  my $peptide_sequence_clause = $sbeams->parseConstraint2SQL(
    constraint_column=>"P.peptide_sequence",
    constraint_type=>"plain_text",
    constraint_name=>"Peptide Sequence",
    constraint_value=>$parameters{peptide_sequence_constraint} );
  return if ($peptide_sequence_clause eq '-1');

   
  my $atlas_project_clause = "AND AB.project_id IN ( $project_string )";

  ## want to replace LIKE with = , as want a single peptide returned
  $peptide_name_clause =~ s/LIKE/=/gi;
  #print "peptide_name_clause: $peptide_name_clause <br>";

  $peptide_sequence_clause =~ s/LIKE/=/gi;
  #print "peptide_sequence_clause: $peptide_sequence_clause <br>";


  #### Define the SQL statement
  $sql = qq~
         SELECT
         P.peptide_accession, P.peptide_sequence,
         PI.best_probability, PI.n_observations, PI.n_genome_locations, 
         PI.n_protein_mappings, PM.chromosome, PM.start_in_chromosome, 
         PM.end_in_chromosome, PM.strand, BS.biosequence_name,
         P.molecular_weight, P.peptide_isoelectric_point,
         PI.n_samples, PI.n_protein_samples, PI.empirical_proteotypic_score,
         O.full_name, PI.original_protein_name,
         P.SSRCalc_relative_hydrophobicity, biosequence_seq,
				 BS.biosequence_id,
         PA.peptide_sequence, PA.peptide_annotation, PA.peptide_annotation_id, 
         PA.annotator_name, CAST(PA.comment AS VARCHAR) comment
         FROM $TBAT_PEPTIDE_INSTANCE PI
         INNER JOIN $TBAT_PEPTIDE P
          ON ( PI.peptide_id = P.peptide_id )
         INNER JOIN $TBAT_ATLAS_BUILD AB 
          ON ( PI.atlas_build_id = AB.atlas_build_id )
         LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
          ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
         LEFT JOIN $TB_ORGANISM O
          ON ( BSS.organism_id = O.organism_id )
         LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
          ON ( PI.peptide_instance_id = PM.peptide_instance_id )
         LEFT JOIN $TBAT_BIOSEQUENCE BS
          ON ( PM.matched_biosequence_id = BS.biosequence_id )
         LEFT JOIN $TB_DBXREF DBX ON ( BS.dbxref_id = DBX.dbxref_id )
         LEFT JOIN $TBAT_PEPTIDE_ANNOTATION PA ON ( PA.peptide_id = PI.peptide_id )
         WHERE 1 = 1
            $atlas_build_clause
            $peptide_name_clause
            $peptide_sequence_clause
            $atlas_project_clause
        ORDER BY PM.chromosome, BS.biosequence_name, PM.start_in_chromosome
    ~;
  unless ( $peptide_name_clause || $peptide_sequence_clause ) {
    $sbeams->display_sql(sql=>$sql);
    print qq~
      <FONT COLR=red>No name or sequence constraint found, unable to proceed</FONT>
      ~;
    return;
  }


  #########################################################################
  #### If QUERY,  display the data
  if ($apply_action =~ /QUERY|GO/i ) {

    my @rows = $sbeams->selectSeveralColumns($sql)

        or print qq~
        Peptide not found.  Please check selections and try again.<br>
	<p>
	<form method="post" action="https://db.systemsbiology.net/sbeams/cgi/PeptideAtlas/Search">
	Or, search for the peptide across all major PeptideAtlas builds:
        &nbsp;&nbsp;<input type="text" name="search_key" value="$searchValue" size="25" maxlength="120"/>
	<input type="submit" name="apply_action" value="GO" /><BR>
	~;
    $log->debug( "finished running query " . time() );


    if (@rows) {
      my (@peptide_accession, @peptide_sequence);
      my (@best_probability, @n_observations, @n_genome_locations, @n_protein_mappings);
      my (@chrom, @start_chrom, @end_chrom, @strand);
      my (%biosequence_name, @biosequence_name, %biosequence_id);
      my ( @mw, @pi, @nsamp, @nprotsamp, @epscore, @organism, @original_name, @SSRCalc_relative_hydrophobicity, @pep_annot );

      my $i=0;  ##index counter

      my %chrom_map;
      my %protein_map;
      foreach my $row (@rows) {

					my ($pa, $seq, $prob, $n_obs, $n_g_loc, $n_prot_map, 
							$chr, $s_chr, $e_chr, $str, $b_name, $mw, $pi, 
							$ns, $nps, $eps, $org, $orig_name,
							$SSRCalc_relative_hydrophobicity, $protein_sequence, $bioseq_id, @annot ) = @{$row};
					@pep_annot = @annot unless @pep_annot;
					$protein_map{$bioseq_id} ||= { name  => $b_name,
											 id    => $bioseq_id,
											 seq   => $protein_sequence,
											 level => 'tbd',
											 pep_seq => $seq };
					$peptide_accession[$i] = $pa;
					$peptide_sequence[$i] = $seq;
					$best_probability[$i] = $prob;
					$n_observations[$i] = $n_obs;
					$n_genome_locations[$i] = $n_g_loc;
					$n_protein_mappings[$i] = $n_prot_map;
					$chrom[$i] = $chr;
					$start_chrom[$i] = $s_chr;
					$end_chrom[$i] = $e_chr;
					$strand[$i] = $str;
					$biosequence_name[$i] = $b_name;
					$biosequence_name{$b_name}++;
					$mw[$i] = sprintf( "%0.2f", $mw);
					$pi[$i] = sprintf( "%0.1f", $pi );
					$nsamp[$i] = $ns;
					$nprotsamp[$i] = $nps;
					$epscore[$i] = $eps;
					$organism[$i] = $org;
					$original_name[$i] = $orig_name;
					$SSRCalc_relative_hydrophobicity[$i] = $SSRCalc_relative_hydrophobicity;
					#print "sql returns: $n_observations[$i] $sample_tag[$i] <br>";
					$biosequence_id{$bioseq_id}++;

					my $key = join( ':::', $chr, $s_chr, $e_chr, $str, $seq );

					# Could just push, thought this was clearer.
					if ( !$chrom_map{$key} ) {
						# First time through, point to arrayref
						$chrom_map{$key} = [$b_name]; 
					} else {
						# Subsequent visits push an item onto the list
						push @{$chrom_map{$key}}, $b_name; 
					}
					$i++;
      }

      ##xxxx PRINT RETURN to HTML HERE... 

      #############################################################################
      #### peptide overview
      #############################################################################
      my $summ = '<TABLE style="margin-left:15px;">';
      my $tr = 'class="hoverable"';

      my $bestp = ( $best_probability[0] == 1 ) ? 1 : sprintf( "%0.2f", $best_probability[0] );

      $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Peptide Accession',
					      value => $peptide_accession[0],
					      tr_info => $tr,
					      key_width => '20%' );
      $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Peptide Sequence',
					      tr_info => $tr,
					      value => $peptide_sequence[0] );
      $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Best Probability',
					      tr_info => $tr,
					      value => $bestp );

      # TMF: remove this conditional if/when want to release this feature to production.
      if ($parameters{'ann'}) {
	$summ .= $sbeamsMOD->encodeSectionItem( key   => 'User Assessment',
						tr_info => $tr,
						value => '<div ID="annotations_summary">-- please wait for page load --</div>' );
      }

      $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Times Observed:',
					      tr_info => $tr,
					      value => $n_observations[0] );
      $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Avg Molecular Weight',
					      tr_info => $tr,
					      value => "$mw[0]"
	  ) if $mw[0];
      $summ .= $sbeamsMOD->encodeSectionItem( key   => 'pI (approx)',
					      tr_info => $tr,
					      value => "$pi[0]"
	  ) if $pi[0];

      if ( defined $SSRCalc_relative_hydrophobicity[0] ) {
	$summ .= $sbeamsMOD->encodeSectionItem( key   => 'SSRCalc relative hydrophobicity',
						tr_info => $tr,
						value => sprintf("%.2f",$SSRCalc_relative_hydrophobicity[0])
                                           );
      }

      if ( defined $epscore[0] ) {
	$summ .= $sbeamsMOD->encodeSectionItem( key   => '# Experiments',
						tr_info => $tr,
						value => "$nsamp[0]" );
	$summ .= $sbeamsMOD->encodeSectionItem( key   => '# Protein Experiments',
						tr_info => $tr,
						value => "$nprotsamp[0]" );
	$summ .= $sbeamsMOD->encodeSectionItem( key   => 'Proteotypic score',
						tr_info => $tr,
						value => sprintf( "%0.1f", $epscore[0] ) );
      }


      $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Reference peptide',
					      tr_info => $tr,
					      value => format_refpep( \@pep_annot )
	  ) if $pep_annot[0];


      #### Deciding which clause to send to PeptideCount method present in Utilities.pm
 
      my $peptide_clause = ($peptide_name_clause) ? $peptide_name_clause : $peptide_sequence_clause;

      my($no_organisms,$no_distinct_builds)=$sbeamsMOD->PeptideCount(atlas_project_clause=>$atlas_project_clause,
								     peptide_clause=>$peptide_clause );


      my $link="$CGI_BASE_DIR/$SBEAMS_SUBDIR/Summarize_Peptide?searchForThis=$peptide_sequence[0]&apply_action=QUERY";
      my $build_html_link="<A HREF=$link TARGET=_BLANK color=blue>$no_distinct_builds</A>";
      my $org_html_link="<A HREF=$link  TARGET=_BLANK >$no_organisms</A>";
  
      $summ.=$sbeamsMOD->encodeSectionItem(key => 'Number of builds in which Peptide found',
					   tr_info=>$tr,
					   value=>$build_html_link );
                                       
      $summ.=$sbeamsMOD->encodeSectionItem(key => 'Organisms in which Peptide found',
					   tr_info=>$tr,
					   value=>$org_html_link );
  
##      print "<BR>\n";
      $summ .= "</TABLE>\n";

      print scalar $sbeams->make_toggle_section( neutraltext => $peptide_accession[0],
						   sticky => 1,
						     name => 'getpeptide_overview_div',
					  #ToDo?# tooltip => 'Show/Hide Section',
						  barlink => 1,
						  visible => 1,
						  content => $summ );

      # End first section
      $log->debug( "End overview " . time() );



      #############################################################################
      #### External Links section
      #############################################################################
      displayExternalLinksSection( pepseq =>$peptide_sequence[0],);



      #############################################################################
      #### Genome mappings section
      #############################################################################
      my $mapHTML = '<TABLE>';

      my $last_chrom = "";
      my $last_protein = "";
      my $last_seq_used_length = "";
      my $n_indices=$#peptide_accession;

      my @rows;
      my @prots;
      my $exon_bp_length_total =0;
      for my $key (sort {$a cmp $b} keys (%chrom_map)  ) {
         
					my @map = split( ':::', $key );

					my $current_chrom = $map[0];
					my $tmp_start = $map[1];
					my $tmp_end = $map[2];
					my $tmp_strand = $map[3];
					my $peptide_sequence = $map[4];
					# Select Uniprot ident if available (prev. to March 2013, selected 1st ident).
					my $current_prot_num=0;
					for (my $i=0; $i < scalar @{ $chrom_map{$key} }; $i++ ) {
						$current_prot_num = $i;
						last if ( SBEAMS::PeptideAtlas::ProtInfo::is_uniprot_identifier ( $chrom_map{$key}->[$i] ) );
					}
					my $current_prot = $chrom_map{$key}->[$current_prot_num];
					push @prots, $current_prot;
							
					# This indicates an unmapped peptide
					next unless $current_prot; 


					## $current_peptide_seq is the entire peptide sequence, even if split over 2 exons
					my $current_peptide_seq = $peptide_sequence;

					#if ($current_chrom ne $last_chrom) {
					#  $mapHTML .= "<TR><TD NOWRAP COLSPAN=2><B>Chromosome $current_chrom: </B></TD><TD></TD></TR>\n";
					#}
					my $tmp_protein = $current_prot;
					my $tmp_seq;

					#### get residues on given exons ####
					my $exon_bp_length = ceil( (abs($tmp_end - $tmp_start) + 1 + $last_seq_used_length%3 )/3.) ;
					## if the strand is negative, count residues on exon starting from end
					if ($tmp_strand eq "-") {
						if ($tmp_protein eq $last_protein) {
              $exon_bp_length_total += abs($tmp_end - $tmp_start)+1;
							$tmp_seq = substr($current_peptide_seq, 
										((length $current_peptide_seq) - floor($last_seq_used_length/3.0) - $exon_bp_length), 
										((length $current_peptide_seq) - floor($last_seq_used_length/3.0) ) );
						} else {
              
							$tmp_seq = substr($current_peptide_seq, 
										((length $current_peptide_seq) - $exon_bp_length), 
										(length $current_peptide_seq) );
              $exon_bp_length_total = abs($tmp_end - $tmp_start)+1;
						}

						#### Else from the start
					} elsif ($tmp_strand eq "+") {
						if ($tmp_protein eq $last_protein) {
              $exon_bp_length_total += abs($tmp_end - $tmp_start)+1;
							$tmp_seq = substr($current_peptide_seq, floor($last_seq_used_length/3.0),$exon_bp_length );
						} else {
							$tmp_seq = substr($current_peptide_seq, 0, $exon_bp_length);
              $exon_bp_length_total = abs($tmp_end - $tmp_start)+1;
						}

						#### Otherwise, there's no proper mapping, but show information anyway
					} else {
						$tmp_seq = $current_peptide_seq;
					}


					$last_seq_used_length = $exon_bp_length_total; 

					# Set up protein[s] display
					my $protein_display = makeProteinLink( name  => $tmp_protein, 
												 build => $parameters{atlas_build_id}); 

					my $extra = $#{$chrom_map{$key}};
					if ( $extra ) {
						my $all = join ', ', @{$chrom_map{$key}};
						my $all_links;
						for my $p ( @{$chrom_map{$key}} ) {
							$all_links .= makeProteinLink( build => $parameters{atlas_build_id},
										 name  => $p,
										target => '_prot_info' ) . "<BR>\n"; 
						}

						$mapHTML .= $sbeams->getPopupDHTML();
						my $session_key = $sbeams->getRandomString( num_chars => 20,
													char_set => ['A'..'Z', 'a'..'z', 0..9] );

						$sbeams->setSessionAttribute( key => $session_key,  value => $all_links );

						my $url = "$CGI_BASE_DIR/help_popup.cgi?title=Alternate%20Mappings;session_key=$session_key;email_link=no";
						my $more = qq~ &nbsp;&nbsp;[<A onClick=popitup("$url"); CLASS=pseudo_link>$extra more</A>]~;
						$protein_display = "<DIV TITLE='$all'>$protein_display $more</DIV>";
					}


					my $ens_link = '';
					my $range = '';
					my $kaviar_link = '';
					my $links = '';
					if ( defined $tmp_start && defined $tmp_end && $tmp_end ) {
						$ens_link = makeGenomeLink( start => $tmp_start,
											end => $tmp_end,
											strand => $tmp_strand,
											chrom => $current_chrom,
											acc => $current_prot,
											org => $organism[0] );

						$range = $tmp_start . '-' . $tmp_end;
						$kaviar_link = makeKaviarLink( start => $tmp_start,
									 end => $tmp_end,
									 strand => $tmp_strand,
									 chrom => $current_chrom,
									 acc => $current_prot,
									 org => $organism[0],
									 build_id => $parameters{atlas_build_id} );
						$links = $ens_link if $ens_link;
						if ( $links && $kaviar_link ) {
							$links .= ",$kaviar_link";
						}
					}

					$current_chrom ||= $sbeams->makeInactiveText('n/a');
					$tmp_strand = ( $tmp_strand =~ /\?/ ) ? $sbeams->makeInactiveText('n/a') : "<B>$tmp_strand</B>";
					push @rows, [ $current_chrom, $protein_display, $tmp_seq, $range, $tmp_strand, $links ] if $tmp_seq;

					$last_chrom = $current_chrom;
					$last_protein = $current_prot;

      } # end for


      #### If there are some protein entries to display
      if ( @rows ) {
	unshift @rows, ['Chr', 'Protein', 'Residues on Exon', 'Exon Range', 'Strand', 'links' ];
	$mapHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
						    nowrap => [ 1..6 ],
						    rows_to_show => 5,
						    bkg_interval => 3,
						    align  => [qw(center left left center center)],
						    rows => \@rows );

	# display protein names as gaggle microformat
	if ($sbeams->output_mode() eq 'html') {
	  my $organism = $sbeamsMOD->getCurrentAtlasOrganism( parameters_ref => { atlas_build_id => $current_page->{atlas_build_id} } );
	  my @proteins = keys( %biosequence_name );
	  my $protein_microformat = $sbeams->getGaggleMicroformat( name => "Protein(s) in which peptide is found",
								   organism => $organism, 
								   data => \@proteins,
								   object => 'namelist',
								   type => 'direct' );

	  $mapHTML .= $protein_microformat;
	}

	#### Otherwise, just confess what the original name was
      } else {
	$mapHTML .= qq~
    <TR><TD COLSPAN=2>
    <FONT COLOR=green>
    This peptide was identified in our original Sequest search, but
    cannot be mapped to the reference database.<BR>
    ~;
    $mapHTML .= "The original name from the search was $original_name[0]\n<BR>" if $original_name[0];
    $mapHTML .= qq~
    Click <A HREF=http://www.ncbi.nlm.nih.gov/blast/Blast.cgi?PROGRAM=blastp&DATABASE=nr&OVERVIEW=TRUE&EXPECT=1000&FILTER=L&QUERY=$peptide_sequence[0] TARGET=_blastit> here </A> to BLAST search this sequence at NCBI.
    </FONT>
    </TD></TR>
    ~;
      }


      my $bioseqs = join( ',', keys( %biosequence_id ) );
      my $compare_link = '';
      if ( $bioseqs !~ /,/ ) {
	my $text = $sbeams->makeInactiveText( 'Compare Proteins' );
  	$compare_link = "<TR><TD COLSPAN=3><DIV TITLE='Cannot run alignment with only one sequence'>$text</DIV></TD></TR>\n";
      } else  {
  	$compare_link = "<TR><TD COLSPAN=3><A HREF=compareProteins?pepseq=$peptide_sequence[0];bioseq_id=$bioseqs>Compare Proteins</A></TD></TR>\n";
      }
      $mapHTML .= $compare_link;

      $mapHTML .= "</TABLE>\n";

      $n_genome_locations[0] = 0 if $n_genome_locations[0] < 0;

      print scalar $sbeams->make_toggle_section( neutraltext => "Genome Mappings: $n_genome_locations[0]",
						   sticky => 1,
						     name => 'genome_mappings_div',
					  #ToDo?# tooltip => 'Show/Hide Section',
						  barlink => 1,
						  visible => 1,
						  content => $mapHTML );

      #  End mapping loop 
      $log->debug( "End genome mapping " . time() );




      #############################################################################
      #### Protein Mapping section
      #############################################################################
      print get_protein_mapping_widget( \%protein_map, \%parameters );




      #############################################################################
      #### Modified Peptides section
      #############################################################################
      my $is_origene = 0;
      if ($atlas_build_name =~ /Origene/i){
	$is_origene = 1;
      }

      my $modHTML = "<TABLE>";

      my $mseq_idx = 0;      # modified peptide sequence
      my $chrg_idx = 1;      # charge
      my $mz_idx = 2;        # monoisotopic parent m/z
      my $prob_idx = 3;      # best probability
      my $nobs_idx = 4;      # number observations
      my $nsib_idx = 5;      # num siblings
      my $smpl_idx = 6;      # sample IDs
      my $spec_idx = 7;      # consensus spectrum
      my $ref_idx = 8;      # reference spectrum index
      my $ce_idx = 9;      # ce_stepping index

      my $modSQL = qq~
  SELECT distinct
  modified_peptide_sequence, 
  MPI.peptide_charge, 
  MPI.monoisotopic_parent_mz,
  MPI.best_probability, 
  MPI.n_observations, MPI.n_sibling_peptides, MPI.sample_ids  
  FROM $TBAT_PEPTIDE_INSTANCE PI
  INNER JOIN $TBAT_PEPTIDE P
   ON ( PI.peptide_id = P.peptide_id )
  JOIN $TBAT_MODIFIED_PEPTIDE_INSTANCE MPI
   ON ( PI.peptide_instance_id = MPI.peptide_instance_id )
  INNER JOIN $TBAT_ATLAS_BUILD AB 
   ON ( PI.atlas_build_id = AB.atlas_build_id )
  LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
   ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
  LEFT JOIN $TB_ORGANISM O
   ON ( BSS.organism_id = O.organism_id )
  LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
   ON ( PI.peptide_instance_id = PM.peptide_instance_id )
  LEFT JOIN $TBAT_BIOSEQUENCE BS
   ON ( PM.matched_biosequence_id = BS.biosequence_id )
  LEFT JOIN $TB_DBXREF DBX ON ( BS.dbxref_id = DBX.dbxref_id )
  WHERE 1 = 1
     $atlas_build_clause
     $peptide_name_clause
     $peptide_sequence_clause
  ORDER BY modified_peptide_sequence, MPI.peptide_charge ASC
  ~;

      #$sbeams->display_sql(sql=>$modSQL);
      my @mod_peps = $sbeams->selectSeveralColumns( $modSQL );

      # Use build-specific library if warranted
      my $lib_id = $sbeamsMOD->getBuildConsensusLib( build_id => $current_page->{atlas_build_id} );


      my $cs_obj = SBEAMS::PeptideAtlas::ConsensusSpectrum->new();
      $cs_obj->setSBEAMS( $sbeams );
      my $consensus;
      if ($is_origene){
	$consensus = $cs_obj->spectrum_search_origene( seq => $peptide_sequence[0] ); 
      } else {
	$consensus = $cs_obj->spectrum_search( seq => $peptide_sequence[0], project_ids => $project_string );
      }

      my $reference = $cs_obj->spectrum_search( seq => $peptide_sequence[0],
						project_ids => $project_string,
						lib_id => '322, 331, 353',
						rm_path_constraint => 1 );

      #### If a result is returned
      my $display_ce = 0;

      if ( scalar @mod_peps ) {
	$modHTML .= $sbeams->getPopupDHTML();

	my $ce_ids;
	if ( $cs_obj->has_QTOF_stepping( seq => $peptide_sequence[0] ) ) {
	  $ce_ids = $cs_obj->get_QTOF_stepping( seq => $peptide_sequence[0] ); 
	}
	$q->delete( 'mod_seq' );
	$q->delete( 'charge' );
	my $spec_url = $q->self_url();
	#### Loops through resultset and do formatting
	for my $pep ( @mod_peps ) {
	  # Originally showed only one consensus per peptide ion, now
	  # show as a list, with default in first position.
	  my %all_consensus;
	  $pep->[$spec_idx] = '';
	  for my $c_spectrum ( @$consensus ) {
	    if ( $c_spectrum->[2] == $pep->[$chrg_idx] ) {

	      if ( $peptide_sequence[0] eq $pep->[$mseq_idx] ) {
		# No mods except charge
		next if $c_spectrum->[8] && $c_spectrum->[8] ne $pep->[$mseq_idx];
	      } else {
		next if !$c_spectrum->[8] || $c_spectrum->[8] ne $pep->[$mseq_idx];
	      }
	      my $default_txt = ( $lib_id eq $c_spectrum->[7] ) ? '(Build default)' : '';
	      my $title = "View consensus spectrum from the $c_spectrum->[10] library $default_txt"; 
	      $all_consensus{$c_spectrum->[7]} = "<A HREF='ShowConsensusSpectrum?consensus_library_spectrum_id=$c_spectrum->[0];ymax=11000' TARGET=blank><IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='$title'></A>";
	    }
	  }
	  my $best = '';
	  my $rest = '';
	  if ( $is_origene){
	    foreach my $l (qw (345 346 347 348 349)){
	      if ($l eq 345){
		$rest .= $all_consensus{$l};
	      }else{
		$rest .= "<TD>$all_consensus{$l}</TD>\n"; 
	      }
	    }
	  } else {
	    for my $l ( sort { $a <=> $b } ( keys( %all_consensus ) ) ) {
	      if ( $lib_id && $l eq $lib_id ) {
		$best .= $all_consensus{$l};
	      } else {
		$rest .= ( $rest ) ? '&nbsp;&nbsp;' . $all_consensus{$l} : $all_consensus{$l};
	      }
	    }
	  }
	  if ( $best ) {
	    $pep->[$spec_idx] = $best;
	    if ( $rest ) {
	      $pep->[$spec_idx] .= "&nbsp;&nbsp;$rest";
	    }
	  } elsif ( $rest ) {
	    $pep->[$spec_idx] = $rest;
	  }

	  unless ( $sbeams->isGuestUser() || $is_origene ) {
	    my $ref_spectra = '';
	    for my $r_spectrum ( @$reference ) {
	      if ( $r_spectrum->[2] == $pep->[$chrg_idx] ) {

		if ( $peptide_sequence[0] eq $pep->[$mseq_idx] ) {
		  # No mods except charge
		  next if $r_spectrum->[8] && $r_spectrum->[8] ne $pep->[$mseq_idx];
		} else {
		  next if !$r_spectrum->[8] || $r_spectrum->[8] ne $pep->[$mseq_idx];
		}
		my $title = "View reference peptide consensus spectrum from the $r_spectrum->[10] library";

		my $sep = ( $ref_spectra ) ? '&nbsp;' : '';
		$ref_spectra .= $sep . "<A HREF='ShowConsensusSpectrum?consensus_library_spectrum_id=$r_spectrum->[0];ymax=11000' TARGET=blank><IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='$title'></A>";
	      }
	    }
	    $pep->[$ref_idx] = $ref_spectra;
	  }
			
	  my $ce_key = $pep->[$mseq_idx] . $pep->[$chrg_idx];
	  my $ce_link = '&nbsp;';
	  if ( !$sbeams->isGuestUser() && $ce_ids->{$ce_key} ) {
	    my $title = "View +$pep->[$chrg_idx] spectra for $pep->[$mseq_idx] on QTOF at various CE values";
	    my $max_mz = ( int( $pep->[$mz_idx] * $pep->[$chrg_idx] / 200 ) * 200 );
	    my $param_str = "xmin=200;xmax=$max_mz";
	    for my $opt ( 'medium','high','low','mhigh', 'mlow' ) {
	      my $id = $ce_ids->{$ce_key}->{$opt} || '';
	      $param_str .= ";$opt=$id";
	    }
        
	    $ce_link = "<A HREF='ShowCESpectralPlot?$param_str' TARGET='_CE_spectrum'><IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='$title'></A>";
	    $display_ce=1;
	  }
	  $pep->[$ce_idx] = $ce_link unless ($sbeams->isGuestUser() || $is_origene || ! $display_ce);


	  # Final formatting for list items
	  $pep->[$mz_idx] = sprintf("%0.4f", $pep->[$mz_idx]);  # parent m/z
	  $pep->[$prob_idx] = sprintf("%0.2f", $pep->[$prob_idx]) unless $pep->[$prob_idx] == 1; # probability
	  $pep->[$prob_idx] = 1 if $pep->[$prob_idx] == 1; # huh?
	  $pep->[$nsib_idx] = sprintf("%0.1f", $pep->[$nsib_idx]) if $pep->[$nsib_idx]; # number of siblings
	  $pep->[$smpl_idx] = sample_view( $pep->[$smpl_idx] ); # Sample IDs, keep list under control

	  my $img = "<IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='View spectra for $pep->[$mseq_idx] (+$pep->[$chrg_idx])'>";

	  my $sep = ( $spec_url =~ /\?/ ) ? ';' : '?';
	  push @{$pep}, "<a href='${spec_url}${sep}charge=$pep->[$chrg_idx];mod_seq=$pep->[$mseq_idx]#Modified Peptides'>$img</a>";

	  $pep->[$mseq_idx] = $sbeamsMOD->formatMassMods( $pep->[$mseq_idx] );
	}

	#### Add table column headings
	my $column_headings = ['Modified Sequence', 'Charge', 'Mono Parent m/z', 'Best Prob', '# Obs', '# Siblings', 'Experiment IDs', 'Consensus Spectra' ];
	push @{$column_headings},  '<div title ="Synthetic Peptide Reference Spectra from SRM Atlas">Reference</div>' unless ($sbeams->isGuestUser() || $is_origene);
	push @{$column_headings},  'CE_range' unless ($sbeams->isGuestUser() || $is_origene || ! $display_ce);
	push @{$column_headings}, '<div title="Filter applies to Individual Spectra section below">Spectrum Filter</div>';

	unshift @mod_peps, $column_headings;

	#### Format table
	$modHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
						    align  => [qw(left center right right right center center center center center)], 
						    bkg_interval => 3,
						    rows => \@mod_peps,
						    rows_to_show => 10,
						    nowrap => [1..7] );
	if ( $is_origene){
	  my $str = qq~
          <tr ALIGN=CENTER BGCOLOR="#CCC" >
          <td>ITCID</td>
          <td>FTCID</td>
          <td>ITETD</td>
          <td>FTETD</td>
          <td>HCD</td>
          </tr>
         ~;
	  my @lines = split ("\n", $modHTML);
	  my $flag=0;
	  foreach (@lines){
	    if ($_ =~ /Modified Sequence/){ 
	      s/<td/<td rowspan="2"/i;
	      $flag=1;
	      next;
	    }
	    if ($flag){
	      if (/>Consensus Spectra/i){
		s/<td/<td colspan="5"/i;
	      } else {
		s/<td/<td rowspan="2"/i;
	      }
	    }
	    if ($flag && /<\/tr>/i){
	      s/$/$str/;
	      last;
	    }
	  } 
	  $modHTML = join("\n", @lines);
	}


	$modHTML .= "</TABLE>\n";

	#### Display table
	print scalar $sbeams->make_toggle_section( neutraltext => "Modified Peptides",
						   sticky => 1,
						     name => 'getprot_mod_peps_div',
					  #ToDo?# tooltip => 'Show/Hide Section',
						  barlink => 1,
						  visible => 1,
						  content => $modHTML );

      } # Modified Peptides Section
      $log->debug( "End modified peptides " . time() );



      # Individual Spectra Placeholder

      #############################################################################
      #### Spectra section
      #############################################################################
      my $spectraHTML = '<TABLE>';

      my $ispectra_clause = '';
      my $section_text = 'Individual Spectra';
      if ( $parameters{mod_seq} && $parameters{charge} ) {
	$ispectra_clause = qq~
           AND modified_peptide_sequence = '$parameters{mod_seq}'
           AND MPI.peptide_charge = $parameters{charge}
        ~;
	$section_text .= ' (filtered)';
      }

      my %colnameidx = ();
      my @column_titles = ();
      my @column_array = (
	["modpep", "modified_peptide_sequence", "Modified Sequence"],
	["chg", "MPI.peptide_charge","Chg"],
	["sample_id", "SMP.sample_id","Smpl"],
	["instrument_name", "I.instrument_name","Instr"],
	["probability", "SI.probability","Prob"],
	["spectrum_name", "S.spectrum_name","Spectrum Name"],
	["avg_prob", "AVG(SAL.level_probability)","Avg Eval"],
	["frg_type", "FRG.FRAGMENTATION_TYPE","Fragmentation Type"],
	["spectrum", "SI.spectrum_identification_id","Spectrum"],
	["chromatogram", "''","Chromatogram"],
	["chimera_level", "S.chimera_level","Chimera Level"],
	["precursor_intensity", "S.precursor_intensity", "Precursor Intensity (x10^6)"],
	["scan_time", "scan_time", "RT"],
	["collision_energy","collision_energy", "CE"],
	["ptm_sequence", "SPI.ptm_sequence","PTM Sequence"],
	["sal_prob", "COUNT(SAL.level_probability)","SAL Prob"],
	["sample_tag", "SMP.sample_tag", "Experiment Tag"],
	["total_ion_current", "S.total_ion_current", "TIC (x10^6)"],
	["signal_to_noise", "S.signal_to_noise", "S/N"],
      );
      my $columns_clause = $sbeams->build_SQL_columns_list(
	column_array_ref=>\@column_array,
	colnameidx_ref=>\%colnameidx,
	column_titles_ref=>\@column_titles
      );


      my $modSQL = qq~
  SELECT $columns_clause 
    FROM $TBAT_PEPTIDE_INSTANCE PI
   INNER JOIN $TBAT_PEPTIDE P
         ON ( PI.peptide_id = P.peptide_id )
    JOIN $TBAT_MODIFIED_PEPTIDE_INSTANCE MPI
         ON ( PI.peptide_instance_id = MPI.peptide_instance_id )
   INNER JOIN $TBAT_ATLAS_BUILD AB
         ON ( PI.atlas_build_id = AB.atlas_build_id )
    LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
         ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
    LEFT JOIN $TB_ORGANISM O
         ON ( BSS.organism_id = O.organism_id )
   INNER JOIN $TBAT_SPECTRUM_IDENTIFICATION SI
         ON ( MPI.modified_peptide_instance_id = SI.modified_peptide_instance_id )
    LEFT JOIN $TBAT_SPECTRUM_PTM_IDENTIFICATION SPI
         ON ( SI.spectrum_identification_id = SPI.spectrum_identification_id)
    LEFT JOIN $TBAT_SPECTRUM S
         ON ( SI.spectrum_id = S.spectrum_id )
    LEFT JOIN $TBAT_FRAGMENTATION_TYPE FRG
         ON (FRG.FRAGMENTATION_TYPE_ID = S.FRAGMENTATION_TYPE_ID)
    LEFT JOIN $TBAT_SAMPLE SMP
         ON ( S.sample_id = SMP.sample_id )
    LEFT JOIN $TBPR_INSTRUMENT I
         ON ( SMP.instrument_model_id = I.instrument_id )
    LEFT JOIN $TBAT_SPECTRUM_ANNOTATION SA
         ON ( SA.spectrum_identification_id = SI.spectrum_identification_id AND
	      SA.spectrum_id = S.spectrum_id )
	 AND SA.record_status != 'D'
    LEFT JOIN $TBAT_SPECTRUM_ANNOTATION_LEVEL  SAL
         ON ( SAL.spectrum_annotation_level_id = SA.spectrum_annotation_level_id )
   WHERE 1 = 1
     $atlas_build_clause
     $peptide_name_clause
     $peptide_sequence_clause
     $ispectra_clause
  GROUP BY modified_peptide_sequence, MPI.peptide_charge,
         SMP.sample_id,I.instrument_name, SI.probability, S.spectrum_name,
         SI.spectrum_identification_id, SMP.sample_tag,scan_time,
         collision_energy, SPI.ptm_sequence, FRG.FRAGMENTATION_TYPE,
         S.chimera_level,S.precursor_intensity,S.total_ion_current,S.signal_to_noise
  ORDER BY modified_peptide_sequence,
           MPI.peptide_charge,
           I.instrument_name,
           S.precursor_intensity DESC,
           S.total_ion_current DESC,
           S.signal_to_noise DESC 
  ~;

      #$sbeams->display_sql(sql=>$modSQL);
      #my @mod_peps;
      #my $sth = $sbeams->get_statement_handle( $modSQL );

      $sbeams->fetchResultSet(
        sql_query=>$modSQL,
        resultset_ref=>$resultset_ref,
        use_caching => 0 
      );

      my (@ptm_peps,%ptm_score_summary);
      postProcessResultset(
														rs_params_ref=>\%rs_params,
														resultset_ref=>$resultset_ref,
														query_parameters_ref=>\%parameters,
														column_titles_ref=>\@column_titles,
														hidden_cols => \%hidden_cols,
														ptm_score_summary_ref =>\%ptm_score_summary,
														ptm_peps_ref => \@ptm_peps);

      my $spectra_display = $sbeamsMOD->get_individual_spectra_display( 
																									column_titles_ref=>\@column_titles,
																									colnameidx_ref => \%colnameidx,
																									resultset_ref=> $resultset_ref,
																									hidden_cols_ref=>\%hidden_cols );

      my $help_me = get_table_help( 'individual_spectra' );

      $spectraHTML .= "<TR><TD ALIGN=left>$help_me</TD></TR><TR><TD>$spectra_display</TD></TR></TABLE>";

      print scalar $sbeams->make_toggle_section( neutraltext => $section_text,
						 sticky => 1,
						 name => 'getprot_indiv_spec_div',
						 #ToDo?# tooltip => 'Show/Hide Section',
						 barlink => 1,
						 visible => 1,
						 content => $spectraHTML )
	  if $htmlmode;


      #############################################################################
      #### PTM Spectra
      #############################################################################
      if (@ptm_peps){
	$spectraHTML = '';
	$spectraHTML = $sbeams->getPopupDHTML();

	$resultset_ref->{data_ref} = \@ptm_peps; 

	$spectra_display = $sbeamsMOD->get_individual_spectra_display(
	  column_titles_ref=>\@column_titles,
	  colnameidx_ref => \%colnameidx,
	  resultset_ref=> $resultset_ref,
	  hidden_cols_ref=>\%hidden_cols );
	$spectra_display =~ s/<table/<table name="ptm_spectra"/i;

	print qq~
			 <style>
				.ptm_ll {background:red;}
				.ptm_ml {background:orange;}
				.ptm_l {background:purple;}
				.ptm_m {background:grey;}
        .ptm_h {background:#007eca;}
        .ptm_mh {background:skyblue;}
        .ptm_hh {background:green;}
			 </style>
			~;

	my $PTM_color = qq~
			 <table>
				<tr align="CENTER" bgcolor="#CCCCCC">
				<td>PTM Probability Score: </td> 
				<td> 0 - 0.01 </td>
				<td class="ptm_ll" style="width: 10px; height: 5px;"></td>
				<td> 0.01 - 0.05 </td>
				<td class="ptm_ml" style="width: 10px; height: 5px;"></td>
				<td> 0.05 - 0.19 </td>
				<td class="ptm_l" style="width: 10px; height: 5px;"></td>
				<td> 0.19 - 0.81 </td> 
				<td class="ptm_m" style="width: 10px; height: 5px;"></td>
        <td> 0.81 - 0.95 </td>
        <td class="ptm_h" style="width: 10px; height: 5px;"></td>
        <td> 0.95 - 0.99 </td>
        <td class="ptm_mh" style="width: 10px; height: 5px;"></td>
        <td> 0.99 - 1 </td>
        <td class="ptm_hh" style="width: 10px; height: 5px;"></td>
				</tr>
			 </table>
			~;

	my $GV = SBEAMS::Connection::GoogleVisualization->new();
	my $ptm_summary_chart = $GV->drawPTMHisChart(data=> \%ptm_score_summary);


	$spectraHTML .= "<TABLE><TR><TD>$ptm_summary_chart\n$PTM_color</TD></TR><TR><TD>$spectra_display</TD></TR></TABLE>";

	#### Display table
	print scalar $sbeams->make_toggle_section( neutraltext => "PTM Spectra",
						   sticky => 1,
						   name => 'ptm_spectra_div',
						   #ToDo?# tooltip => 'Show/Hide Section',
						   barlink => 1,
						   visible => 1,
						   content => $spectraHTML )
	    if $htmlmode;


	print( <<"		END" );
	<script LANGUAGE="JavaScript" TYPE="text/javascript">
	  var indiv_spec = document.getElementsByName("ptm_spectra");
	  var rows = indiv_spec[0].getElementsByTagName('TR');	
          var j=3;
	  while (j<=rows.length) {
	    var aas = rows[j].cells[0].innerHTML.split('\\)'); 
	    var newInnerHTML = '';
	    var re;
	    for (var i=0; i < aas.length; i++){
	      if (aas[i].match(/\\(/g)){ 
					var aa = aas[i].split('\\(');
					var prob = parseFloat(aa[1]);
					if (aas[i].match(/\\[...\\]\\(/g)){ 
						re =  new RegExp('(\\\\w)(\\\\[...\\\\])\\\\('+aa[1], "g"); 
						if (prob < 0.01 ){   
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_ll">\$1</span>\$2');
						} else if (prob >=0.01 && prob < 0.05){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_ml">\$1</span>\$2'); 
						} else if (prob >= 0.05 && prob < 0.19 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_l">\$1</span>\$2'); 
						}else if (prob >= 0.19 && prob < 0.81 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_m">\$1</span>\$2');
						}else if (prob >= 0.81 && prob < 0.95 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_h">\$1</span>\$2');
						}else if (prob >= 0.95 && prob < 0.99 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_mh">\$1</span>\$2');
						}else {
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_hh">\$1</span>\$2'); 
						}
					}else{
						re =  new RegExp('(\\\\w)\\\\('+aa[1], "g");
						if (prob < 0.01 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_ll">\$1</span>');
						} else if (prob >=0.01 && prob < 0.05){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_ml">\$1</span>');
						} else if (prob >= 0.05 && prob < 0.19 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_l">\$1</span>');
						}else if (prob >= 0.19 && prob < 0.81 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_m">\$1</span>');
						}else if (prob >= 0.81 && prob < 0.95 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_h">\$1</span>');
						}else if (prob >= 0.95 && prob < 0.99 ){
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_mh">\$1</span>');
						}else {
							aas[i] = aas[i].replace(re, '<span onmouseover="showTooltip(event,'+ aa[1] +')" onmouseout="hideTooltip()" class="ptm_hh">\$1</span>');
						}
					}
				   newInnerHTML += aas[i] ;
				} else {
			  	newInnerHTML += aas[i];
	      }
	    }
	    re = new RegExp('(\\\\[...\\\\])', "g");  
	    newInnerHTML = newInnerHTML.replace (re, "<span class='aa_mod'>\$1</span>");
	    rows[j].cells[0].innerHTML = newInnerHTML;
	    j++;
	  }
	</script>
		END
      }
      $log->debug( "End spectra " . time() );





      ## LM: did not verify new L&F of this section -- ToDo
      #############################################################################
      #### User Annotations Section
      #############################################################################
      # TMF: remove this conditional if/when want to release this feature to production.
      if ($parameters{'ann'}) {
	my $hidden_form_fields = '<INPUT TYPE="hidden" NAME="ann" VALUE="1">';
	print &printUserAnnotations(
	  peptide_sequence => $parameters{'peptide_sequence_constraint'},
	  peptide_name => $parameters{'peptide_name_constraint'},
	  parameters_href => \%parameters,
	  form_fields => $hidden_form_fields
	    );
      }






      #############################################################################
      #### Validated Transitions Section
      #############################################################################
      my $mrm_transitions = $sbeamsMOD->get_mrm_transitions( accessions => [$peptide_accession[0]] );

      #### If a result is returned
      if ( scalar @$mrm_transitions ) {
	my $transitionHTML = '';
#    $transitionHTML .= $sbeams->getPopupDHTML();

	#### Loop through resultset and do formatting
	for my $pep ( @$mrm_transitions ) {
	  my $accession = shift( @$pep );
	  $pep->[0] = $sbeamsMOD->formatMassMods( $pep->[0] );
	  $pep->[2] = sprintf("%0.2f", $pep->[2]); # . '&nbsp;';
	  $pep->[3] = sprintf("%0.2f", $pep->[3]); # . '&nbsp;';
	  $pep->[5] = sprintf("%0.1f", $pep->[5]); # . '&nbsp;';
	  $pep->[6] = sprintf("%0.0f", $pep->[6]); # . '&nbsp;';
	  $pep->[7] = sprintf("%0.1f", $pep->[7]); # . '&nbsp;';
	  $pep->[8] = sprintf("%0.1f", $pep->[8]); # . '&nbsp;';
#      $pep->[1] .= '&nbsp;';
#      $pep->[6] .= '&nbsp;';
#      $pep->[7] .= '&nbsp;';

	  # trim off extra peak label stuff, like mass delta and alt annots.
#      ($pep->[4]) = $pep->[4] =~ /^([a-zA-Z]\d+)/;
	  ($pep->[4]) = $pep->[4] =~ /^([^\/]+)\/*/;
      
	  for my $idx ( 0..$#{$pep} ) {
	    $pep->[$idx] = $sbeams->makeInactiveText('n/a') if !defined $pep->[$idx];
	  }
	}
	my @labels = ( 'Sequence', 'Charge', 'q1_mz', 'q3_mz', 'Label', 'Intensity', 'CE', 'RT', 'SSRCalc', 'Instr', 'Annotator', 'Quality' );

	#### Add table column headings
	unshift @$mrm_transitions, \@labels;

	#### Format table
	$transitionHTML .= $sbeamsMOD->encodeSectionTable( header => 1,
							   set_download => 1,
							   bkg_interval => 3,
							   align  => [qw(left center right right center right right right right left left left)],
							   rows => $mrm_transitions );



	#### Display table
	if ($#{$mrm_transitions}) {
	  my $annot_help = get_table_help( 'annotated_transitions' );

	  print scalar $sbeams->make_toggle_section( neutraltext => 'Annotated Transitions',
						     sticky => 1,
						     name => 'getprot_valid_trans_div',
						     #ToDo?# tooltip => 'Show/Hide Section',
						     barlink => 1,
						     visible => 1,
						     content => "<TABLE><TR><TD COLSPAN='5'>$annot_help</TD></TR>$transitionHTML</TABLE>" );
	}

      }


      #############################################################################
      #### Reference Peptides Section
      #############################################################################
      my $marker_peptides = get_synthesized_peptides( $peptide_accession[0] );

      #### If a result is returned
      if ( scalar @$marker_peptides ) {
	my $markerHTML = '';
#    $transitionHTML .= $sbeams->getPopupDHTML();

	#### Loops through resultset and do formatting
	for my $pep ( @$marker_peptides ) {
	  $pep->[4] = $sbeamsMOD->formatMassMods( $pep->[4] );
	  $pep->[2] = $sbeams->makeInactiveText('n/a') if !$pep->[2];
	}
	my @labels = ( 'Peptide Sequence', 'Type', 'Publication', 'Annotator', 'Modified Sequence' );

	#### Add table column headings
	unshift @$marker_peptides, \@labels;

	#### Format table
	$markerHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
						       colspan => 1,  #ugh...
						       bkg_interval => 3,
						       align  => [qw(left center left left center)],
						       rows => $marker_peptides );

	if ($#{$marker_peptides}) {
	  print scalar $sbeams->make_toggle_section( neutraltext => 'Reference Peptides',
						     sticky => 1,
						     name => 'getpep_transitions_div',
						     #ToDo?# tooltip => 'Show/Hide Section',
						     barlink => 1,
						     visible => 1,
						     content => "<TABLE>$markerHTML</TABLE>" );
	}

	$log->debug( "End validated Trans " . time() );
      }




      #############################################################################
      #### Samples Section
      #############################################################################
      my $sampleSQL = qq ~
     SELECT sample_title, PIS.n_observations, PI.n_observations, 
		 S.sample_id, ASB.n_searched_spectra 
     FROM $TBAT_PEPTIDE_INSTANCE PI
     INNER JOIN $TBAT_PEPTIDE P
      ON ( PI.peptide_id = P.peptide_id )
     INNER JOIN $TBAT_ATLAS_BUILD AB 
      ON ( PI.atlas_build_id = AB.atlas_build_id )
     INNER JOIN $TBAT_PEPTIDE_INSTANCE_SEARCH_BATCH PIS
      ON ( PI.peptide_instance_id = PIS.peptide_instance_id )
     INNER JOIN $TBAT_ATLAS_SEARCH_BATCH ASB
      ON ( PIS.atlas_search_batch_id = ASB.atlas_search_batch_id )
     INNER JOIN $TBAT_SAMPLE S
      ON ( ASB.sample_id = S.sample_id )
		 JOIN $TBAT_ATLAS_BUILD_SEARCH_BATCH ABSB 
			ON ( ABSB.atlas_build_id        = AB.atlas_build_id AND
		       ABSB.atlas_search_batch_id = ASB.atlas_search_batch_id )

     WHERE 1 = 1
     $atlas_build_clause
     $peptide_name_clause
     $peptide_sequence_clause
     ORDER BY sample_title ASC
  ~;

      my @samples = $sbeams->selectSeveralColumns( $sampleSQL );
      my $n_obs = [];
      my $obs_per_million = [];
      my $table_samples = [];
      my $total = 0;
      my $inst_obs;
      for my $sample ( @samples ) {
	$inst_obs ||= $sample->[2];
	if ( $sample->[4] ) {
	  $sample->[4] = sprintf( "%0.1f",( $sample->[1]/$sample->[4] ) * 1000000 );
	} else {
	  $sample->[4] = 'null';
	}
	my $title = $sample->[0];
	$title =~ s/\W//g;
	push @$n_obs, [ $title, $sample->[1] ];
	push @$obs_per_million, [ $title, $sample->[4] ];
	push @$table_samples, $sample->[3];
	$total += $sample->[1];
      }
      unless ( $total == $inst_obs ) {
	$log->error( "mismatch in sample count!!! $total <> $inst_obs " );
      }


      my ($sheader, $sHTML) = $sbeamsMOD->getSamplePlotDisplay( n_obs => $n_obs,
								no_header => 1,
								obs_per_million => $obs_per_million );

      my $peptide_clause = $peptide_name_clause || $peptide_sequence_clause || '';
      $atlas_build_clause =~ s/AB/PI/g;

      my $tHTML = $sbeamsMOD->getDetailedSampleDisplay( sample_ids => $table_samples,
							build_clause => $atlas_build_clause,
							peptide_clause => $peptide_clause,
							rows_to_show => 10,
							max_rows => 500 );



      print scalar $sbeams->make_toggle_section( neutraltext => 'Observed in Experiments',
						 sticky => 1,
						 name => 'getprot_obs_sample_div',
						 #ToDo?# tooltip => 'Show/Hide Section',
						 barlink => 1,
						 visible => 1,
						 content => "<TABLE>$sHTML<TR><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>$tHTML</TABLE>" );

    }


    print "<br/><br/>\n";

    #### If QUERY was not selected, then tell the user to enter some parameters
  } else {

    if ($sbeams->invocation_mode() eq 'http') {
      print "<H4>Select parameters above and press QUERY</H4>\n";
    } else {
      print "You need to supply some parameters to contrain the query\n";
    }

  }

  $log->debug( "End samples, handlerequest " . time() );

} # end handle_request


sub postProcessResultset {
  my %args = @_;
  my ($i,$element,$key,$value,$line,$result,$sql);

  #### Process the arguments list
  my $resultset_ref = $args{'resultset_ref'};
  my $rs_params_ref = $args{'rs_params_ref'};
  my $query_parameters_ref = $args{'query_parameters_ref'};
  my $column_titles_ref = $args{'column_titles_ref'};
  my $hidden_cols = $args{'hidden_cols'};
  my $ptm_score_summary_ref = $args{'ptm_score_summary_ref'};
  my $ptm_peps_ref = $args{'ptm_peps_ref'};
	#--------------------------------------------------
	# 0 modified_peptide_sequence
	# 1 MPI.peptide_charge
	# 2 SMP.sample_id
	# 3 I.instrument_name
	# 4 SI.probability
	# 5 S.spectrum_name,
	# 6 AVG(SAL.level_probability),
	# 7 FRAGMENTATION_TYPE
	# 8 SI.spectrum_identification_id
	# 9 chromatogram 
	# 10 chimera_level 
	# 11 precursor_intensity
	# 12 scan_time,
	# 13 collision_energy
	# 14 SPI.ptm_sequence,
	# 15 COUNT(SAL.level_probability)
	# 16 SMP.sample_tag
	# 17 total_ion_current
	# 18 signal_to_noise 
	#-------------------------------------------------- 

  # First few $blah_idx variables refer both to query results
  # and column of results table
  my $mseq_idx    = 0;      # modified peptide sequence
  my $chrg_idx    = 1;      # charge
  my $smpl_idx = 2;      # sample
  my $inst_idx = 3;      # instrument
  my $prob_idx    = 4;      # probability
  my $name_idx = 5;      # spectrum name: mzML basename, scan, scan, chrg
  my $ann_idx  = 6;      # avg user annotation value
  my $frag_idx = 7;      # 
  my $spec_idx    = 8;      # link to spectrum display
  my $chrm_idx = 9;      # chromatogram.
  my $chimera_idx = 10;


  # The remaining $blah_idx variables refer to optional columns
  # of the results table,
  # These columns are deleted in loop below if they are not to be displayed.
  my $it_idx = 11;        # precursor intensity
  my $rt_idx = 12;        # retention time
  my $ce_idx = 13;        # collision energy
  
  # not displayed result 
  my $ptm_idx = 14;       # ptm sequence
  my $ann_count_idx = 15; # n user annotations
  my $sample_tag_idx = 16;   
  my $tic_idx = 17;
  my $sn_idx = 18; 

	my @display_peps;
	my $at_least_one_chromatogram = 0;
	my $at_least_one_chimera =0;
  my $has_header_info = 0;
  my $has_ptm_score = 0;
  my $n_rows = scalar(@{$resultset_ref->{data_ref}});

 for (my $i=0; $i<$n_rows; $i++) {
    #### Loops through resultset and do formatting
    my $pep = $resultset_ref->{data_ref}->[$i];
      # Get mzML filename, cycle, and charge from spectrum name
      $pep->[$name_idx] =~ /(\S+)\.(\d+?)\.(\d+?)\.(\d)/;
      my $mzml_basename = $1;
      my $cycle = $2;
      my $cycle2 = $3;
      my $precursor_charge = $4;
      $mzml_basename =~ s/\.mzML$//;    #remove .mzML if it's there
      my $mzml_fname = "$mzml_basename.mzML";
      my $rt;
      my @trace_array;
      my %trace;
      my $chromatogram_entry = '';  #empty, unless we can find chromgram info
      $at_least_one_chimera++ if ($pep->[$chimera_idx]);
      #### If this is a QTRAP 5500 mzML file, get info from special
      #### table, QT5500_TRANSITION_GROUP.
      #### This table needs to be updated each time the Human SRMAtlas is rebuilt.
      #### Takes ~3 days. Clear existing table, then reload with
      #### $SBEAMS/lib/scripts/PeptideAtlas/load_Q55500_transition_groups.pl
      #### PeptideChromatogramExtractor java code is now failing
      #### for all QT_ZH* files (see /Appears that all the QT files/ in
      #### Terry's log), so for now
      #### we won't display chromatogram icons/links for them.  07/05/11
      my $none = $sbeams->makeInactiveText( 'n/a' );
      if ( ( ($mzml_fname =~ /^5Q/) ||
           ( $mzml_fname =~ /^Z5Q/) ) ) {
        my $sql = qq~
          SELECT *
          FROM $TBAT_QT5500_TRANSITION_GROUP QTG
          WHERE QTG.mzml_filename = '$mzml_fname'
        ~;
        my @rows = $sbeams->selectSeveralColumns($sql);
        my %site_ptm_info = ();
        if (scalar @rows) {
					my $first_row = shift @rows;
					my ($qt5500_transition_group_id,
										$mzml_filename, $mzml_pathname, $cycle, $precursor_charge,
							 $precursor_mz, $rt) = @{$first_row};
								$mzml_pathname .= "/$mzml_filename";
        
					my ($q1, $q1_charge2, $q1_charge3, $precursor_neutral_mass);

					# Compute precursor neutral mass for this peptide
					# (Could also compute theoretical mass from pepseq + mods)
					my $precursor_charged_mass = $precursor_mz * $precursor_charge;
					# Subtract mass for each proton added when precursor was charged
					$precursor_neutral_mass = $precursor_charged_mass -
						 ($precursor_charge * 1.00727638);

					# We must invent the ion because we don't have transition list
					my $ion = "y1";        ### INVENTED!!!
					my $ion_charge = '1';    ### INVENTED!!!
					# remove mods from pepseq
					my $modified_pepseq = $pep->[$mseq_idx];
					my $pepseq = $modified_pepseq;
					$pepseq =~ s/\[.+?\]//g;
					my $fragmentor = 125;  ### INVENTED!!! but maybe unused.
					# There are fields for CE & RT in the Spectrum table,
					# but unfortunately for SRM atlas these values are not loaded.
					my $ce = $pep->[$ce_idx] ?  $pep->[$ce_idx] : 99;
					if (! $rt ) {
						$rt = $pep->[$rt_idx] ?  $pep->[$rt_idx] : 99;
					}
					my $delta_rt = 5.00;   ### INVENTED!!! but maybe unused.

					$at_least_one_chromatogram = 1;
					my $chrom_img = "<IMG BORDER=0 SRC='$HTML_BASE_DIR/images/chromatogram.gif' TITLE='View chromatogram for $pep->[$mseq_idx] (+$pep->[$chrg_idx])'>";
					
					#print "<p>Charge $precursor_charge Precursor Neutral Mass $precursor_neutral_mass Precursor Charged Mass $precursor_charged_mass<br>\n";

					$chromatogram_entry =
						qq~<A HREF="$CGI_BASE_DIR/PeptideAtlas/ShowChromatogram?~;
					$chromatogram_entry .= ""
				#	."&ion=$ion"  #multiple; different per trace.
				#	."&ion_charge=$ion_charge"  #multiple
			  # ."&precursor_charge=$precursor_charge"  #both +2 & +3 will be shown.
					."&pepseq=$pepseq"
					."&modified_pepseq=$modified_pepseq"
				#	."&q1=$q1"  #multiple
				#	."&q3=$q3"  #multiple
					."&spectrum_basename=$mzml_basename"
					."&spectrum_pathname=$mzml_pathname"
				#	."&ce=$ce"
			  # ."&rt=$rt"  #multiple
					."&delta_rt=$delta_rt"
					."&fragmentor=$fragmentor"
					."&precursor_neutral_mass=$precursor_neutral_mass";

					 $chromatogram_entry =
						qq~$chromatogram_entry" TARGET=blank>$chrom_img</A>~;

				} # end if there is info for this pep in the QT5500_transition_group table
      } # end if Qtrap 5500

      $pep->[$prob_idx] = sprintf("%0.3f", $pep->[$prob_idx]) unless $pep->[$prob_idx] == 1;
      $pep->[$prob_idx] = 1 if $pep->[$prob_idx] == 1;
      $pep->[$inst_idx] =~ s/ +/&nbsp;/g;
      my $build_id = $query_parameters_ref->{atlas_build_id};
      my $img = "<IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='View spectrum for $pep->[$mseq_idx] (+$pep->[$chrg_idx])'>";
      my $eval_string = $query_parameters_ref->{'ann'}? 'eval=1&' : '' ;
      $pep->[$spec_idx] = qq~<A HREF="$CGI_BASE_DIR/PeptideAtlas/ShowObservedSpectrum?${eval_string}atlas_build_id=$build_id&spectrum_identification_id=$pep->[$spec_idx]&peptide=$pep->[$mseq_idx]&assumed_charge=$pep->[$chrg_idx]&chimera_level=$pep->[$chimera_idx]&sample_id=$pep->[$smpl_idx]&spectrum_name=$pep->[$name_idx]" TARGET=blank>$img</A>~;
      $pep->[$ann_idx] = sprintf("%0.2f", $pep->[$ann_idx]);
      $pep->[$ann_idx] =~ s/^0// if ($pep->[$ann_idx] > 0);  #remove any zero before decimal
      $pep->[$ann_idx] = "0" if ($pep->[$ann_idx] == 0);
      $pep->[$ann_idx] .= "($pep->[$ann_count_idx])";
      $pep->[$ann_idx] = $none if (!$pep->[$ann_count_idx]);
      $pep->[$chrm_idx] = $chromatogram_entry;
      $pep->[$chimera_idx] = '' if (!$pep->[$chimera_idx]);
			my $modified_pepseq = $pep->[$mseq_idx];

      my @ptm_pep =();
			if ($pep->[$ptm_idx]){
        foreach my $i (0..10){
          push @ptm_pep, $pep->[$i];
        }
				my $ptm_sequence = $pep->[$ptm_idx];
				my $newseq = '';
				my %mods = ();
        my %ptm_score = ();
				my $pos = -1;
				my @elms = split(/\]/, $modified_pepseq);
				foreach my $str (@elms){
					if ($str =~ /(.*)\[(.*)/){
					  $pos += length ($1);
					  $mods{$pos} = $2;
          }else{
            $pos += length ($str);
          }
				}
        
				@elms = split(/\)/, $ptm_sequence);
        if (@elms > 1){ $has_ptm_score = 1;}
					$pos = -1;
					foreach my $str (@elms){
						if ($str =~ /(.*)\((.*)/){
							$pos += length ($1);
							$ptm_score{$pos} = $2;
						}else{
							$pos += length ($str);
						}
					}
          $pos=0;
          @elms =  split(/(?=[a-zA-Z])/, $ptm_sequence) ;
          my @melms = split(/(?=[a-zA-Z])/, $modified_pepseq) ;
          for (my $i=0; $i<=$#elms;$i++){
            my $pstr = $elms[$i];
            my $mstr = $melms[$i];
            if ($pstr =~ /n/){
              next;
            }
            $pstr =~ /([A-Z])/;
            my $aa = $1;
            my $score='';
            if ($aa !~ /[STY]/){
              $ptm_score_summary_ref->{$pos}{aa} = $aa;
              foreach my $s (qw(obsll obsml obsl obsm obsh obsmh obshh)){
								$ptm_score_summary_ref->{$pos}{$s}='';
              }
              $pos++;
              next;
            }
            $ptm_score_summary_ref->{$pos}{aa} = $aa;
            if ($pstr =~ /[STY]\(/){ 
              $pstr =~ /([\d\.]+)/;
              $score = $1;
              if($score >= 0.99 ){
                $ptm_score_summary_ref->{$pos}{obshh}++;
              }elsif($score >= 0.95 && $score < 0.99 ){
                $ptm_score_summary_ref->{$pos}{obsmh}++;
						  }elsif ($score >= 0.81 && $score < 0.95){
								 $ptm_score_summary_ref->{$pos}{obsh}++;
							}elsif($score >= 0.19 && $score < 0.81 ){
								$ptm_score_summary_ref->{$pos}{obsm}++;
							}elsif($score >= 0.05 && $score < 0.19){
								 $ptm_score_summary_ref->{$pos}{obsl}++;
							}elsif($score >= 0.01 && $score < 0.05){
								 $ptm_score_summary_ref->{$pos}{obsml}++;
							}elsif($score < 0.01){
								$ptm_score_summary_ref->{$pos}{obsll}++;
							}
            }
            $pos++;
          }
        my $pepseq = $modified_pepseq;
        $pepseq =~ s/\[[\d\.]+\]//g;
        my @aas = split(//, $pepseq);
        for(my $i=0; $i<=$#aas; $i++){
          if(defined $mods{$i} && defined $ptm_score{$i}){
            $newseq .= "$aas[$i]\[$mods{$i}\]($ptm_score{$i})";
          }elsif(defined $mods{$i} && not defined $ptm_score{$i}){
            $newseq .= "$aas[$i]\[$mods{$i}\]";
          }elsif(defined $ptm_score{$i} && not defined $mods{$i}){
            $newseq .= "$aas[$i]($ptm_score{$i})";
          }else{
            $newseq .= $aas[$i];
          }
        }
				$modified_pepseq = $newseq;
			  if ($modified_pepseq  !~/\(/){
          $ptm_pep[$mseq_idx] = $sbeamsMOD->formatMassMods($modified_pepseq);
        }else{
          $ptm_pep[$mseq_idx] = $modified_pepseq;
        }
        $ptm_pep[$frag_idx] = $pep->[$frag_idx];
        $pep->[$mseq_idx] =~ s/(\([\d\.]+\))//g;
      }
    
      $pep->[$it_idx] = ( $pep->[$it_idx] ) ?  sprintf("%.2f", $pep->[$it_idx]/1000000) : $sbeams->makeInactiveText('n/a'); 
      $pep->[$tic_idx] = ( $pep->[$tic_idx] ) ?  sprintf("%.2f", $pep->[$tic_idx]/1000000): $sbeams->makeInactiveText('n/a');
      $pep->[$sn_idx] = ( $pep->[$sn_idx] ) ? sprintf("%.0f", $pep->[$sn_idx]) : $sbeams->makeInactiveText('n/a');

      if ($pep->[$ptm_idx]){
        $ptm_pep[$it_idx] = $pep->[$it_idx];
        $ptm_pep[$tic_idx] = $pep->[$tic_idx];
        $ptm_pep[$sn_idx] = $pep->[$sn_idx];
        push @$ptm_peps_ref, \@ptm_pep;
      }

      if ( $has_header_info ) {
        $pep->[$rt_idx] = ( $pep->[$rt_idx] ) ? sprintf( "%0.1f", $pep->[$rt_idx]/60 ) : $sbeams->makeInactiveText('n/a'); 
        $pep->[$ce_idx] = ( $pep->[$ce_idx] ) ? sprintf( "%0.1f", $pep->[$ce_idx] ) : $sbeams->makeInactiveText('n/a'); 
      }
      $resultset_ref->{data_ref}->[$i] = $pep; 
    } # end for each pep
     
    if ($has_ptm_score){
       sort_ptm_peps(\@$ptm_peps_ref);
    }
    $hidden_cols->{"chimera_level"} = 1 if (! $at_least_one_chimera) ; 
    $hidden_cols->{"chromatogram"} = 1 if ( ! $at_least_one_chromatogram);
    if ( ! $has_header_info){
      #$hidden_cols->{'precursor_intensity'} = 1;
      $hidden_cols->{'scan_time'} =1;
      $hidden_cols->{'collision_energy'} =1;
      $hidden_cols->{'avg_prob'} =1;
    }
    
    $hidden_cols->{'ptm_sequence'} = 1;
    $hidden_cols->{'sal_prob'} = 1;
    $hidden_cols->{'sample_tag'} = 1;
}

sub get_protein_mapping_widget {
  my $protein_map = shift;
  my $parameters = shift;
  my $id_str = join( ',', keys( %{$protein_map} ) ) || '';
  my $build_id = $parameters->{atlas_build_id};

  return $id_str unless $id_str && $build_id;

  my $sql = qq~
  SELECT DISTINCT BS.biosequence_id,  BS.biosequence_name, dbxref_name,
          CAST( BS.biosequence_desc AS VARCHAR(2000) ) biosequence_desc,
          CASE WHEN PPL.level_name IS NULL THEN 'zzzz' ELSE PPL.level_name END as level_name,
          BSRT.relationship_name,
          BS_REF.biosequence_name as "reference_biosequence_name"
    FROM PeptideAtlas.dbo.biosequence_set BSS
    INNER JOIN PeptideAtlas.dbo.biosequence BS
          ON ( BSS.biosequence_set_id = BS.biosequence_set_id )

     LEFT JOIN BioLink.dbo.dbxref DBX
          ON ( BS.dbxref_id = DBX.dbxref_id )

     LEFT JOIN PeptideAtlas.dbo.protein_identification PID
          ON ( PID.biosequence_id = BS.biosequence_id )
	            AND PID.atlas_build_id = $build_id

     LEFT JOIN PeptideAtlas.dbo.protein_presence_level PPL
          ON ( PPL.protein_presence_level_id = PID.presence_level_id )

     LEFT JOIN PeptideAtlas.dbo.biosequence_relationship BSR
          ON ( BSR.related_biosequence_id = BS.biosequence_id )
          AND BSR.atlas_build_id = $build_id

     LEFT JOIN PeptideAtlas.dbo.biosequence_relationship_type BSRT
          ON ( BSRT.biosequence_relationship_type_id = BSR.relationship_type_id )
         LEFT JOIN PeptideAtlas.dbo.biosequence BS_REF
              ON ( BS_REF.biosequence_id = BSR.reference_biosequence_id )
       WHERE BS.biosequence_id IN ( $id_str )
       ORDER BY level_name ASC, dbxref_name DESC, BS.biosequence_name ASC
       ~;

  my $sth = $sbeams->get_statement_handle( $sql );
  my @ordered;
  my %level;

  my @headings = qw( ID Protein Database Annotation EvidenceLevel Relationship Reference isVariant );
  my @data = ( \@headings );
  while ( my @row = $sth->fetchrow_array() ) {
    $row[4] = '' if $row[4] eq 'zzzz';
    $row[2] =~ s/Human Proteins//g;
    $row[2] =~ s/EBI IPI/IPI/g;
    $row[2] ||= '';
    $row[1] = makeProteinLink( name  => $row[1], build => $build_id);
    my $desc = $row[3];
    my $seq = $protein_map->{$row[0]}->{seq};
    my $pep = $protein_map->{$row[0]}->{pep_seq};
    my @seq = split( /\*/, $seq );
    my $cseq = shift( @seq );
    my $aseq = join( "*", @seq );
    my $isvar = 'n/a';
    my $annot = '';
    if ( $row[2] =~ /(Swiss|Uniprot|nextprot|Ensembl)/i ) {
      if ( $desc =~ /\sPE=(\d)/ ) {
        $annot = "PE level $1";
      }
      if ( $cseq =~ /$pep/ ) {
        $isvar = 'no';
      } else{
					my $lpep = $pep;
					my $lcseq = $cseq;
					$lpep =~ s/I/L/g;
					$lcseq =~ s/I/L/g;
					if ( $lcseq =~ /$lpep/ ) {
						$isvar = 'L/I';
					} else {
						#$isvar = 'n/a';
						$isvar = 'yes';
					}
      }
    }
    $row[3] = $annot;

    push @data, [ @row[0..6], $isvar ]
  }

  my $widget = '<table>';
  $widget .= $sbeamsMOD->encodeSectionTable( header => 1, 
					       align  => [qw(left center right right right center center right)],
					       bkg_interval => 3,
					       rows => \@data,
					       rows_to_show => 10,
					       nowrap => [1..7] );
  $widget .= '</table>';

  return scalar $sbeams->make_toggle_section( neutraltext => "Proteins Mapped",
						   sticky => 1,
						     name => 'getpeptide_proteinmapping_div',
					  #ToDo?# tooltip => 'Show/Hide Section',
						  barlink => 1,
						  visible => 1,
						  content => $widget );
}

sub sort_ptm_peps {
  my $rows = shift;
  my $heading = shift @$rows;
  my %peptide = ();
  my $idx = 0;

  foreach my $row (@$rows){
    my $pos = '';
    my $entry = $row->[0];
    my @matches = ($entry =~ /\[\d+\]\(([\d\.]+)\)/g);
    my $total_ptm_score =0;
    foreach my $m (@matches){
      $total_ptm_score += $m;
    } 
    my $modified_pep= $entry;
    $modified_pep =~ s/\([\d\.]+\)//g;
    if ($peptide{scalar @matches}{$modified_pep}{max_score} < $total_ptm_score){
      $peptide{scalar @matches}{$modified_pep}{max_score}  = $total_ptm_score;
    }
    push @{$peptide{scalar @matches}{$modified_pep}{entry}}, [$total_ptm_score, $idx];
    ## for testing
    #my $ptm_sequence = $entry;
    #$ptm_sequence =~ s/\[[\d\.]+\]//g;
    #push @{$rows->[$idx]}, $ptm_sequence;

    $idx++;
  }
  my @sorted_rows = ();
  push @sorted_rows, $heading ;
  foreach my $n_ptm_site (sort {$b <=> $a} keys %peptide){
    foreach my $modified_pep (sort {$peptide{$n_ptm_site}{$b}{max_score} <=> 
                                    $peptide{$n_ptm_site}{$a}{max_score}} keys %{$peptide{$n_ptm_site}}){
      my @entries = @{$peptide{$n_ptm_site}{$modified_pep}{entry}};
      my @sorted_entries = sort {$b->[0] <=> $a->[0]} @entries;
      foreach my $entry (@sorted_entries){
          #print "$n_ptm_site $modified_pep ". join(",", @$entry) ."\n";
          my $idx = $entry -> [1];
          push @sorted_rows, $rows->[$idx];
        
      }
    }
  }
  @$rows = @sorted_rows;
}


sub format_refpep {
  my $annot = shift || return '';
  my $peptide_mass = $modification_helper->getPeptideMass( peptide => $annot->[0],
                                                           precision => 2 );  
  my $ptext =<<"  END";
  <TABLE>
    <TR><TD NOWRAP=1>Type:</TD><TD NOWRAP=1>$annot->[1]</TD></TR>
    <TR><TD NOWRAP=1>Sequence:</TD><TD NOWRAP=1>$annot->[0]</TD></TR>
    <TR><TD NOWRAP=1>Mass:</TD><TD NOWRAP=1>$peptide_mass</TD></TR>
    <TR><TD NOWRAP=1>Submitted by:</TD><TD NOWRAP=1>$annot->[3]</TD></TR>
  </TABLE>
  END
#  $ptext =~ s/\'/\\\'/gm;
  $ptext =~ s/\n//gm;
  return ( $sbeamsMOD->make_pa_tooltip( link_text => $annot->[0],
                                        tip_text => $ptext,
                                        link_class => 'pseudo_link' ) );

#  return "<SPAN CLASS=pseudo_link onMouseover=\"showTooltip(event, '$ptext')\" onMouseout=\"hideTooltip()\">$annot->[0]</SPAN>";
}

sub get_mrm_transitions {
  my $accession = shift || return [];

  # Project control
  my @accessible = $sbeams->getAccessibleProjects();
  my $projects = join( ",", @accessible );
  return '' unless $projects;

  my $sql =<<"  END";
  SELECT
--  modified_peptide_annotation_id,
  modified_peptide_sequence,
  peptide_charge, 
  q1_mz,
  q3_mz,
  q3_ion_label,  
  q3_peak_intensity,
  collision_energy,
  retention_time,
  instrument,
  CASE WHEN contact_id IS NULL 
    THEN annotator_name 
    ELSE username 
    END AS name,
  level_name
  FROM $TBAT_MODIFIED_PEPTIDE_ANNOTATION MPA 
  JOIN $TBAT_PEPTIDE P ON MPA.peptide_id = P.peptide_id
  JOIN $TBAT_TRANSITION_SUITABILITY_LEVEL TSL 
    ON TSL.transition_suitability_level_id = MPA.transition_suitability_level_id
  LEFT JOIN $TB_USER_LOGIN UL ON UL.contact_id = MPA.annotator_contact_id
  WHERE peptide_accession = '$accession'
  AND project_id IN ( $projects )
  AND level_score > 0.8
  ORDER BY modified_peptide_sequence, peptide_charge DESC, level_score DESC, Q3_peak_intensity DESC, q3_mz
  END
  my @rows = $sbeams->selectSeveralColumns($sql);
  return \@rows;
}


sub get_table_help {
  my $name = shift;
  return '' unless $name;
  my @entries;
  my $showtext = 'show column descriptions';
  my $hidetext = 'hide column descriptions';
  my $heading;
  my $description;
## { key => 'Peptide Accession', value => 'Primary key for annotations table.' },
  if ( $name eq 'annotated_transitions' ) {  
    @entries = ( 
                 { key => 'Sequence', value => 'Amino acid sequence of detected pepide, including any mass modifications.' },
                 { key => 'Charge', value => 'Charge on Q1 (precursor) peptide ion.' },
                 { key => 'q1_mz', value => 'Mass to charge ratio of precursor peptide ion.' },
                 { key => 'q3_mz', value => 'Mass to charge ratio of fragment ion.' },
                 { key => 'Label', value => 'Ion-series designation for fragment ion (Q3).' },
                 { key => 'Intensity', value => 'Intensity of peak in CID spectrum' },
                 { key => 'CE', value => 'Collision energy, the kinetic energy conferred to the peptide ion and resulting in peptide fragmentation. (eV)' },
                 { key => 'RT', value => 'Peptide retention time( in minutes ) in the LC/MS system.' },
                 { key => 'SSRCalc', value => "Sequence Specific Retention Factor provides a hydrophobicity measure for each peptide using the algorithm of Krohkin et al. Version 3.0 <A HREF=http://hs2.proteome.ca/SSRCalc/SSRCalc.html target=_blank>[more]</A>" },
                 { key => 'Instr', value => 'Model of mass spectrometer on which transition pair was validated.' },
                 { key => 'Annotator', value => 'Person/lab who contributed validated transition.' },
                 { key => 'Quality', value => 'Crude scale of quality for the observation, currently one of Best, OK, and No. ' },
        );
                 
    $heading = 'Annotated Transitions';
    $description= 'Contributed Q1/Q3 transition pairs for SRM experiments';
  } elsif ( $name eq 'individual_spectra' ) {
    @entries = ( 
                 { key => 'Modified Sequence', value => 'Amino acid sequence of detected pepide, including any mass modifications.' },
                 { key => 'Chg', value => 'Charge on observed peptide ion.' },
                 { key => 'Smpl', value => 'Experiment ID from which this spectrum was obtained.' },
                 { key => 'Instr', value => 'Model of mass spectrometer on which transition pair was validated.' },
                 { key => 'Prob', value => 'Probability assigned peptide-spectrum match (iProphet).' },
                 { key => 'Spectrum Name', value => 'Name of spectrum, typically filename.scan.scan' },
                 { key => 'Avg Eval', value => 'Average manual evaluation score for peptide-spectrum match  (if applicable)' },
                 { key => 'Fragmentation Type', value => 'Fragmentation method used to generate spectrum.  IT = IonTrap, CID = Collision Induced Dissociation, etc.' },
                 { key => 'Spectrum', value => 'Link to display of actual spectrum'},
                 { key => 'Precursor Intensity', value => 'Precursor Intensity in Millions'},
                 { key => 'TIC', value=>'Total ion current in Millions'},
                 { key => 'S/N', value=> 'Signal to noise'},
        );
                 
    $heading = 'Individual Spectra';
    $description= 'Individual spectra supporting the existence of the subject peptide; list can be narrowed to a specific peptide ion in the Modified Peptide table above';
  }

  return unless @entries;
  my $help = $sbeamsMOD->get_table_help_section( name => $name,
                                             description => $description,
                                             heading => $heading,
                                             entries => \@entries,
                                             showtext => $showtext,
                                             hidetext => $hidetext  );
  return $help;

} # end get_table_help




sub get_synthesized_peptides {
  my $accession = shift || return [];

  # Project control
  my @accessible = $sbeams->getAccessibleProjects();
  my $projects = join( ",", @accessible );
  return '' unless $projects;

  my $sql =<<"  END";
  SELECT
--  peptide_annotation_id, 
    P.peptide_sequence, peptide_annotation,
  publication_name,
--  P.peptide_id,
  CASE WHEN contact_id IS NULL 
    THEN annotator_name 
    ELSE username 
    END AS name,
  PA.peptide_sequence
  FROM $TBAT_PEPTIDE_ANNOTATION PA 
  JOIN $TBAT_PEPTIDE P ON PA.peptide_id = P.peptide_id
  LEFT JOIN $TB_USER_LOGIN UL ON UL.contact_id = PA.annotator_contact_id
  LEFT JOIN $TBAT_PUBLICATION PP ON PP.publication_id = PA.publication_id
  WHERE peptide_accession = '$accession'
  AND project_id IN ( $projects )
  END
  my @rows = $sbeams->selectSeveralColumns($sql);
  return \@rows;
}

sub add_transition_link {
  my $pep = shift;
  my $mrm_transitions = shift;
  my $link = '';
  for my $transition ( @$mrm_transitions ) {
    if ( $pep->[1] == $transition->[2] ) {
      return "<A HREF='ViewMRM?sequence=$pep->[2];modified_peptide_annotation_id=$transition->[0]'>$transition->[1]</A>";
    }
  }
  return '&nbsp;';
}

sub sample_view {
  my $samples = shift;
  my $tot = $samples =~ tr/,/,/;

  # If we have 5 or fewer, go with the flow
  return($samples) if $tot <= 5;

  $samples =~ s/\s//g;
  my @samples = split(',', $samples);

  my $viewable = join( ',', @samples[0..3] );
  my $session_samples = "$viewable<BR>\n";
  my $cnt = 0;
  my $sep = '';
  for ( my $j = 4; $j <= $#samples; $j++ ) {
    $cnt++;
    $session_samples .= $sep . $samples[$j];
    $sep = ',';
    unless( $cnt % 4 ) {
      $session_samples .= ",<BR>\n"; 
      $sep = '';
    }
  }
  $session_samples .= "<BR>\n";

  my $more = $tot - 4;

  my $key = $sbeams->getRandomString(num_chars => 20);
  $sbeams->setSessionAttribute( key => $key,  value => $session_samples );

  my $url = "$CGI_BASE_DIR/help_popup.cgi?title=Observed%20in%20Samples;session_key=$key;email_link=no";
  my $morelink = qq~ &nbsp;&nbsp;[<A onClick=popitup("$url"); CLASS=pseudo_link>$more more</A>]~;
  return "$viewable $morelink";
}

sub makeProteinLink {
  my %args = @_;
  for ( qw( name build ) ) {
    die "missing parameter $_" unless $args{$_};
  }
  my $target = ( $args{target} ) ? "TARGET=$args{target}" : '';
  $args{name} = $q->escape( $args{name} );
  my $link = "<A HREF='$CGI_BASE_DIR/PeptideAtlas/GetProtein?atlas_build_id=";
  $link   .= "$args{build}&protein_name=$args{name}&action=QUERY' ";
  $link   .= "class='text_link' $target>$args{name}</A>";

  return $link;
}

###########################################
sub makeKaviarLink {
  my %args = @_;

  return '' unless $args{org} =~ /Homo/i;
  return '' unless defined $args{start};
  my $chrom = $args{chrom};
  my $range = $args{start} . '-' . $args{end};
  my $frz = 'hg38';
  if ( $args{build_id} < 440 ) {
    $frz = 'hg19';
  }
  my $link = "<a href='http://db.systemsbiology.net/kaviar/cgi-pub/Kaviar.pl?frz=$frz&onebased=1&onebased_output=2&chr=$chrom&pos=$range&list=&uploaded_file=&format=table&.submit=Submit+Query' title='Explore polymorphisms in this region with Kaviar' target='_kaviar'>Kaviar</a>";
  return $link;
}


sub makeGenomeLink {
  my %args = @_;
#### EDeutsch commented out to allow peptides with mappings to proteins
#### without coordinates.  May not be a correct fix
#  for ( qw( start end strand chrom org ) ) {
#    die "missing parameter $_" unless $args{$_};
#  }
  # Length specified by range
 
  return $sbeams->makeInactiveText( 'n/a' ) unless $args{chrom};
  
  my $len = abs( $args{start} - $args{end} );

  # want to show some flanking info, minimun 2KB
#  my $extra = ( $len >= 2000 ) ? 0 : int((2000 - $len)/2);
  my $extra = 1000;

  my $org = $args{org};
  $org =~ s/ /_/g;
  my $chr = $args{chrom};

   # Ensembl uses roman numerals for yeast chromosomes...
  if ( $org =~ /^Sacch/ ) {
    $chr = $sbeams->getRomanNumeral( number => $chr ) || $chr; # Fallback...
  }

## xxxxxxx is this a debug statement?
# print "<br/><br/>$org<br/<br/>";

  my $vc_start = $args{start} - $extra;
  my $vc_end = $args{end} + $extra;
  if ( $args{start} > $args{end} ) {
    $vc_start = $args{end} - $extra;
    $vc_end = $args{start} + $extra;
  }
  $vc_start = 0 if $vc_start < 0;

  my $link = '';
  if ( $org =~ /Halo/ ) {
    # Currently halo has chromosome designations of MAIN, PNRC100 and PNRC200,
    # but KEGG wants 'c', pNRC100 and pNRC200
    $chr =~ s/P/p/;
    $chr = 'c' if $chr =~ /MAIN/;

    $link = "<A HREF='http://www.genome.jp/kegg-bin/show_genomemap?ORG=hal&CHR=$chr&START_POS=$vc_start&ACCESSION=$args{acc}' TARGET=_ensembl Title='Explore range in KEGG contig viewer'>Contig Viewer </A>";
#    $link = "<A HREF='http://www.genome.jp/kegg-bin/show_genomemap?ORG=hal&CHR=$chr&START_POS=$vc_start&ACCESSION=$args{acc}' TARGET=_ensembl>" .
#            "<DIV Title='Explore range in KEGG contig viewer'> $args{start} - $args{end} </DIV> </A>";
  } else {
    $link = "<A HREF='http://www.ensembl.org/$org/contigview?region=$chr;vc_start=$vc_start;vc_end=$vc_end' TARGET=_ensembl Title='Explore range in Ensembl contig viewer'>Ensembl </A>";
#    $link = "<A HREF='http://www.ensembl.org/$org/contigview?region=$chr;vc_start=$vc_start;vc_end=$vc_end' TARGET=_ensembl>" .
#            "<DIV Title='Explore range in Ensembl contig viewer'> $args{start} - $args{end} </DIV> </A>";
  }
  return $link;

}




#######################################################################
# get_atlas_build_name -- get atlas_build_name, given id
# @param atlas_build_id
# @return atlas_build_name
#######################################################################
sub get_atlas_build_name
{
    my %args = @_;

    my $atlas_build_id = $args{atlas_build_id}
      || die "need atlas_build_id";

    my $sql = qq~
        SELECT atlas_build_name
        FROM $TBAT_ATLAS_BUILD
        WHERE atlas_build_id = '$atlas_build_id'
    ~;

    my ($atlas_build_name) = $sbeams->selectOneColumn($sql);

    return $atlas_build_name;
}


###############################################################################
# printUserAnnotations
# get and display user annotations, if any
###############################################################################
sub printUserAnnotations {
  my %args = @_;
  my $parameters_href = $args{parameters_href};

  my $buffer;
  my $total = 0; # this starts as a counter, then becomes a string
  my $show_form = 1;
  my $line_sep = "<tr><td colspan='2'><hr size='1' noshade></td></tr>";

  my $peptide_constraint_sql = "0 = 0";
  if (defined $args{peptide_sequence}) {
    $peptide_constraint_sql = "P.peptide_sequence = '$args{peptide_sequence}'";
  } elsif (defined $args{peptide_name}) {
    $peptide_constraint_sql = "P.peptide_accession = '$args{peptide_name}'";
  } else {
    print "<P>ERROR: printUserAnnotations needs either peptide_sequence or peptide_name.</p>\n";
  }

  # First, get the peptide_instance_id.
  # TODO should check for uniqueness
  my $sql = qq~
      select peptide_instance_id
      from $TBAT_PEPTIDE_INSTANCE pi
      join $TBAT_PEPTIDE p
      on p.peptide_id = pi.peptide_id
      where $peptide_constraint_sql
	and pi.atlas_build_id = '$parameters_href->{atlas_build_id}'
    ~;
  my ($peptide_instance_id) = $sbeams->selectOneColumn($sql);
  $parameters_href->{peptide_instance_id} = $peptide_instance_id;
  if (! $peptide_instance_id) {
    print "<P>ERROR: printUserAnnotations could not find peptide_instance_id.</p>\n";
  }

  # TMF removed items 4,5,6 from SELECT statement; changed SPECTRUM_ANNOTATION SA to
  # PEPTIDE_INSTANCE_ANNOTATION PIA
  my $sql = qq~
	SELECT PIA.peptide_instance_annotation_id, PIA.comment, PIA.date_modified,
	       SL.spectrum_annotation_level_id, SL.level_name,
	       C.first_name, C.last_name,
	       UL.username
	  FROM $TBAT_PEPTIDE_INSTANCE_ANNOTATION PIA
    INNER JOIN $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
            ON ( PIA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
    INNER JOIN $TB_CONTACT C
            ON ( annotator_contact_id = C.contact_id )
    INNER JOIN $TB_USER_LOGIN UL
            ON ( UL.contact_id = annotator_contact_id )
    INNER JOIN $TBAT_PEPTIDE_INSTANCE PI
            ON ( PI.peptide_instance_id = PIA.peptide_instance_id )
	 WHERE PIA.record_status = 'N'
	   AND PIA.peptide_instance_id = '$peptide_instance_id'
      ORDER BY PIA.date_modified DESC
        ~;

  my @rows = $sbeams->selectSeveralColumns($sql);

  $buffer = qq~
	<table width="100%" class="table_setup">
	<tr class="orange_bg"><th>User annotations: how good is the evidence for this peptide sequence in this PeptideAtlas build?</th><td><a name="user_annotations">&nbsp;</a></td></tr>
	~;

  if (@rows) {
    foreach my $row (@rows) {
      # TMF removed items 4,5,6 $sequence $charge 
      my ($annot_id, $comment, $date, $level_id, $level, $first, $last, $uname,
	  ) = @{$row};
      $total++;

      # TMF
      #if ($args{modified_sequence}.$args{charge} eq $sequence.$charge) {
      $buffer .= "<tr id='${uname}${annot_id}_annot_tr'><th valign='top'>$level</th><td>$first $last ($date)<br />\n";
      #-TMF----------------------------------------------
      # } else {
      # my $link = $q->self_url();
      # $link =~ s/\?.*//;  # clear querystring
      # $link .= "?spectrum_identification_id=$ident_id;peptide=$sequence;assumed_charge=$charge";
      #-------------------------------------------------- 

      #--------------------------------------------------
      # $buffer .= "<tr bgcolor='#dddddd' id='${uname}${annot_id}_annot_tr'><th valign='top'>$level<br /><a href='$link' style='color:red'>$sequence +$charge</a></th><td>$first $last ($date)<br />\n";
      #-------------------------------------------------- 
      #}

      my $disp_comment = $comment;
      $disp_comment =~ s|\n|<BR />\n|g; # display carriage returns
      $buffer .= "$disp_comment\n";

      if ($uname eq $current_username) {
	$show_form = 0;

	# TMF spectrum_annotation_id => peptide_instance_annotation_id
	$buffer .= qq~
		    <br /><div align='right'><a href='javascript:showEditForm();'>Edit my annotation</a> | <a href='javascript:confirm_delete();'>Delete</a>
		    <FORM NAME="delete_annotation" METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
		    $args{form_fields}
		    <INPUT TYPE='hidden' NAME='peptide_instance_annotation_id' VALUE='$annot_id'>
   		    <INPUT TYPE='hidden' NAME='apply_action' VALUE='DELETE ANNOTATION'></FORM>
		    </div>
		    ~;

	$buffer .= "</td></tr>\n";

	$buffer .= &printUserAnnotationsForm(
	  form_type => 'update',
	  uname => $uname,
	  default_level_id => $level_id,
	  default_comment => $comment,
	  annot_id => $annot_id,
	  extra_form_fields => $args{form_fields}
	    );
      }

      $buffer .= "</td></tr>\n$line_sep\n";
    }

  } else {
    $buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td class='section_heading'>There are no user annotations for this peptide instance.<br /></td></tr>
	    $line_sep
	    ~;
  }


  if ($current_username eq 'guest') {
    my $url = $q->self_url();
    $url .= '&force_login=yes';

    $buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td><a href='$url'>Log into PeptideAtlas</a> to add an annotation for this peptide instance.<br /></td></tr>
	    $line_sep
	    ~;

  } elsif ($show_form) {
    $buffer .= "<tr id='${current_username}add_annot_tr'><th valign='top'><a href='javascript:showEditForm();'>Add annotation</a></th><td>&nbsp;</td></tr>\n";

    $buffer .= &printUserAnnotationsForm(
      form_type => 'add',
      uname => $current_username,
      # TMF
      #spectrum_id => $args{spectrum_id},
      peptide_instance_id => $peptide_instance_id,
      extra_form_fields => $args{form_fields}
	);

    $buffer .= "</td></tr>\n$line_sep\n";
  }

  $buffer .= "</table>\n";

  # get average
  # TMF
  $sql = qq~
 	SELECT ROUND(AVG(SL.level_probability)*100,0) AS avg_prob_pct,
	       COUNT(*)
	  FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
    INNER JOIN $TBAT_PEPTIDE_INSTANCE_ANNOTATION PIA
            ON ( PIA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
	 WHERE peptide_instance_id = '$peptide_instance_id'
	   AND PIA.record_status = 'N'
        ~;

  @rows = $sbeams->selectSeveralColumns($sql);

  my ($avg, $num) = @{$rows[0]};
  if ($total != $num) {
    $total = "($total total)";
  } else {
    $total = '';
  }

  my $innerHTML;

  # TMF spectrum => peptide
  if ($num == 1) {
    $innerHTML = "<a href=\"#user_annotations\">One user annotation</a> $total, score <b>$avg%</b>";
  } elsif ($num > 1) {
    $innerHTML = "<a href=\"#user_annotations\">$num user annotations</a> $total, average score <b>$avg%</b>";
  } elsif ($num == 0) {
    $innerHTML = "<a href=\"#user_annotations\">No user annotations</a>";
  }

  $buffer .=<< "EOJS" if $innerHTML;
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
    document.getElementById("annotations_summary").innerHTML = '$innerHTML';
    document.getElementById("annotations_head").style.display = 'table-row';
</SCRIPT>
EOJS

  return $buffer;
}


###############################################################################
# printUserAnnotationsForm
# get and display user annotations, if any
###############################################################################
sub printUserAnnotationsForm {
    my %args = @_;

    $args{form_type} ||= 'add';
    $args{uname} ||= 'user_anon';
    $args{default_level_id} ||= 0;
    $args{default_comment} ||= '';
    $args{annot_id} ||= 0;
    $args{extra_form_fields} ||= '';

    my $spacer = "&nbsp;"x5;

    my $trname = $args{uname};
    $trname .= ($args{form_type} eq 'add') ? 'add' : $args{annot_id};

    my $buffer = qq~
	<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
	<!--
	function showEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'none';
	    document.getElementById('${trname}_form_tr').style.display = 'table-row';
	}
        function hideEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'table-row';
	    document.getElementById('${trname}_form_tr').style.display = 'none';
	}

        function confirm_delete() {
	    var del = confirm("Are you sure you want to delete your comment?");
	    if (del==true) {
		document.delete_annotation.submit();
	    }
	}
        // -->
	</SCRIPT>
	~;

    # add a hidden <tr> for edit form
    my $sql = qq~
	SELECT spectrum_annotation_level_id, level_probability, level_name, level_description
	FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL
	WHERE record_status = 'N'
	ORDER BY sort_order
	~;

    my @levels = $sbeams->selectSeveralColumns($sql);

    my $select = "<SELECT NAME='user_spectrum_annotation'>\n";
    foreach my $levrow (@levels)
    {
	my ($lev_id, $lev_prob, $lev_name, $lev_desc) = @{$levrow};

	my $sel = ( "$args{default_level_id}" eq "$lev_id" ) ? 'SELECTED' : '';
	my $desc = $sbeams->escapeXML(value => $lev_desc);

	$select .= "<OPTION TITLE='$desc' VALUE='$lev_id' $sel>$lev_name</OPTION>\n";
    }
    $select .= "</SELECT>";

    # TMF -- I don't think I need this stuff below.
    my $form_action = "ADD";
    if ($args{form_type} eq 'update') {
	$form_action = "UPDATE";
        # TMF spectrum_annotation_id => peptide_instance_annotation_id
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='peptide_instance_annotation_id' VALUE='$args{annot_id}'>";

    } else {
        # TMF spectrum_id => peptide_instance_id
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='peptide_instance_id' VALUE='$args{peptide_instance_id}'>";
    }

    $buffer .= qq~
	<tr style='display:none' id='${trname}_form_tr'>
	<th valign='top'>
	<FORM METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
	$args{extra_form_fields}
	$select</th>
	<td><TEXTAREA ROWS='6' COLS='80' NAME='user_spectrum_commment'>$args{default_comment}</TEXTAREA><br />
	<div align='right'><INPUT TYPE='submit' NAME='apply_action' VALUE='$form_action ANNOTATION'>$spacer<a class='small_form_field' href='javascript:hideEditForm();'>CANCEL</a></div>
	~;

    # caller will close the td and tr
    return $buffer;

}


###############################################################################
# displayExternalLinksSection
#
# Display a section for information about this peptide in other resources
###############################################################################
sub displayExternalLinksSection {
  my %args = @_;

  #### Process the arguments list
  my $pepseq = $args{pepseq} || die("ERROR: No peptide sequence passed");

  my $tr = 'class="hoverable"';
  my $external_links = '';


  #### Link to Google
  my $link="http://www.google.com/#q=$pepseq&nfpr=1";
  my $peptide_google_link="<A HREF=$link TARGET=_BLANK color=blue>$pepseq</A>";
  my $tooltip = $sbeamsMOD->make_pa_tooltip( link_text => $peptide_google_link,
					     tip_text => "Query Google with this peptide sequence",
					     link_class => 'pseudo_link' );
  $external_links .= $sbeamsMOD->encodeSectionItem( key   => 'Google',
						    tr_info => $tr,
						    value => $tooltip );

  #### Link to all instances of this peptide in Swiss-Prot (from PIR)
  $link="http://proteininformationresource.org/cgi-bin/peptidematch?peptide=$pepseq";

  # Updated 2014-01 DSC
  $link = "http://research.bioinformatics.udel.edu/peptidematch/peptidewithorganisms.jsp?input_option=all&organism_name=&organism_id=all&keyword=$pepseq&start=0&initialed=false&searchtype=peptide&rows=20&uniref100=N&lEqi=N";

  my $peptide_pir_html_link="<A HREF=$link TARGET=_BLANK color=blue>$pepseq</A>";
  my $tooltip = $sbeamsMOD->make_pa_tooltip( link_text => $peptide_pir_html_link,
					     tip_text => "Retrieve all peptide hits from UniProtKB (all species)",
					     link_class => 'pseudo_link' );
  $external_links .= $sbeamsMOD->encodeSectionItem( key   => 'UniProtKB',
						    tr_info => $tr,
						    value => $tooltip );


  #### Close section
  if ($sbeams->output_mode() eq 'html' && $external_links ) {
    $external_links = "<TABLE style='margin-left:15px;'>$external_links</TABLE>";

    print scalar $sbeams->make_toggle_section( neutraltext => 'External Links',
					         sticky => 1,
					           name => 'getpeptide_ExternalLinks_div',
				        #ToDo?# tooltip => 'Show/Hide Section',
					        barlink => 1,
					        visible => 1,
					        content => $external_links );
  }

  return 1;
} # end displayExternalLinksSection
