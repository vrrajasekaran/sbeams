#!/usr/local/bin/perl

###############################################################################
# Program     : GetPeptide
# $Id$
#
# Description : Prints summary of a given peptide given selection
#               atlas build, and peptide name or sequence.
#
# SBEAMS is Copyright (C) 2000-2005 Institute for Systems Biology
# This program is governed by the terms of the GNU General Public License (GPL)
# version 2 as published by the Free Software Foundation.  It is provided
# WITHOUT ANY WARRANTY.  See the full description of GPL terms in the
# LICENSE file distributed with this software.
#
###############################################################################


###############################################################################
# Set up all needed modules and objects
###############################################################################
use strict;
use Getopt::Long;
use FindBin;

use POSIX qw(ceil);

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($sbeams $sbeamsMOD $q $current_contact_id $current_username
             $PROG_NAME $USAGE %OPTIONS $QUIET $VERBOSE $DEBUG $DATABASE
             $TABLE_NAME $PROGRAM_FILE_NAME $CATEGORY $DB_TABLE_NAME
             @MENU_OPTIONS);
##use CGI::Carp qw(fatalsToBrowser croak);

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::TabMenu;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;
use SBEAMS::PeptideAtlas::ConsensusSpectrum;
use SBEAMS::PeptideAtlas::ModificationHelper;
use SBEAMS::PeptideAtlas::Utilities;

use SBEAMS::Proteomics::Tables;

$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);
my $modification_helper = new ModificationHelper();

#$q = new CGI;


###############################################################################
# Set program name and usage banner for command like use
###############################################################################
$PROG_NAME = $FindBin::Script;
$USAGE = <<EOU;
Usage: $PROG_NAME [OPTIONS] key=value key=value ...
Options:
  --verbose n         Set verbosity level.  default is 0
  --quiet             Set flag to print nothing at all except errors
  --debug n           Set debug flag

 e.g.:  $PROG_NAME [OPTIONS] [keyword=value],...

EOU

#### Process options
unless (GetOptions(\%OPTIONS,"verbose:s","quiet","debug:s")) {
  print "$USAGE";
  exit;
}

$VERBOSE = $OPTIONS{"verbose"} || 0;
$QUIET = $OPTIONS{"quiet"} || 0;
$DEBUG = $OPTIONS{"debug"} || 0;

if ($DEBUG) {
  print "Options settings:\n";
  print "  VERBOSE = $VERBOSE\n";
  print "  QUIET = $QUIET\n";
  print "  DEBUG = $DEBUG\n";
}


###############################################################################
# Set Global Variables and execute main()
###############################################################################
main();
exit(0);


###############################################################################
# Main Program:
#
# Call $sbeams->Authenticate() and exit if it fails or continue if it works.
###############################################################################
sub main {

    #### Do the SBEAMS authentication and exit if a username is not returned
    exit unless ($current_username = $sbeams->Authenticate(
        permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
        'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
        #connect_read_only=>1,
        allow_anonymous_access=>1,
    ));

    #### Read in the default input parameters
    my %parameters;
    my $n_params_found = $sbeams->parse_input_parameters(
        q=>$q,
        parameters_ref=>\%parameters
        );

    #### Decide what action to take based on information so far
    if ($parameters{action} eq "???") 
    {
      # Some action
    } else 
    {
        my $project_id = $sbeamsMOD->getProjectID(
            atlas_build_id => $parameters{atlas_build_id}
        );

        $sbeamsMOD->display_page_header(project_id => $project_id);

        handle_request(ref_parameters=>\%parameters);

        $sbeamsMOD->display_page_footer();
    }

} # end main


###############################################################################
# Handle Request
###############################################################################
sub handle_request {

  my %args = @_;

  #### Process the arguments list
    my $ref_parameters = $args{'ref_parameters'}
        || die "ref_parameters not passed";

    my %parameters = %{$ref_parameters};

    #### Show current user context information
    print "<BR>\n" if ($sbeams->output_mode() eq 'html');
    #$sbeams->printUserContext();
  
    #### Get the HTML to display the tabs
    my $tabMenu = $sbeamsMOD->getTabMenu(
        parameters_ref => \%parameters,
        program_name => $PROG_NAME,
    );

    print $tabMenu->asHTML() if ($sbeams->output_mode() eq 'html');

    #### Define some generic variables
    my ($i,$element,$key,$value,$line,$result,$sql);

    #### Define some variables for a query and resultset
    my %resultset = ();
    my $resultset_ref = \%resultset;
    my (%url_cols,%hidden_cols,%max_widths,$show_sql);
    
    # Get list of accessible projects
    my @accessible_project_ids = $sbeams->getAccessibleProjects();
    my $project_string = join( ",", @accessible_project_ids ) || '0';
    return unless $project_string;
    


    #### Read in the standard form values
    my $apply_action  = $parameters{'action'} || $parameters{'apply_action'};

    my $TABLE_NAME = $parameters{'QUERY_NAME'};
        #### Get the search keyword


my $searchValue = $parameters{'searchForThis'};


############################
 ### Getting the last session information for a user, if it exists or setting up a new one
    #### If a new protein_name was supplied, store it
     if ($searchValue) {
    $sbeams->setSessionAttribute(
      key => 'PeptideAtlas_peptide_seq',
      value => $searchValue,
    );

    #### Else see if we had one stored
  } else {
    $searchValue = $sbeams->getSessionAttribute(
      key => 'PeptideAtlas_peptide_seq',
    );


if ($searchValue) {
       $parameters{'searchForThis'}=$searchValue;
      $parameters{'apply_action'} = 'GO';

    }

    else {

    ## Setting the value to some given peptide for those users who visits the page first time
      $parameters{'searchForThis'}= 'VSFLSALEEYTK';
     $searchValue=$parameters{'searchForThis'};
     $parameters{'apply_action'} = 'GO';

     }

}

print "<BR>";

##########################
#### Get the Build Name

my $atlas_build_name = $parameters{atlas_build_name};
my $atlas_build_id;


 


 ### Getting the last session information for a user, if it exists or setting up a new one
    #### If a new protein_name was supplied, store it
 if ($atlas_build_name) {
    $sbeams->setSessionAttribute(
      key => 'PeptideAtlas_build_name',
      value => $atlas_build_name,
    );

    #### Else see if we had one stored
  } else {
    $atlas_build_name = $sbeams->getSessionAttribute(
      key => 'PeptideAtlas_build_name',
    );


if ($atlas_build_name) {

      $parameters{'atlas_build_name'}=$atlas_build_name;
      $parameters{'apply_action'} = 'GO';
    }

     else {

                 ## Setting the value default build id and build name
                 $atlas_build_id = get_default_atlas_build_id(accessible_projects => $project_string );
                 $parameters{'atlas_build_id'} = $atlas_build_id;

               if ( $atlas_build_id )
               {
               $parameters{'atlas_build_name'} = get_atlas_build_name(atlas_build_id => 113 );
               $atlas_build_name = $parameters{'atlas_build_name'};
                $parameters{'apply_action'} = 'GO';

                 }

          }


}



    

###############################################################
### Getting the last session information of the Search Key used

my $searchKey=$parameters{'searchWithinThis'};

if ($searchKey) {
    $sbeams->setSessionAttribute(
      key => 'PeptideAtlas_search_key',
      value => $searchKey,
    );

    #### Else see if we had one stored
  } else {
    $searchKey = $sbeams->getSessionAttribute(
      key => 'PeptideAtlas_search_key'
    );


if ($searchKey) {
      $parameters{'apply_action'} = 'GO';

      $parameters{'searchWithinThis'}=$searchKey;
    }

    else {

    ## Setting the value to some given peptide for those users who visits the page first time
     $parameters{'searchWithinThis'}='Peptide Sequence';
     $searchKey=$parameters{'searchWithinThis'};
     $parameters{'apply_action'} = 'GO';

     }

}



#### Set some specific settings for this program
    my $CATEGORY="Get Peptide";
    my $PROGRAM_FILE_NAME = $PROG_NAME;
    my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";
    my $help_url = "$CGI_BASE_DIR/help_popup.cgi";
    

   if (defined($atlas_build_id) && $atlas_build_id < 0)
    {
        $parameters{'atlas_build_id'} = $atlas_build_id;
        return;
    }

  # Handle search tool links...
    if ($parameters{searchWithinThis} eq 'Peptide+Name') {
      $log->info( "Adjusted Peptide+Name to Peptide Name.");
      $parameters{searchWithinThis} = 'Peptide Name';
    }

    my $validation_error = '';
    ## if have atlas_build_name, but no id, get the id:
    if ( (exists $parameters{'atlas_build_name'}) && (!exists $parameters{'atlas_build_id'})) {
      $atlas_build_name = $parameters{'atlas_build_name'};
      if ($atlas_build_name) {
        my ($tmp) = get_atlas_build_id( atlas_build_name => $parameters{'atlas_build_name'});
        unless ( $tmp ) {
          $validation_error = "Unable to use specified Atlas, please select a new one ";
        }
        $parameters{'atlas_build_id'} = $tmp;
        $atlas_build_id = $tmp;
      }
    }


    ## if have atlas_build_id, but no name, get the name
    if ( (exists $parameters{'atlas_build_id'})  && (!exists $parameters{'atlas_build_name'}) ) {
      $atlas_build_id = $parameters{'atlas_build_id'};
      my ($tmp) = get_atlas_build_name( atlas_build_id => $atlas_build_id);
      unless ( $tmp ) {
        $validation_error = "Unable to use specified Atlas, please select a new one ";
      }
      $atlas_build_name = $tmp;
      $parameters{'atlas_build_name'} = $atlas_build_name;
    }
    
    if ( !$parameters{atlas_build_id} ) {
      $validation_error = "No build specified";
    } elsif ( !$sbeamsMOD->isAccessibleBuild( build_id => $parameters{atlas_build_id} ) ) {
      $validation_error = "You lack permission to access the specified build";
    }
    if ( $validation_error ) {
      my $error_string = $sbeams->makeErrorText( $validation_error );
      my $url = $q->self_url();
      my $url_delim = ( $url =~ /\?/ ) ? ';' : '?';
      print qq~
        <BR><BR>
        $error_string
        <BR>
        <BR>Please <A HREF="main.cgi?_tab=2;reset_id=1">choose</A> a valid Atlas Build, 
        or <A HREF="$url${url_delim}force_login=yes"> login </A> as a different user.
      ~;
      exit;
    }

    ## Get and store list of atlases for use with form:  
    my (@atlas_option_id_array, @atlas_option_name_array);  

    ## get accessible atlases:
    my $sql = qq~
        SELECT atlas_build_id,atlas_build_name
        FROM $TBAT_ATLAS_BUILD
        WHERE project_id IN ( $project_string )
        AND record_status!='D'
	ORDER BY atlas_build_name
    ~;

    my @rows = $sbeams->selectSeveralColumns($sql); 
    unless ( @rows ) {
      print qq~
      <BR><BR>
      <FONT COLOR=red>Unable to use specified Atlas, please select a new one </FONT>
      <BR><A HREF="main.cgi?_tab=2">Choose new Atlas Build</A>
      ~;
      exit; 
    }

    foreach my $row (@rows) {

        my ($tmp_id, $tmp_name) = @{$row};

        push(@atlas_option_id_array, $tmp_id);
        push(@atlas_option_name_array, $tmp_name);
    
    }



    #### Build search options for textbox:
    my @peptide_search_constraint = ( "peptide_name_constraint", 
                                      "peptide_sequence_constraint"
    );

    my @textbox_option_tags = ( "Peptide Name", 
                                "Peptide Sequence"
    );


    #### Apply any parameter adjustment logic
    $parameters{display_options} = 'ShowSQL';

    my ($selected_atlas_build_name, $selected_key, $selected_key_search);


$apply_action=$parameters{'apply_action'};

unless ( $apply_action eq "QUERY" || $apply_action eq "GO" ) { ## if receive from link, don't assign null

        $apply_action = $parameters{"query"};

    }

    ### if receive $parameters{atlas_build_id} from link, get atlas build name 
    #if ( $parameters{atlas_build_id} ) {
    #    for (my $i=0; $i<=$#atlas_option_id_array; $i++) {
    #        if ( $parameters{atlas_build_id} eq $atlas_option_id_array[$i] ) {
    #            $atlas_build_name = $atlas_option_name_array[$i]
    #        }
    #    }
    #}


    if ($sbeams->output_mode() eq 'html') {

#      print $sbeamsMOD->init_pa_tooltip(); 

        print "<p>";

        print "<nobr>";
        print $q->start_form(-method=>"POST",
                              -action=>"$base_url",
                             );
        print $q->popup_menu(-name=> "atlas_build_name",
                              -values=> [@atlas_option_name_array],
                              -default=>$atlas_build_name,
            );
        print "&nbsp;&nbsp;Search&nbsp;";
        print $q->popup_menu(-name=> "searchWithinThis",
                             -values=> [@textbox_option_tags],
                             -default=>$searchKey,
            );
        print "&nbsp;for:&nbsp;";
        print $q->textfield( "searchForThis", $searchValue);
        print $q->submit(-name => "query", 
                         -value => 'QUERY',
                         -label => 'QUERY');
        print $q->endform;
        print "</nobr>";

        ## xxxx $help_url

        print "</p>";
    } 

    ## store form values in %parameters:
    for (my $i=0; $i<=$#atlas_option_name_array; $i++){

        if ( $atlas_build_name eq $atlas_option_name_array[$i]) {

             $parameters{atlas_build_name} = $atlas_build_name;

             $parameters{atlas_build_id} = $atlas_option_id_array[$i];

        }
    }


    for (my $i=0; $i<=$#textbox_option_tags;$i++){

        if ( $searchKey eq $textbox_option_tags[$i]) {

             $parameters{$peptide_search_constraint[$i]} = $searchValue;
        }
    }




    #########################################################################
    #### Process all the constraints

    #### If atlas_build_id was not selected, stop here
    unless ($parameters{atlas_build_name}) {
        $sbeams->reportException(
            state => 'ERROR',
            type => 'INSUFFICIENT CONSTRAINTS',
            message => 'You must select an Atlas Build',
        );
        return;
    }


    #### Build ATLAS_BUILD constraint
    my $atlas_build_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"AB.atlas_build_id",
        constraint_type=>"int_list",
        constraint_name=>"Atlas Build",
        constraint_value=>$parameters{atlas_build_id} );
    return if ($atlas_build_clause eq '-1');




    #### Build PEPTIDE_NAME constraint
    my $peptide_name_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"P.peptide_accession",
        constraint_type=>"plain_text",
        constraint_name=>"Peptide Name",
        constraint_value=>$parameters{peptide_name_constraint} );
    return if ($peptide_name_clause eq '-1');

    #### Build PEPTIDE_SEQUENCE constraint
    my $peptide_sequence_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"P.peptide_sequence",
        constraint_type=>"plain_text",
        constraint_name=>"Peptide Sequence",
        constraint_value=>$parameters{peptide_sequence_constraint} );
    return if ($peptide_sequence_clause eq '-1');


   
    my $atlas_project_clause = "AND AB.project_id IN ( $project_string )";

    ## want to replace LIKE with = , as want a single peptide returned
    $peptide_name_clause =~ s/LIKE/=/gi;
    #print "peptide_name_clause: $peptide_name_clause <br>";

    $peptide_sequence_clause =~ s/LIKE/=/gi;
    #print "peptide_sequence_clause: $peptide_sequence_clause <br>";


    #### Define the SQL statement
    $sql = qq~
         SELECT distinct
         P.peptide_accession, P.peptide_sequence,
         PI.best_probability, PI.n_observations, PI.n_genome_locations, 
         PI.n_protein_mappings, PM.chromosome, PM.start_in_chromosome, 
         PM.end_in_chromosome, PM.strand, BS.biosequence_name,
         P.molecular_weight, P.peptide_isoelectric_point,
         PI.n_samples, PI.n_protein_samples, PI.empirical_proteotypic_score,
         O.full_name, PI.original_protein_name,
         P.SSRCalc_relative_hydrophobicity, CAST(biosequence_seq AS VARCHAR) biosequence_seq,
         PA.peptide_sequence, PA.peptide_annotation, PA.peptide_annotation_id, 
         PA.annotator_name, CAST(PA.comment AS VARCHAR) comment
         FROM $TBAT_PEPTIDE_INSTANCE PI
         INNER JOIN $TBAT_PEPTIDE P
          ON ( PI.peptide_id = P.peptide_id )
         INNER JOIN $TBAT_ATLAS_BUILD AB 
          ON ( PI.atlas_build_id = AB.atlas_build_id )
         LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
          ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
         LEFT JOIN $TB_ORGANISM O
          ON ( BSS.organism_id = O.organism_id )
         LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
          ON ( PI.peptide_instance_id = PM.peptide_instance_id )
         LEFT JOIN $TBAT_BIOSEQUENCE BS
          ON ( PM.matched_biosequence_id = BS.biosequence_id )
         LEFT JOIN $TB_DBXREF DBX ON ( BS.dbxref_id = DBX.dbxref_id )
         LEFT JOIN $TBAT_PEPTIDE_ANNOTATION PA ON ( PA.peptide_id = PI.peptide_id )
         WHERE 1 = 1
            $atlas_build_clause
            $peptide_name_clause
            $peptide_sequence_clause
            $atlas_project_clause
        ORDER BY PM.chromosome, BS.biosequence_name, PM.start_in_chromosome
    ~;
    unless ( $peptide_name_clause || $peptide_sequence_clause ) {
      $sbeams->display_sql(sql=>$sql);
      print qq~
      <FONT COLR=red>No name or sequence constraint found, unable to proceed</FONT>
      ~;
      return;
    }


    #########################################################################
    #### If QUERY,  display the data
if ($apply_action =~ /QUERY|GO/i ) {

        my @rows = $sbeams->selectSeveralColumns($sql)
        or print "Peptide not found.  Please check selections and try again.<br>";

        if (@rows) {

            my (@peptide_accession, @peptide_sequence);
            my (@best_probability, @n_observations, @n_genome_locations, @n_protein_mappings);
            my (@chrom, @start_chrom, @end_chrom, @strand);
            my (@biosequence_name);
            my ( @mw, @pi, @nsamp, @nprotsamp, @epscore, @organism, @original_name, @SSRCalc_relative_hydrophobicity, @pep_annot );

            my $i=0;  ##index counter

            my %chrom_map;
            foreach my $row (@rows) {

                my ($pa, $seq, $prob, $n_obs, $n_g_loc, $n_prot_map, 
                    $chr, $s_chr, $e_chr, $str, $b_name, $mw, $pi, 
                    $ns, $nps, $eps, $org, $orig_name,
		    $SSRCalc_relative_hydrophobicity, $protein_sequence, @annot ) = @{$row};
                @pep_annot = @annot unless @pep_annot;

                $peptide_accession[$i] = $pa;
                $peptide_sequence[$i] = $seq;
                $best_probability[$i] = $prob;
                $n_observations[$i] = $n_obs;
                $n_genome_locations[$i] = $n_g_loc;
                $n_protein_mappings[$i] = $n_prot_map;
                $chrom[$i] = $chr;
                $start_chrom[$i] = $s_chr;
                $end_chrom[$i] = $e_chr;
                $strand[$i] = $str;
                $biosequence_name[$i] = $b_name;
                $mw[$i] = sprintf( "%0.2f", $mw);
                $pi[$i] = sprintf( "%0.1f", $pi );
                $nsamp[$i] = $ns;
                $nprotsamp[$i] = $nps;
                $epscore[$i] = $eps;
                $organism[$i] = $org;
                $original_name[$i] = $orig_name;
                $SSRCalc_relative_hydrophobicity[$i] = $SSRCalc_relative_hydrophobicity;
                #print "sql returns: $n_observations[$i] $sample_tag[$i] <br>";

                my $key = join( ':::', $chr, $s_chr, $e_chr, $str, $seq );

                # Could just push, thought this was clearer.
                if ( !$chrom_map{$key} ) {
                  # First time through, point to arrayref
                  $chrom_map{$key} = [$b_name]; 
                } else {
                  # Subsequent visits push an item onto the list
                  push @{$chrom_map{$key}}, $b_name; 
                }
                $i++;
            }

            ##xxxx PRINT RETURN to HTML HERE... 

  # Widget to allow show/hide of overview section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getpeptide_overview',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );


  my $summary_header = $sbeamsMOD->encodeSectionHeader(
    text => "$peptide_accession[0]",
    'link' => $link,
    bold => 1
  );

  my $summ =<<"  END"; 
    $summary_header 
  END

  my $bestp = ( $best_probability[0] == 1 ) ? 1 : sprintf( "%0.2f", $best_probability[0] );

  $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Peptide Accession',
                                          value => $peptide_accession[0],
                                          tr_info => $tr,
                                          key_width => '20%'
                                         );
  $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Peptide Sequence',
                                          tr_info => $tr,
                                          value => $peptide_sequence[0],
                                         );
  $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Best Probability',
                                          tr_info => $tr,
                                          value => $bestp,
                                         );
  $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Times Observed:',
                                          tr_info => $tr,
                                          value => $n_observations[0],
                                         );
  $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Avg Molecular Weight',
                                          tr_info => $tr,
                                          value => "$mw[0]",
                                         ) if $mw[0];
  $summ .= $sbeamsMOD->encodeSectionItem( key   => 'pI (approx)',
                                          tr_info => $tr,
                                          value => "$pi[0]",
                                         ) if $pi[0];
  if ( defined $SSRCalc_relative_hydrophobicity[0] ) {
    $summ .= $sbeamsMOD->encodeSectionItem( key   => 'SSRCalc relative hydrophobicity',
                                            tr_info => $tr,
                                            value => sprintf("%.2f",$SSRCalc_relative_hydrophobicity[0]),
                                           );
  }

  if ( defined $epscore[0] ) {
    $summ .= $sbeamsMOD->encodeSectionItem( key   => '# Samples',
                                            tr_info => $tr,
                                            value => "$nsamp[0]",
                                           );
    $summ .= $sbeamsMOD->encodeSectionItem( key   => '# Protein Samples',
                                            tr_info => $tr,
                                            value => "$nprotsamp[0]",
                                           );
    $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Proteotypic score',
                                            tr_info => $tr,
                                            value => sprintf( "%0.1f", $epscore[0] ),
                                           );
  }


  $summ .= $sbeamsMOD->encodeSectionItem( key   => 'Reference peptide',
                                          tr_info => $tr,
                                          value => format_refpep( \@pep_annot )
                                         ) if $pep_annot[0];


 #### Deciding which clause to send to PeptideCount method present in Utilities.pm
 
  my $peptide_clause = ($peptide_name_clause) ? $peptide_name_clause : $peptide_sequence_clause;

  my($no_organisms,$no_distinct_builds)=$sbeamsMOD->PeptideCount(atlas_project_clause=>$atlas_project_clause,
                                                                  peptide_clause=>$peptide_clause );


  my $link="$CGI_BASE_DIR/$SBEAMS_SUBDIR/Summarize_Peptide?searchForThis=$peptide_sequence[0]&apply_action=QUERY";
  my $build_html_link="<A HREF=$link TARGET=_BLANK color=blue>$no_distinct_builds</A>";
  my $org_html_link="<A HREF=$link  TARGET=_BLANK >$no_organisms</A>";
  
  $summ.=$sbeamsMOD->encodeSectionItem(key => 'Number of builds in which Peptide found',
                                       tr_info=>$tr,
                                       value=>$build_html_link);
                                       
  $summ.=$sbeamsMOD->encodeSectionItem(key => 'Organisms in which Peptide found',
                                       tr_info=>$tr,
                                       value=>$org_html_link);
  
  print "<BR>\n";
  print "<TABLE WIDTH=600><BR>$summ</TABLE>\n";

### End first section

  #############################################################################
  #### Genome mappings section
    
  # Widget to allow show/hide of genome mapping section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'genome_mappings',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );
# Encode section header
#  'link' => $link,
# encodeSectionTable(
#  tr_info => $tr,

  my $mapHTML = qq~
  <TR><TD COLSPAN=2>&nbsp;</TD></TR>
  ~; 
  $n_genome_locations[0] = 0 if $n_genome_locations[0] < 0;
  $mapHTML .= $sbeamsMOD->encodeSectionHeader(
    text => "Genome Mappings: $n_genome_locations[0]",
    'link' => $link,
    bold => 1
  );
  my $last_chrom = "";
  my $last_protein = "";
  my $last_seq_used_length = "";
  my $n_indices=$#peptide_accession;

  my @rows;
  for my $key ( keys( %chrom_map ) ) {
    my @map = split( ':::', $key );

    my $current_chrom = $map[0];
    my $tmp_start = $map[1];
    my $tmp_end = $map[2];
    my $tmp_strand = $map[3];
    my $peptide_sequence = $map[4];

    # Defer...    my $current_prot = $map[$i];
    my $current_prot = $chrom_map{$key}->[0]; # For now just use the first

    # This indicates an unmapped peptide
    next unless $current_prot; 


    ## $current_peptide_seq is the entire peptide sequence, even if split over 2 exons
    my $current_peptide_seq = $peptide_sequence;

    #if ($current_chrom ne $last_chrom) {
    #  $mapHTML .= "<TR><TD NOWRAP COLSPAN=2><B>Chromosome $current_chrom: </B></TD><TD></TD></TR>\n";
    #}
    my $tmp_protein = $current_prot;
    my $tmp_seq;

    #### get residues on given exons ####
    my $exon_bp_length = ceil( (abs($tmp_end - $tmp_start)/3.) );

    ## if the strand is negative, count residues on exon starting from end
    if ($tmp_strand eq "-") {
      if ($tmp_protein eq $last_protein) {
        $tmp_seq = substr($current_peptide_seq, 
                        ((length $current_peptide_seq) - $last_seq_used_length - $exon_bp_length), 
                        ((length $current_peptide_seq) - $last_seq_used_length ) );
      } else {
	$tmp_seq = substr($current_peptide_seq, 
                        ((length $current_peptide_seq) - $exon_bp_length), 
                        (length $current_peptide_seq) );
      }

    #### Else from the start
    } elsif ($tmp_strand eq "+") {
      if ($tmp_protein eq $last_protein) {
	$tmp_seq = substr($current_peptide_seq, $last_seq_used_length, (length $current_peptide_seq));
      } else {
	$tmp_seq = substr($current_peptide_seq, 0, $exon_bp_length);
      }

    #### Otherwise, there's no proper mapping, but show information anyway
    } else {
      $tmp_seq = $current_peptide_seq;
    }


    $last_seq_used_length = length($tmp_seq);

    # Set up protein[s] display
    my $protein_display = makeProteinLink( name  => $tmp_protein, 
					   build => $parameters{atlas_build_id}); 

    my $extra = $#{$chrom_map{$key}};
    if ( $extra ) {
      my $all = join ', ', @{$chrom_map{$key}};
      my $all_links;
      for my $p ( @{$chrom_map{$key}} ) {
	$all_links .= makeProteinLink( build => $parameters{atlas_build_id},
				       name  => $p,
				       target => '_prot_info' ) . "<BR>\n"; 
      }

      $mapHTML .= $sbeams->getPopupDHTML();
      my $session_key = $sbeams->getRandomString( num_chars => 20,
						  char_set => ['A'..'Z', 'a'..'z', 0..9] );

      $sbeams->setSessionAttribute( key => $session_key,  value => $all_links );

      my $url = "$CGI_BASE_DIR/help_popup.cgi?title=Alternate%20Mappings;session_key=$session_key;email_link=no";
      my $more = qq~ &nbsp;&nbsp;[<A onClick=popitup("$url"); CLASS=pseudo_link>$extra more</A>]~;
      $protein_display = "<DIV TITLE='$all'>$protein_display $more</DIV>";
    }


    my $range = makeGenomeLink( start => $tmp_start,
				end => $tmp_end,
				strand => $tmp_strand,
				chrom => $current_chrom,
        acc => $current_prot,
				org => $organism[0] );

    $current_chrom ||= $sbeams->makeInactiveText('n/a');
    $tmp_strand = ( $tmp_strand =~ /\?/ ) ? $sbeams->makeInactiveText('n/a') : "<B>$tmp_strand</B>";
    push @rows, [ $current_chrom, $protein_display, $tmp_seq, $range, $tmp_strand ] if $tmp_seq;

    $last_chrom = $current_chrom;
    $last_protein = $current_prot;

  } # end for


  #### If there are some protein entries to display
  if ( @rows ) {
    unshift @rows, ['Chr', 'Protein', 'Residues on Exon', 'Exon Range', 'Strand'];
    $mapHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
                                                width => '600',
                                                tr_info => $tr,
                                                align  => [qw(center left left center center)],
                                                rows => \@rows );

  #### Otherwise, just confess what the original name was
  } else {
    $mapHTML .= qq~
    <TR><TD COLSPAN=2>
    <FONT COLOR=green>
    This peptide was identified in our original Sequest search, but
    cannot be mapped to the reference database.<BR>
    ~;
    $mapHTML .= "The original name from the search was $original_name[0]\n<BR>" if $original_name[0];
    $mapHTML .= qq~
    Click <A HREF=http://www.ncbi.nlm.nih.gov/blast/Blast.cgi?PROGRAM=blastp&DATABASE=nr&OVERVIEW=TRUE&EXPECT=1000&FILTER=L&QUERY=$peptide_sequence[0] TARGET=_blastit> here </A> to BLAST search this sequence at NCBI.
    </FONT>
    </TD></TR>
    ~;
  }


  print "<TABLE WIDTH=600>$mapHTML</TABLE>\n";

##  End mapping loop


  #############################################################################
  #### Modified Peptides Section

  # Widget to allow show/hide of modified peptides section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprot_mod_peps',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );
# Encode section header
#  'link' => $link,
# encodeSectionTable(
#  tr_info => $tr,

  my $modHTML .= $sbeamsMOD->encodeSectionHeader(
    text => "Modified Peptides",
   'link' => $link,
    bold => 1
  );
  my $modSQL = qq~
  SELECT distinct
  modified_peptide_sequence, MPI.peptide_charge, MPI.monoisotopic_parent_mz,
  MPI.best_probability, 
  MPI.n_observations, MPI.n_sibling_peptides, MPI.sample_ids  
  FROM $TBAT_PEPTIDE_INSTANCE PI
  INNER JOIN $TBAT_PEPTIDE P
   ON ( PI.peptide_id = P.peptide_id )
  JOIN $TBAT_MODIFIED_PEPTIDE_INSTANCE MPI
   ON ( PI.peptide_instance_id = MPI.peptide_instance_id )
  INNER JOIN $TBAT_ATLAS_BUILD AB 
   ON ( PI.atlas_build_id = AB.atlas_build_id )
  LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
   ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
  LEFT JOIN $TB_ORGANISM O
   ON ( BSS.organism_id = O.organism_id )
  LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
   ON ( PI.peptide_instance_id = PM.peptide_instance_id )
  LEFT JOIN $TBAT_BIOSEQUENCE BS
   ON ( PM.matched_biosequence_id = BS.biosequence_id )
  LEFT JOIN $TB_DBXREF DBX ON ( BS.dbxref_id = DBX.dbxref_id )
  WHERE 1 = 1
     $atlas_build_clause
     $peptide_name_clause
     $peptide_sequence_clause
  ORDER BY modified_peptide_sequence, MPI.peptide_charge ASC
  ~;

  my @mod_peps = $sbeams->selectSeveralColumns( $modSQL );

  my $cs_obj = SBEAMS::PeptideAtlas::ConsensusSpectrum->new();
  $cs_obj->setSBEAMS( $sbeams );
  my $consensus = $cs_obj->spectrum_search( seq => $peptide_sequence[0] );

  #### If a result is returned
  if ( scalar @mod_peps ) {
    $modHTML .= $sbeams->getPopupDHTML();

    #### Loops through resultset and do formatting
    for my $pep ( @mod_peps ) {
      $pep->[7] = '';
      
      for my $c_spectrum ( @$consensus ) {
        if ( $c_spectrum->[2] == $pep->[1] ) {

          if ( $peptide_sequence[0] eq $pep->[0] ) {
            # No mods except charge
            next if $c_spectrum->[8] && $c_spectrum->[8] ne $pep->[0];
          } else {
            next if $c_spectrum->[8];
          }

          my $title = "View consensus spectrum for peptide $pep->[0] (+$pep->[1])"; 
          $pep->[7] = "<A HREF='ShowOneSpectrum?NIST_library_spectrum_id=$c_spectrum->[0]' TARGET=blank><IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='$title'></A>";
          last;
        }
      }


      # Final formatting for list items
      $pep->[2] = sprintf("%0.4f", $pep->[2]);  # parent m/z
      $pep->[3] = sprintf("%0.2f", $pep->[3]) unless $pep->[3] == 1; # probability
      $pep->[3] = 1 if $pep->[3] == 1; # huh?
      $pep->[5] = sprintf("%0.1f", $pep->[5]) if $pep->[5]; # number of siblings
      $pep->[6] = sample_view( $pep->[6] ); # Sample IDs, keep list under control
      $pep->[0] = $sbeamsMOD->formatMassMods( $pep->[0] );
    }

    #### Add table column headings
    unshift @mod_peps, ['Modified Sequence', 'Charge', 'Mono Parent m/z', 'Best Prob', '# Obs', '# Siblings', 'Sample IDs', 'Consensus Spectrum' ];

    #### Format table
    $modHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
                                                 width => '600',
                                               tr_info => $tr,
                                                align  => [qw(left center right right right center center center)],
                                                  rows => \@mod_peps,
                                          rows_to_show => 10,
                                                nowrap => [1..7]
                                                );
    #### Display table
    print "<TABLE WIDTH=600><BR>$modHTML</TABLE>\n";
  }


  #############################################################################
  #### Validated Transitions Section

  # Widget to allow show/hide of modified peptides section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprot_valid_trans',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );

  my $transitionHTML = $sbeamsMOD->encodeSectionHeader(
    text => "Annotated Transitions",
   'link' => $link,
    bold => 1
  );

  my $mrm_transitions = get_mrm_transitions( $peptide_accession[0] );

  #### If a result is returned
  if ( scalar @$mrm_transitions ) {
#    $transitionHTML .= $sbeams->getPopupDHTML();

    #### Loops through resultset and do formatting
    for my $pep ( @$mrm_transitions ) {
      $pep->[0] = $sbeamsMOD->formatMassMods( $pep->[0] );
      $pep->[2] = sprintf("%0.2f", $pep->[2]);
      $pep->[3] = sprintf("%0.2f", $pep->[3]);
      for my $idx ( 0..$#{$pep} ) {
        $pep->[$idx] = $sbeams->makeInactiveText('n/a') if !defined $pep->[$idx];
      }
    }
    my @labels = ( 'Sequence', 'Charge', 'q1_mz', 'q3_mz', 'Label', 'CE', 'RT', 'Instr', 'Annotator', 'Quality');

    #### Add table column headings
    unshift @$mrm_transitions, \@labels;

    #### Format table
    $transitionHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
                                                      tr_info => $tr,
                                                        width => '600',
                                                       align  => [qw(left center right right center right right left left left)],
                                                         rows => $mrm_transitions );
    #### Display table
    print "<TABLE WIDTH=600><BR>$transitionHTML</TABLE>\n" if $#{$mrm_transitions};
  }


  my $marker_peptides = get_synthesized_peptides( $peptide_accession[0] );
  my $markerHTML = $sbeamsMOD->encodeSectionHeader(
    text => "Reference Peptides",
   'link' => $link,
    bold => 1
  );

  #### If a result is returned
  if ( scalar @$marker_peptides ) {
#    $transitionHTML .= $sbeams->getPopupDHTML();

    #### Loops through resultset and do formatting
    for my $pep ( @$marker_peptides ) {
#      $pep->[2] = sprintf("%0.2f", $pep->[2]);
#      $pep->[3] = sprintf("%0.2f", $pep->[3]);
#      $pep->[4] = 1 if $pep->[4] == 1;
       $pep->[4] = $sbeamsMOD->formatMassMods( $pep->[4] );
       $pep->[2] = $sbeams->makeInactiveText('n/a') if !$pep->[2];
    }
    my @labels = ( 'Peptide Sequence', 'Type', 'Publication', 'Annotator', 'Modified Sequence' );

    #### Add table column headings
    unshift @$marker_peptides, \@labels;

    #### Format table
    $markerHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
                                                      tr_info => $tr,
                                                        width => '600',
                                                       align  => [qw(left center left left center)],
                                                         rows => $marker_peptides );
    #### Display table
    print "<TABLE WIDTH=600><BR>$markerHTML</TABLE>\n" if $#{$marker_peptides};
  }


  #############################################################################
  #### Spectra Section

  # Widget to allow show/hide of modified peptides section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprot_indiv_spec',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );
# Encode section header
#   'link' => $link,
# encodeSectionTable(
#                                               tr_info => $tr,
  my $modHTML .= $sbeamsMOD->encodeSectionHeader(
    text => "Individual Spectra",
   'link' => $link,
    bold => 1
  );
  my $modSQL = qq~
  SELECT modified_peptide_sequence, MPI.peptide_charge,
         SMP.sample_id,I.instrument_name, SI.probability, S.spectrum_name,
         SI.spectrum_identification_id
    FROM $TBAT_PEPTIDE_INSTANCE PI
   INNER JOIN $TBAT_PEPTIDE P
         ON ( PI.peptide_id = P.peptide_id )
    JOIN $TBAT_MODIFIED_PEPTIDE_INSTANCE MPI
         ON ( PI.peptide_instance_id = MPI.peptide_instance_id )
   INNER JOIN $TBAT_ATLAS_BUILD AB
         ON ( PI.atlas_build_id = AB.atlas_build_id )
    LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
         ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
    LEFT JOIN $TB_ORGANISM O
         ON ( BSS.organism_id = O.organism_id )
   INNER JOIN $TBAT_SPECTRUM_IDENTIFICATION SI
         ON ( MPI.modified_peptide_instance_id = SI.modified_peptide_instance_id )
    LEFT JOIN $TBAT_SPECTRUM S
         ON ( SI.spectrum_id = S.spectrum_id )
    LEFT JOIN $TBAT_SAMPLE SMP
         ON ( S.sample_id = SMP.sample_id )
    LEFT JOIN $TBPR_INSTRUMENT I
         ON ( SMP.instrument_model_id = I.instrument_id )
   WHERE 1 = 1
     $atlas_build_clause
     $peptide_name_clause
     $peptide_sequence_clause
  ORDER BY modified_peptide_sequence, MPI.peptide_charge, S.spectrum_name ASC
  ~;

  my @mod_peps = $sbeams->selectSeveralColumns( $modSQL );

  #### If a result is returned
  if ( scalar @mod_peps ) {
    $modHTML .= $sbeams->getPopupDHTML();

    #### Loops through resultset and do formatting
    for my $pep ( @mod_peps ) {
      $pep->[4] = sprintf("%0.3f", $pep->[4]) unless $pep->[4] == 1;
      $pep->[4] = 1 if $pep->[4] == 1;
      my $img = "<IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='View spectrum for $pep->[0] (+$pep->[1])'>";
      $pep->[6] = qq~<A HREF="$CGI_BASE_DIR/PeptideAtlas/ShowObservedSpectrum?spectrum_identification_id=$pep->[6]&peptide=$pep->[0]&assumed_charge=$pep->[1]" TARGET=blank>$img</A>~;
      $pep->[0] = $sbeamsMOD->formatMassMods( $pep->[0] );
    }

    #### Add table column headings
    unshift @mod_peps, ['Modified Sequence', 'Chg', 'Smpl', 'Instr', 'Prob', 'Spectrum Name', 'Spectrum' ];

    #### Format table
    $modHTML .= $sbeamsMOD->encodeSectionTable( header => 1, 
                                                 width => '600',
                                               tr_info => $tr,
                                                align  => [qw(left center right right right center center)],
                                                  rows => \@mod_peps,
                                          rows_to_show => 10,
                                              max_rows => 500
                                              );
    #### Display table
    print "<TABLE WIDTH=600><BR>$modHTML</TABLE>\n";
  }


  #############################################################################
  #### Samples Section

  my $sampleSQL = qq ~
     SELECT PS.sample_id
     FROM $TBAT_PEPTIDE_INSTANCE PI
     INNER JOIN $TBAT_PEPTIDE P
      ON ( PI.peptide_id = P.peptide_id )
     INNER JOIN $TBAT_ATLAS_BUILD AB 
      ON ( PI.atlas_build_id = AB.atlas_build_id )
       INNER JOIN $TBAT_PEPTIDE_INSTANCE_SAMPLE PIS
       ON ( PI.peptide_instance_id = PIS.peptide_instance_id )
      INNER JOIN $TBAT_SAMPLE PS
      ON ( PIS.sample_id = PS.sample_id )
     WHERE 1 = 1
     $atlas_build_clause
     $peptide_name_clause
     $peptide_sequence_clause
  ~;

  my @samples = $sbeams->selectOneColumn( $sampleSQL );
  # Widget to allow show/hide of modified peptides section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprot_obs_sample',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );
# Encode section header
#   'link' => $link,
# encodeSectionTable(
#                                               tr_info => $tr,

  my ($sheader, $sHTML) = $sbeamsMOD->getSampleDisplay(sample_ids => \@samples,
                                                           'link' => $link,
                                                           tr_info => $tr );
  print "<TABLE WIDTH=600 ><TR><TD COLSPAN=2>&nbsp;</TD></TR>" . $sheader;
  print "$sHTML";
  print "</TABLE>\n";
        }

    #### If QUERY was not selected, then tell the user to enter some parameters
  } else {

        if ($sbeams->invocation_mode() eq 'http') {

            print "<H4>Select parameters above and press QUERY</H4>\n";

        } else {

            print "You need to supply some parameters to contrain the query\n";

        }

    }

} # end handle_request

sub format_refpep {
  my $annot = shift || return '';
  my $peptide_mass = $modification_helper->getPeptideMass( peptide => $annot->[0],
                                                           precision => 2 );  
  my $ptext =<<"  END";
  <TABLE>
    <TR><TD NOWRAP=1>Type:</TD><TD NOWRAP=1>$annot->[1]</TD></TR>
    <TR><TD NOWRAP=1>Sequence:</TD><TD NOWRAP=1>$annot->[0]</TD></TR>
    <TR><TD NOWRAP=1>Mass:</TD><TD NOWRAP=1>$peptide_mass</TD></TR>
    <TR><TD NOWRAP=1>Submitted by:</TD><TD NOWRAP=1>$annot->[3]</TD></TR>
  </TABLE>
  END
#  $ptext =~ s/\'/\\\'/gm;
  $ptext =~ s/\n//gm;
  return ( $sbeamsMOD->make_pa_tooltip( link_text => $annot->[0],
                                        tip_text => $ptext,
                                        link_class => 'pseudo_link' ) );

#  return "<SPAN CLASS=pseudo_link onMouseover=\"showTooltip(event, '$ptext')\" onMouseout=\"hideTooltip()\">$annot->[0]</SPAN>";
}

sub get_mrm_transitions {
  my $accession = shift || return [];

  # Project control
  my @accessible = $sbeams->getAccessibleProjects();
  my $projects = join( ",", @accessible );
  return '' unless $projects;

  my $sql =<<"  END";
  SELECT
--  modified_peptide_annotation_id,
  modified_peptide_sequence,
  peptide_charge, 
  q1_mz,
  q3_mz,
  q3_ion_label,  
  collision_energy,
  retention_time,
  instrument,
  CASE WHEN contact_id IS NULL 
    THEN annotator_name 
    ELSE username 
    END AS name,
  level_name
  FROM $TBAT_MODIFIED_PEPTIDE_ANNOTATION MPA 
  JOIN $TBAT_PEPTIDE P ON MPA.peptide_id = P.peptide_id
  JOIN $TBAT_TRANSITION_SUITABILITY_LEVEL TSL 
    ON TSL.transition_suitability_level_id = MPA.transition_suitability_level_id
  LEFT JOIN $TB_USER_LOGIN UL ON UL.contact_id = MPA.annotator_contact_id
  WHERE peptide_accession = '$accession'
  AND project_id IN ( $projects )
  END
  my @rows = $sbeams->selectSeveralColumns($sql);
  return \@rows;
}

sub get_synthesized_peptides {
  my $accession = shift || return [];

  # Project control
  my @accessible = $sbeams->getAccessibleProjects();
  my $projects = join( ",", @accessible );
  return '' unless $projects;

  my $sql =<<"  END";
  SELECT
--  peptide_annotation_id, 
    P.peptide_sequence, peptide_annotation,
  publication_name,
--  P.peptide_id,
  CASE WHEN contact_id IS NULL 
    THEN annotator_name 
    ELSE username 
    END AS name,
  PA.peptide_sequence
  FROM $TBAT_PEPTIDE_ANNOTATION PA 
  JOIN $TBAT_PEPTIDE P ON PA.peptide_id = P.peptide_id
  LEFT JOIN $TB_USER_LOGIN UL ON UL.contact_id = PA.annotator_contact_id
  LEFT JOIN $TBAT_PUBLICATION PP ON PP.publication_id = PA.publication_id
  WHERE peptide_accession = '$accession'
  AND project_id IN ( $projects )
  END
  my @rows = $sbeams->selectSeveralColumns($sql);
  return \@rows;
}

sub add_transition_link {
  my $pep = shift;
  my $mrm_transitions = shift;
  my $link = '';
  for my $transition ( @$mrm_transitions ) {
    if ( $pep->[1] == $transition->[2] ) {
      return "<A HREF='ViewMRM?sequence=$pep->[2];modified_peptide_annotation_id=$transition->[0]'>$transition->[1]</A>";
    }
  }
  return '&nbsp;';
}

sub sample_view {
  my $samples = shift;
  my $tot = $samples =~ tr/,/,/;

  # If we have 5 or fewer, go with the flow
  return($samples) if $tot <= 5;

  $samples =~ s/\s//g;
  my @samples = split(',', $samples);

  my $viewable = join( ',', @samples[0..3] );
  my $session_samples = "$viewable,<BR>\n";
  my $cnt = 0;
  my $sep = '';
  for ( my $j = 4; $j <= $#samples; $j++ ) {
    $cnt++;
    $session_samples .= $sep . $samples[$j];
    $sep = ',';
    unless( $cnt % 4 ) {
      $session_samples .= ",<BR>\n"; 
      $sep = '';
    }
  }
  $session_samples .= "<BR>\n";

  my $more = $tot - 4;

  my $key = $sbeams->getRandomString(num_chars => 20);
  $sbeams->setSessionAttribute( key => $key,  value => $session_samples );

  my $url = "$CGI_BASE_DIR/help_popup.cgi?title=Observed%20in%20Samples;session_key=$key;email_link=no";
  my $morelink = qq~ &nbsp;&nbsp;[<A onClick=popitup("$url"); CLASS=pseudo_link>$more more</A>]~;
  return "$viewable $morelink";
}

sub makeProteinLink {
  my %args = @_;
  for ( qw( name build ) ) {
    die "missing parameter $_" unless $args{$_};
  }
  my $target = ( $args{target} ) ? "TARGET=$args{target}" : '';

  my $link = "<A HREF='$CGI_BASE_DIR/PeptideAtlas/GetProtein?atlas_build_id=";
  $link   .= "$args{build}&protein_name=$args{name}&action=QUERY' ";
  $link   .= "class='text_link' $target>$args{name}</A>";

  return $link;
}

sub makeGenomeLink {
  my %args = @_;
#### EDeutsch commented out to allow peptides with mappings to proteins
#### without coordinates.  May not be a correct fix
#  for ( qw( start end strand chrom org ) ) {
#    die "missing parameter $_" unless $args{$_};
#  }
  # Length specified by range
 
  return $sbeams->makeInactiveText( 'n/a' ) unless $args{chrom};
  
  my $len = abs( $args{start} - $args{end} );

  # want to show some flanking info, minimun 2KB
#  my $extra = ( $len >= 2000 ) ? 0 : int((2000 - $len)/2);
  my $extra = 1000;

  my $org = $args{org};
  $org =~ s/ /_/g;
  my $chr = $args{chrom};

   # Ensembl uses roman numerals for yeast chromosomes...
  if ( $org =~ /^Sacch/ ) {
    $chr = $sbeams->getRomanNumeral( number => $chr ) || $chr; # Fallback...
  }

## xxxxxxx is this a debug statement?
# print "<br/><br/>$org<br/<br/>";

  my $vc_start = $args{start} - $extra;
  my $vc_end = $args{end} + $extra;
  if ( $args{start} > $args{end} ) {
    $vc_start = $args{end} - $extra;
    $vc_end = $args{start} + $extra;
  }
  $vc_start = 0 if $vc_start < 0;

  my $link = '';
  if ( $org =~ /Halo/ ) {
    # Currently halo has chromosome designations of MAIN, PNRC100 and PNRC200,
    # but KEGG wants 'c', pNRC100 and pNRC200
    $chr =~ s/P/p/;
    $chr = 'c' if $chr =~ /MAIN/;

    $link = "<A HREF='http://www.genome.jp/kegg-bin/show_genomemap?ORG=hal&CHR=$chr&START_POS=$vc_start&ACCESSION=$args{acc}' TARGET=_ensembl>" .
            "<DIV Title='Explore range in KEGG contig viewer'> $args{start} - $args{end} </DIV> </A>";
  } else {
    $link = "<A HREF='http://www.ensembl.org/$org/contigview?region=$chr;vc_start=$vc_start;vc_end=$vc_end' TARGET=_ensembl>" .
            "<DIV Title='Explore range in Ensembl contig viewer'> $args{start} - $args{end} </DIV> </A>";
  }
  return $link;

}


#######################################################################
# get_atlas_build_id -- get atlas_build_id, given name
# @param atlas_build_name
# @return atlas_build_id
#######################################################################
sub get_atlas_build_id
{
    my %args = @_;

    my $atlas_build_name = $args{atlas_build_name}
      || die "need atlas_build_name";

    my $sql = qq~
        SELECT atlas_build_id
        FROM $TBAT_ATLAS_BUILD
        WHERE atlas_build_name = '$atlas_build_name'
    ~;

    my ($atlas_build_id) = $sbeams->selectOneColumn($sql);

    return $atlas_build_id;
}

#######################################################################
# get_atlas_build_name -- get atlas_build_name, given id
# @param atlas_build_id
# @return atlas_build_name
#######################################################################
sub get_atlas_build_name
{
    my %args = @_;

    my $atlas_build_id = $args{atlas_build_id}
      || die "need atlas_build_id";

    my $sql = qq~
        SELECT atlas_build_name
        FROM $TBAT_ATLAS_BUILD
        WHERE atlas_build_id = '$atlas_build_id'
    ~;

    my ($atlas_build_name) = $sbeams->selectOneColumn($sql);

    return $atlas_build_name;
}

#######################################################################
# get_default_atlas_build_id
# @return default_atlas_build_id if there is one
#######################################################################
sub get_default_atlas_build_id
{


    my %args = @_;
    return unless $args{accessible_projects};

    my $default_atlas_build_id;

    my $sql = qq~
        SELECT MAX( DAB.atlas_build_id )
        FROM $TBAT_DEFAULT_ATLAS_BUILD DAB
        JOIN $TBAT_ATLAS_BUILD AB ON AB.atlas_build_id = DAB.atlas_build_id
        WHERE project_id IN ( $args{accessible_projects} )
        AND DAB.record_status = 'N'
    ~;

    my @row = $sbeams->selectrow_array($sql);
    


    return $row[0];
}

