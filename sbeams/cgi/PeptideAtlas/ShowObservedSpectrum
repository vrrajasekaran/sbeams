#!/tools32/bin/perl
#!/usr/local/bin/perl

BEGIN {
push @INC, qw( /net/db/src/SSRCalc/ssrcalc .  /tools32/lib/perl5/5.8.0/i386-linux-thread-multi /tools32/lib/perl5/5.8.0 /tools32/lib/perl5/site_perl/5.8.0/i386-linux-thread-multi /tools32/lib/perl5/site_perl/5.8.0 /tools32/lib/perl5/site_perl );
}

###############################################################################
# Program     : ShowObservedSpectrum
#
# Description : This CGI program displays a single spectrum in PeptideAtlas
#
# Based upon the ShowSpectrum.cgi in the Proteomics module by
# Kerry & Eric Deutsch
#
###############################################################################


###############################################################################
# Basic SBEAMS setup
###############################################################################
use strict;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($q $sbeams $sbeamsMOD $PROG_NAME
             $current_username $massCalculator );

use SBEAMS::Connection qw($q);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;

use SBEAMS::Proteomics::PeptideMassCalculator;
#$massCalculator = new SBEAMS::Proteomics::PeptideMassCalculator;

use PGPLOT;
use PDL;
use PDL::Graphics::PGPLOT;

use File::Basename;

use Carp;
$SIG{__DIE__} = sub { &Carp::confess };
use CGI::Carp qw (fatalsToBrowser);

#$q = new CGI;
$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);

$PROG_NAME="ShowObservedSpectrum";

# Define various integers to represent our drawing colors
my $pink = 6;
my $navy = 11;
my $lt_green = 10;
my $red = 2;
my $blue = 4;
my $green = 3;
my $black = 14;
my $min_color_code = 2;       # the smallest number used above
my @used_colors = ( $red, $blue, $pink, $navy, $black );

# Define various integers to represent ion types
my $y_ion = 1;
my $b_ion = 2;

# Allowable neutral losses
my @neutral_loss_masses = ();

###############################################################################
# Define global variables if any and execute main()
###############################################################################
main();


###############################################################################
# Main Program:
#
# If $sbeams->Authenticate() succeeds, print header, process the CGI request,
# print the footer, and end.
###############################################################################
sub main {

  #### Do the SBEAMS authentication and exit if a username is not returned
  exit unless ($current_username = $sbeams->Authenticate(
    permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
      'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
    #connect_read_only=>1,
    allow_anonymous_access=>1,
  ));


  #### Process certain actions, then print the header, figure and do what the user wants, and print footer
  processDatabaseActions();
  $sbeamsMOD->display_page_header();
  processRequest();
  $sbeamsMOD->display_page_footer();

  $sbeams->display_page_footer(close_tables=>'YES',
    separator_bar=>'YES',display_footer=>'NO');

} # end main


###############################################################################
# Process insert/update/delete, if any, then redirect
###############################################################################
sub processDatabaseActions {
    my $redirect = 0;
    my %parameters;

    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);
    $sbeams->processStandardParameters(parameters_ref=>\%parameters);

    my $apply_action  = $q->param('apply_action');

    if ($apply_action eq "UPDATE ANNOTATION") {
	my %rowdata = (
		       spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
		       comment => $parameters{user_spectrum_commment}
		       );

	my $PK = $sbeams->updateOrInsertRow(
					    update => 1,
					    table_name => $TBAT_SPECTRUM_ANNOTATION,
					    rowdata_ref => \%rowdata,
					    PK => 'spectrum_annotation_id',
					    PK_value => $parameters{spectrum_annotation_id},
					    return_PK => 1,
					    add_audit_parameters => 1
					    );

	if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been updated." ); }
	else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem updating your annotation record." ); }

	$redirect++;

    } elsif ($apply_action eq "ADD ANNOTATION") {
	my %rowdata = (
		       annotator_contact_id => $sbeams->getCurrent_contact_id(),
		       spectrum_identification_id => $parameters{spectrum_identification_id},
		       spectrum_id => $parameters{spectrum_id},
		       identified_peptide_sequence => $parameters{peptide},
		       identified_peptide_charge => $parameters{assumed_charge},
		       spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
		       comment => $parameters{user_spectrum_commment}
		       );

	my $PK = $sbeams->updateOrInsertRow(
				   insert => 1,
				   table_name => $TBAT_SPECTRUM_ANNOTATION,
				   rowdata_ref => \%rowdata,
				   return_PK => 1,
				   add_audit_parameters => 1
				   );

	if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been added." ); }
	else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem inserting your annotation record." ); }

	$redirect++;

    } elsif ($apply_action eq "DELETE ANNOTATION") {
	my %rowdata = (
		       record_status => 'D'
		       );

	my $PK = $sbeams->updateOrInsertRow(
					    update => 1,
					    table_name => $TBAT_SPECTRUM_ANNOTATION,
					    rowdata_ref => \%rowdata,
					    PK => 'spectrum_annotation_id',
					    PK_value => $parameters{spectrum_annotation_id},
					    return_PK => 1,
					    add_audit_parameters => 1
					    );

	if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been deleted." ); }
	else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem deleting your annotation record." ); }

	$redirect++;
    }

    if ($redirect) {
	$q->delete( 'apply_action' );
	print $q->redirect( $q->self_url() );
	exit;
    }

}


###############################################################################
# Print Entry Form
###############################################################################
sub processRequest {

    #### Define some general variables
    my ($i,$element,$key,$value,$sql);

    my %parameters;

    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);

    $sbeams->processStandardParameters(parameters_ref=>\%parameters);

    my $apply_action  = $q->param('apply_action');

    #$sbeams->printDebuggingInfo($q);

    my $assumed_charge = $parameters{'assumed_charge'};

    my $displayCharges = $parameters{'charge'};
    my @displayCharges;
    if ($displayCharges) {
      @displayCharges = split(',',$displayCharges);
    } elsif ($assumed_charge) {
      my $icharge = 1;
      while ($icharge <= $assumed_charge && $icharge < 4) {
        push(@displayCharges,$icharge);
	$icharge++;
      }
      $displayCharges = join(",",@displayCharges);
    }

    my $neutral_loss = $parameters{'neutral_loss'};
    my @neutral_loss;
    if ($neutral_loss) {
      @neutral_loss = split(',',$parameters{'neutral_loss'});
    }
    for my $nl (@neutral_loss) {
      if ($nl eq '17') {
	push (@neutral_loss_masses, 17.031);
      } elsif ($nl eq '18') {
	push (@neutral_loss_masses, 18.015);
      } elsif ($nl eq '35') {
	push (@neutral_loss_masses, 35.046);
      } elsif ($nl eq '45') {
	push (@neutral_loss_masses, 45.04);
      }
    }

    $parameters{'ionlab'} = "Horizontal" unless $parameters{'ionlab'};
    my ($labangle,$fjust);
    if ($parameters{'ionlab'} eq "Vertical") {
      $labangle = 90;
      $fjust = 0;
    } else {
      $labangle = 0;
      $fjust = 0.5;
    }

    print qq!
	<P>
	<FORM METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
    !;

    #### Set up the table and data column
    print qq!
	<TABLE BORDER=0 CELLPADDING=3 WIDTH="675">
	<TR VALIGN=top>
	<TD VALIGN=top >
	<PRE>\n!;

    #### If we have a spectrum_id, find the mass modifications
    if ($parameters{'spectrum_identification_id'})
    {
        my $sql = qq~
            SELECT peptide_sequence,peptide_charge,average_parent_mz,
                   MPI.modified_peptide_sequence,S.spectrum_id
              FROM $TBAT_SPECTRUM_IDENTIFICATION SI
              JOIN $TBAT_MODIFIED_PEPTIDE_INSTANCE MPI
                   ON ( SI.modified_peptide_instance_id = MPI.modified_peptide_instance_id )
              JOIN $TBAT_PEPTIDE_INSTANCE PI
                   ON ( MPI.peptide_instance_id = PI.peptide_instance_id )
             INNER JOIN $TBAT_PEPTIDE P
                   ON ( PI.peptide_id = P.peptide_id )
              LEFT JOIN $TBAT_SPECTRUM S
                   ON ( SI.spectrum_id = S.spectrum_id )
            WHERE spectrum_identification_id = '$parameters{spectrum_identification_id}'
        ~;

        my @rows = $sbeams->selectSeveralColumns($sql);

        foreach my $row (@rows)
        {
            my ($seq, $chg, $mz, $mod_seq, $spectrum_id) = @{$row};
            $parameters{'peptide'} = $mod_seq;
            $parameters{'assumed_charge'} = $chg;
            $parameters{'precursor_mass'} = $mz;
            $parameters{'protein_name'} = 'foo';
            $parameters{'protein_name_alt'} = 'bar';
            $parameters{'modified_sequence'} = $mod_seq;
            $parameters{'spectrum_id'} = $spectrum_id;
        }
    }

    if ( $parameters{peptide} ) {
	print "<TR><TD COLSPAN=2 CLASS=section_description ALIGN=CENTER>Spectrum for $parameters{modified_sequence} <SUP>+$parameters{assumed_charge}</SUP></TD></TR>\n";
	print '<TR ID="annotations_head" style="display:none"><TD ID="annotations_summary" COLSPAN="2">-- No annotations here --</TD></TR>';
    }

    # lots of lint here...
    my $peptide = $parameters{peptide};
    $peptide =~ s/^.\.//;
    $peptide =~ s/\..$//;
    my $precursor_mass = $parameters{'precursor_mass'};
    my $charge = $parameters{'assumed_charge'};
    my $protein_name = $parameters{'protein_name'};
    my $protein_name_alt = $parameters{'protein_name_alt'};
    my $modified_sequence = $parameters{'modified_sequence'};

    $parameters{assumed_charge} = $charge;


    #### Calculate peptide mass information
    my $masstype = $parameters{masstype} || 0;
    my ($AAmasses_ref) = InitializeMass($masstype);

    my %spectrum = get_spectrum(
        spectrum_id=>$parameters{spectrum_id});

    unless (%spectrum) 
    {
      print "ERROR: Unable to load spectrum\n";
      return;
    }

    my ($i,$mass,$intensity,$massmin,$xticks);
    my ($massmax,$intenmax)=(0,0);
    my @spectrum_array;

    for ($i=0; $i<$spectrum{n_peaks}; $i++) {
      $mass = $spectrum{masses}->[$i];
      $intensity = $spectrum{intensities}->[$i];
      push(@spectrum_array,[$mass,$intensity]);
      $massmin = $mass if ($i == 0);
      $massmax = $mass if ($mass > $massmax);
      $intenmax = $intensity if ($intensity > $intenmax);
    }

    #### Compute data and plot bounds
    $parameters{xmin} = int($massmin/200)*200 unless $parameters{xmin};
    $parameters{xmax} = int($massmax/200)*200+200 unless $parameters{xmax};
    $parameters{frag_mz_tol} = 1.0 unless $parameters{frag_mz_tol};
    $parameters{ymin_nl} = $intenmax * 0.1
			unless $parameters{ymin_nl};

    unless (exists $parameters{ymax})
    {
        $parameters{ymax} = $intenmax * 1.1;
    }

    if ($q->param("reset") eq "ZOOM OUT")
    {
      $parameters{ymax} = $intenmax * 1.1;;
      $parameters{xmin} = int($massmin/100)*100;
      $parameters{xmax} = int($massmax/100)*100+100;
    }

    my $maxval = $intenmax;
    #$intenmax *= 1.3 / ( $parameters{zoom} || 1 );
    my $interval = $parameters{ymax} / 20;
    my $interval_power = ( $interval ) ? int( log($interval) / log(10) ) : 0;
    my $roundval = 10**$interval_power;
    #$intenmax = int($intenmax/$roundval)*$roundval;
    $parameters{ymax} = int( $parameters{ymax} /$roundval)*$roundval;
    my $ydiv = $parameters{ymax} / 5;

    #### Calculate fragment ions for the given peptide
    my @residues = Fragment($peptide);
    my $length = $#residues + 1;

    #### Initialize the plot environment
    my($progname)= basename $0;
    #my($tmpfile) = "$progname.$$.@{[time]}.gif";
    #### Reduce length because of PGPLOT 80 char limit??
    my($tmpfile) = "Spec.$$.@{[time]}.gif";

#   $parameters{gifwidth} = 640 unless $parameters{gifwidth};
#   $parameters{gifheight} = 480 unless $parameters{gifheight};
    $parameters{gifwidth} = 800 unless $parameters{gifwidth};
    $parameters{gifheight} = 400 unless $parameters{gifheight};

    if ($apply_action eq "PRINTABLE FORMAT") {
      $parameters{gifwidth} = 480;
      $parameters{gifheight} = 384;
    }

    #print "Writing GIF to: $PHYSICAL_BASE_DIR/tmp/images/$tmpfile\n";
    my $win = pg_setup(Device=>"$PHYSICAL_BASE_DIR/tmp/images/$tmpfile/gif",
        title=>"$parameters{peptide}",
        xmin=>$parameters{xmin}, xmax=>$parameters{xmax},
        ymax=>$parameters{ymax}, ydiv=>$ydiv, nyticks=>5,
        gifwidth=>$parameters{gifwidth},
        gifheight=>$parameters{gifheight}
    );

    pgsch 1.0;
    my $prec = sprintf ("%0.1f", $precursor_mass);
    pgmtext 'T',0.7,.01,0,"Peak value = $maxval  Precursor m/z = $prec";
#   pgmtext 'RV',-2,1.02,1,"Assumed charge = $parameters{assumed_charge}";
    pgmtext 'RV',-2,1.02,1,"Charge = $parameters{assumed_charge}";

    defineColors();

    my @peakcolors;              # array of colors, one per peak
    my @theoretical_spectrum;    # populated by printIons;
                                 #  for recalling resultset
    my $mzlist_ref = {};       # storage for info on all fragments

    # Get info on all possible fragments for this peptide, including
    # neutral losses and all possible charge states.
    # Create labels for peaks.
    my $fragments_aref = getAllPossibleFragments(
              Residues=>\@residues, Charges=>\@displayCharges,
              MassList=>$mzlist_ref,
              AAmasses=>$AAmasses_ref,
              precursor_charge=>$parameters{assumed_charge},
           );
    my @fragments = @$fragments_aref;
    # ion must have predicted m/z within +/- this value of
    # peak for identification
    my $frag_mz_tol = $parameters{frag_mz_tol} || 2; 
    my $ymin_nl = $parameters{ymin_nl} || 0;

    # Filter the fragments to get only those close to an actual peak
    my $matched_fragments_aref = getMatchedFragments(
              Fragments=>$fragments_aref, SpecData=>\%spectrum,
              YminNL=>$ymin_nl,
              FragMzTol=>$frag_mz_tol);

    # Annotate each fragment with the height at which to draw its
    # label. Quietly set to empty string labels we don't want to draw.
    matchFragmentsWithPeaks(
		  Fragments=>$matched_fragments_aref,
		  SpecData=>\@spectrum_array,
		  FragMzTol=>$frag_mz_tol,
                  MZlist=>$mzlist_ref,
		  Win=>$win,
		  Xmin=>$parameters{xmin}, Xmax=>$parameters{xmax},
		  Ymax=>$parameters{ymax}, Angle=>$labangle, Fjust=>$fjust);

    # Add labels to unidentified peaks, if requested
    # Whoa, this is all wrong! The info we need is not in
    # $fragments_aref, and it is not to be stored there, either!!!
#    if ( 1 || $parameters{mzlabels}) {
#      LabelUnidentifiedPeaks(
#	      Fragments=>$matched_fragments_aref,
#              YminNL=>$ymin_nl,
#      );
#    }

    #### Plot the peaks, colorizing according to nearest label
    PlotPeaks(
                     SpecData=>\%spectrum,
		     Fragments=>$matched_fragments_aref,
		     Win=>$win,
		     PeakColors=>\@peakcolors);

    #### Draw the labels on the peaks
    LabelPeaks(
		  Fragments=>$matched_fragments_aref,
		  Win=>$win,
		  Xmin=>$parameters{xmin}, Xmax=>$parameters{xmax},
		  Ymax=>$parameters{ymax}, Angle=>$labangle, Fjust=>$fjust);

    #### Loop over each desired charge to print text chart of
    ####  predicted peptide ions.
    my $charge;
    my $buffer = '';
    foreach $charge (@displayCharges) {
      #my ($mzlist_ref) = CalcIonsOld(Residues=>\@residues, Charge=>$charge,
#      CalcIonsOld(Residues=>\@residues, Charge=>$charge,
#                                    mzlist_ref=>$mzlist_ref,
#                                    Fragments=>$matched_fragments_aref,
#                                    AAmasses=>$AAmasses_ref);

      #### Make the plot and figure out what the labels should be
#      $win = PlotPeaksOld(SpecData=>\%spectrum,
#		       MZlist=>$mzlist_ref, Charge=>$charge,
#		       Win=>$win, Length=>$mzlist_ref->{length},
#		       PeakColors=>\@peakcolors);

      #### Print out the peptide ion information
      $buffer .= printIonTable(mzlist_ref=>$mzlist_ref,color=>1,html=>1,
        charge=>$charge,length=>$length,
        theoretical_spectrum_ref=>\@theoretical_spectrum);

    } # end foreach

    #### Label tall unidentified peaks with their m/z values, if requested
    #### Isn't working for re-display (i.e. zoom).
    if ( 0 && $parameters{mzlabels}) {
      my $mz_label_threshold = $parameters{mzlabels} || 0.05;
      if (($mz_label_threshold < 0 ) || ( $mz_label_threshold > 1.0 ) ||
            ($mz_label_threshold * 1 ne $mz_label_threshold)) {
	die("ERROR: mzlabels parameter must be number between 0.0 and 1.0");
      }
      LabelUnidentifiedPeaksOld( SpecData=>\%spectrum, Win=>$win, 
                  MZ_threshold=>$mz_label_threshold,
		  Xmin=>$parameters{xmin}, Xmax=>$parameters{xmax},
		  Ymax=>$parameters{ymax}, Angle=>$labangle, Fjust=>$fjust);
    }



    #### Draw Precursor mass symbol
    if ($parameters{precursor_mass}) {
      pgsci 2;    #### Default color
      pgsch 2;    #### Character size
      pgslw 5;    #### Line thinkness
      pgsclp(0);   #### Disable clipping
      pgpt(1,$parameters{precursor_mass},-0.34 * $interval,7);
      pgsch 1;    #### Character size
      pgpt(1,$parameters{precursor_mass},-0.34 * $interval,7);
    }


    #### Finish and close the plot
    $win->close();


    #### Set up the image cell
    print qq~</PRE>
	</TD>
	<TD VALIGN=top>
	<IMG SRC="$HTML_BASE_DIR/tmp/images/$tmpfile"><BR>
    ~;


    my $hidden_form_fields = qq~
        <INPUT TYPE="hidden" NAME="spectrum_identification_id" VALUE="$parameters{spectrum_identification_id}">
        <INPUT TYPE="hidden" NAME="assumed_charge" VALUE="$parameters{assumed_charge}">
        <INPUT TYPE="hidden" NAME="peptide" VALUE="$parameters{peptide}">
	~;

    print $hidden_form_fields;

    #### Charge selector
    my $onChange = "";
   $sql = "SELECT option_key,option_value FROM $TBAT_QUERY_OPTION " .
          " WHERE option_type = 'charge_constraint' " .
          " ORDER BY sort_order,option_value";
   my $optionlist = $sbeams->buildOptionList($sql,$displayCharges);

   print qq~
       Charge: <SELECT NAME="charge" $onChange>
       $optionlist</SELECT>
   ~;

    print qq~
        <nobr>
	Xmin: <INPUT NAME="xmin" VALUE="$parameters{xmin}" SIZE="4" $onChange>
	Xmax: <INPUT NAME="xmax" VALUE="$parameters{xmax}" SIZE="4" $onChange>
	Ymax: <INPUT NAME="ymax" VALUE="$parameters{ymax}" SIZE="8" $onChange>
        <INPUT TYPE="submit" NAME="apply_action" VALUE="DISPLAY"/>
	<INPUT TYPE="submit" NAME="reset" VALUE="ZOOM OUT">
        <INPUT TYPE="submit" NAME="apply_action" VALUE="PRINTABLE FORMAT">
        </nobr>
    ~;

     print qq~
        <nobr>
	Frag m/z tol: <INPUT NAME="frag_mz_tol" VALUE="$parameters{frag_mz_tol}" SIZE="4" $onChange>
        </nobr>
     ~;

     print qq~
        <nobr>
	Ymin neut loss: <INPUT NAME="ymin_nl" VALUE="$parameters{ymin_nl}" SIZE="4" $onChange>
        </nobr>
     ~;

     #### Neutral loss selector
     $sql = "SELECT option_key,option_value FROM $TBAT_QUERY_OPTION " .
	    " WHERE option_type = 'neutral_loss_constraint' " .
	    " ORDER BY sort_order,option_value";
     my $optionlist = $sbeams->buildOptionList($sql,$parameters{'neutral_loss'});

     print qq~
	 Allowable neutral losses: <SELECT NAME="neutral_loss" $onChange>
	 $optionlist</SELECT>
     ~;



    #### Store the observed spectrum data as a recallable resultset
    my %dataset;
    $dataset{data_ref} = \@spectrum_array;
    $dataset{column_list_ref} = ['m/z','intensity'];
    my $rs_set_name = "SETME";
    $sbeams->writeResultSet(resultset_file_ref=>\$rs_set_name,
      resultset_ref=>\%dataset,
      file_prefix=>'spec_',
      query_parameters_ref=>\%parameters);


    #### Store the peptide data as a recallable resultset
    my %peptide_dataset;
    $peptide_dataset{data_ref} = \@theoretical_spectrum;
    $peptide_dataset{column_list_ref} = ['Residue','Index','Ion','Charge','m/z'];
    my $pep_rs_set_name = "SETME";
    $sbeams->writeResultSet(resultset_file_ref=>\$pep_rs_set_name,
      resultset_ref=>\%peptide_dataset,
      file_prefix=>'peptide_',
      query_parameters_ref=>\%parameters);

    #### Finish up the table and form
    print qq~<BR>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <BR>Download spectrum in Format: 
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$rs_set_name.tsv?rs_set_name=$rs_set_name&format=tsv">TSV</a>,
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$rs_set_name.xls?rs_set_name=$rs_set_name&format=excel">Excel</a>
        <BR>Download peptide data in Format: 
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$pep_rs_set_name.tsv?rs_set_name=$pep_rs_set_name&format=tsv">TSV</a>,
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$pep_rs_set_name.xls?rs_set_name=$pep_rs_set_name&format=excel">Excel</a>
        <BR>
	</TD>
	</TR>
	</TABLE>
        </FORM>
        <PRE>$buffer</PRE>
    ~;

    print &printUserAnnotations(
				spectrum_id => $parameters{'spectrum_id'},
				modified_sequence => $parameters{'modified_sequence'},
				charge => $parameters{'assumed_charge'},
				spectrum_identification_id => $parameters{'spectrum_identification_id'},
				form_fields => $hidden_form_fields
				) if ($parameters{'spectrum_identification_id'});

} # end printEntryForm


###############################################################################
# get_spectrum
###############################################################################
sub get_spectrum
{
  my %args = @_;

  my $spectrum_id = $args{'spectrum_id'};
  unless ($spectrum_id) {
    print "\nERROR: spectrum_id not passed.\n\n";
    return;
  }


  my $sql = qq~
    SELECT proteomics_search_batch_id,spectrum_name
      FROM $TBAT_SPECTRUM S
      JOIN $TBAT_SPECTRUM_IDENTIFICATION SI
           ON (S.spectrum_id = SI.spectrum_id )
      JOIN $TBAT_ATLAS_SEARCH_BATCH ASB
           ON (SI.atlas_search_batch_id = ASB.atlas_search_batch_id )
     WHERE S.spectrum_id = $spectrum_id
  ~;

  my @rows = $sbeams->selectSeveralColumns($sql);
  unless (@rows) {
    print "\nERROR: Unable to get search batch information for ".
      "spectrum_id '$spectrum_id'.\n\n";
    return;
  }
  my $search_batch_id = $rows[0]->[0];
  my $spectrum_name = $rows[0]->[1];
  my $fraction_tag;
  if ($spectrum_name =~ /^(.+)\.(\d+)\.(\d+)\.\d$/) {
    $fraction_tag = $1;
  } else {
    die("ERROR: Unable to parse fraction name from '$spectrum_name'");
  }

  #print "search_batch_id = $search_batch_id\n";
  #print "spectrum_name = $spectrum_name\n";
  #print "fraction_tag = $fraction_tag\n";


  use SBEAMS::PeptideAtlas::Spectrum;
  my $spectra = new SBEAMS::PeptideAtlas::Spectrum;
  $spectra->setSBEAMS($sbeams);

  my @mass_intensities = $spectra->getSpectrumPeaks(
    proteomics_search_batch_id => $search_batch_id,
    spectrum_name => $spectrum_name,
    fraction_tag => $fraction_tag,
  );


  #### If we still have no spectrum data, then bail out
  unless (@mass_intensities) {
    print "\nERROR: Unable to get m/z,intensity pairs for ".
      "spectrum_id '$spectrum_id'.\n\n";
    return;
  }

  #### Extract rows into two arrays of masses and intensities
  my (@masses,@intensities);
  for (my $i=0; $i<=$#mass_intensities; $i++) {
    push(@masses,$mass_intensities[$i]->[0]);
    push(@intensities,$mass_intensities[$i]->[1]);
  }

  my %spectrum;
  $spectrum{n_peaks} = $#mass_intensities + 1;


  #### Put data into hash and return
  $spectrum{masses} = \@masses;
  $spectrum{intensities} = \@intensities;

  return %spectrum;


}


###############################################################################
# InitializeMass -- returns reference to hash of amino acid mono-isotopic masses
###############################################################################
sub InitializeMass {
    my %AAmasses = (
    "G" => "57.02146",
    "A" => "71.03711",
    "S" => "87.02303",
    "P" => "97.05276",
    "V" => "99.06841",
    "T" => "101.04768",
    "C" => "103.00919",
    "L" => "113.08406",
    "I" => "113.08406",
    "N" => "114.04293",
    "D" => "115.02694",
    "Q" => "128.05858",
    "K" => "128.09496",
    "E" => "129.04259",
    "M" => "131.04049",
    "H" => "137.05891",
    "F" => "147.06841",
    "R" => "156.10111",
    "Y" => "163.06333",
    "W" => "186.07931",
    );

    return (\%AAmasses);
}

###############################################################################
# pg_setup
###############################################################################
sub pg_setup {
    my %args = @_;

    #### Default device is to screen (xserver)
    my $device = $args{'Device'} || "\/xs";
    #$device = "/xs";

    #### Plot title
    my $title = $args{'title'} || "";

    #### Default x limits are (0,2000)
    my $xmin = $args{'xmin'} || 0;
    my $xmax = $args{'xmax'} || 2000;

    #### Default y limits are (0,500000)
    my $ymin = $args{'ymin'} || 0;
    my $ymax = $args{'ymax'} || 500000;

    #### Default separation between ticks is 100000
    my $ytickdiv = $args{'ydiv'} || 100000;

    #### Default number of y ticks
    my $nyticks = ($args{'nyticks'}+1) || 4;

    #### Default image size is 640x480
    my $gifwidth = $args{'gifwidth'} || 640;
    my $gifheight = $args{'gifheight'} || 480;

    #### Set needed PGPLOT environment variables
    $ENV{"PGPLOT_GIF_WIDTH"} = $gifwidth;
    $ENV{"PGPLOT_GIF_HEIGHT"} = $gifheight;

    #### Try to set the proper location of rgb.txt
    if ($CONFIG_SETTING{PGPLOT_RGBTXT}) {
      $ENV{"PGPLOT_RGB"} = $CONFIG_SETTING{PGPLOT_RGBTXT};
    } elsif ( -e "/usr/share/X11/rgb.txt" ) {
      $ENV{"PGPLOT_RGB"} = "/usr/share/X11/rgb.txt";
    } else {
      $ENV{"PGPLOT_RGB"} = "/usr/X11R6/lib/X11/rgb.txt";
    }

    $ENV{"PGPLOT_FONT"} = $CONFIG_SETTING{PGPLOT_FONT} ||
      "/usr/local/lib/grfont.dat";
    $ENV{"PGPLOT_BACKGROUND"} = "white";

    #### Create a new graphics device
    #### WARNING: If the device is a filename, it apparently gets
    #### truncated at 80 characters!!!
    my $win = PDL::Graphics::PGPLOT::Window -> new({Device => "$device"});

    #### Set window limits
    pgswin $xmin, $xmax, 0, $ymax;

    #### Set viewport limits
    pgsvp .095,.9775,.065,.95;

    #### Set axis color to black (stealing lt. gray color)
    pgscr 15, 0,0,0;

    #### Set color index
    pgsci 15;

    #### Set character height
    pgsch 0.9;

    #### Set line width
    pgslw 1;

    #### Set character font (Normal)
    pgscf 1;

    #### Draw labeled frame around viewport: full frame (BC), labels on
    #### bottom and left of frame (N), major tick marks (T), y labels
    #### normal to y-axis (V), decimal labels instead of scientific
    #### notation (1), automatic x major ticks, $ytickdiv between y ticks,
    #### with $nyticks major divisions.
    pgbox 'BCNT',0,0,'BCNTV1',$ytickdiv,$nyticks;

    #### Reset character height (make labels larger)
    pgsch 1;

    #### Y label on left, centered vertically along axis
    pgmtxt 'L',3.8,.5,.5,'Intensity';

    #### X label on bottom, centered vertically along axis
    pgmtxt 'B',2.25,.5,.5,'m/z';

    #### Main title above, centered vertically along top
    pgmtxt 'T',1,.5,.5,"$title";

    #### Reset character height (want in-plot labels small)
    pgsch .8;

    #### Allow overplotting of this frame
    $win -> hold;

    return $win;
}

###############################################################################
# PlotPeaksOld   DEPRECATED; remove by June 2011
#  called once for each possible charge
###############################################################################
sub PlotPeaksOld {
    my %args = @_;

    #### Spectrum data to be plotted
    my $specdata = $args{'SpecData'};

    #### Ions to be plotted
    my $mzlist_ref = $args{'MZlist'};

    #### Charge
    my $charge = $args{'Charge'};

    #### Plot frame
    my $win = $args{'Win'};

    #### Peak Colors
    my $peakcolors_ref = $args{'PeakColors'};

    #### Peak finding window. An arg isn't currently passed, so
    ####  default value 2 is used.
    my $window = $args{'Window'} || 2;

    #### Number of residues in matched peptide
    my $length = $args{'Length'};
    #### Intensity of tallest peak (if any) close to each ion's m/z.
    my @Bmaxinten = (0) x $length;
    my @Ymaxinten = (0) x $length;

    # Lists of peak masses. Each peak belongs to one list.
    my @Bmass;
    my @Ymass;
    my @BYmass;
    my @Rmass;				# R stands for "other"

    # Lists of peak intensities. Each peak belongs to one list.
    my @Binten;
    my @Yinten;
    my @BYinten;
    my @Rinten;
    #my @Rinten = (0) x $specdata->{n_peaks};


    # Draw +1 peaks a darker color
    my ($redcol,$bluecol,$grcol);

    if ($charge == 1) {
      $redcol = $red;
      $bluecol = $blue;
      $grcol = $green;
    } else {
      $redcol = $pink;
      $bluecol = $navy;
      $grcol = $lt_green;
    }

    #### Convert lists of m/z values to piddle for easy sub-selecting
    #### These are lists of length $length of expected m/z values for
    ####  each predicted ion.
    my $bdata = pdl $mzlist_ref->{Bions};
    my $ydata = pdl $mzlist_ref->{Yions};

    #### Draw peaks
    my $i;
    my $lineclr;
    my ($mass, $intensity);

    # For each actual peak in the spectrum ...
    for ($i=0; $i<$specdata->{n_peaks}; $i++) {

      ### Get the mass and intensity for this peak
      $mass = $specdata->{masses}->[$i];
      $intensity = $specdata->{intensities}->[$i];

      #### Set default color for drawing peak to any color that's already
      #### been assigned to this peak when processing a diff. charge,
      #### otherwise black.
      $lineclr = $peakcolors_ref->[$i] || $black;

      ### Bind and Yind each contain the index into $bdata/$ydata
      ###  for any value within a small window around the current peak,
      ###  else 'Empty' if no value in that window.
      my $Bind = which($bdata >= ($mass-$window) & $bdata <= ($mass+$window));
      my $Yind = which($ydata >= ($mass-$window) & $ydata <= ($mass+$window));
      my $watermz = 18.015/$charge;

      my $b = $Bind->at(0) if ($Bind !~ 'Empty');
      my $y = $Yind->at(0) if ($Yind !~ 'Empty');

      #### Figure out how to label this peak, if at all.

      #### If there are just B fragments with m/z near enough this peak ...
      ####   Don't label/colorize peaks for "fragments"
      ####   corresponding to entire peptide ($b = $length-1 or $y=0)
      if (($Bind !~ 'Empty') && ($b != $length-1) &&
         (($Yind =~ 'Empty') || ($y == 0))) {
        $lineclr = $redcol;
        # store the mass and intensity of this peak on a list for B-ions
        push(@Binten,$intensity);
        push(@Bmass,$mass);
        # Record that this peak has been identified
        $specdata->{identified}->[$i] = 1;
        # If this is the first or tallest peak close to the m/z for
        # this ion, store intensity to be used as label height. Store label
        # color if one has not yet been stored (why would a diff one
        # have already been stored?)
        if ($Bmaxinten[$b] < $intensity) {
          $Bmaxinten[$b] = $intensity;
          # Save color to use for printing chart of predicted m/z values
          $mzlist_ref->{Bcolor}->[$b] = $lineclr
            unless ($mzlist_ref->{Bcolor}->[$b]);
        }

      #### Else if there are just Y fragments with m/z near enough this peak
      } elsif (($Yind !~ 'Empty') && ($y != 0) &&
	      (($Bind =~ 'Empty') || ($b == $length-1))) {
        $lineclr = $bluecol;
        push(@Yinten,$intensity);
        push(@Ymass,$mass);
        $specdata->{identified}->[$i] = 1;
        if ($Ymaxinten[$y] < $intensity) {
          $Ymaxinten[$y] = $intensity;
          $mzlist_ref->{Ycolor}->[$y] = $lineclr;
        }

      #### Else if both B and Y fragments with m/z near enough this peak
      } elsif (($Bind !~ 'Empty') && ($Yind !~ 'Empty')) {
        $lineclr = $grcol;
        push(@BYinten,$intensity);
        push(@BYmass,$mass);
        $specdata->{identified}->[$i] = 1;
        if ($Ymaxinten[$y] < $intensity) {
          $Ymaxinten[$y] = $intensity;
          $mzlist_ref->{Ycolor}->[$y] = $lineclr;
        }
        if ($Bmaxinten[$b] < $intensity) {
          $Bmaxinten[$b] = $intensity;
          $mzlist_ref->{Bcolor}->[$b] = $lineclr;
        }

      #### else if there is no fragment with m/z near enough this peak,
      #### even from a previously processed charge
      } else {
        # if a color hasn't already been assigned to this peak
        if (($peakcolors_ref->[$i] != $red) &
            ($peakcolors_ref->[$i] != $green) &
            ($peakcolors_ref->[$i] != $blue) &
            ($peakcolors_ref->[$i] != $pink) &
            ($peakcolors_ref->[$i] != $lt_green) &
            ($peakcolors_ref->[$i] != $navy)) {
          #$Rinten[$i] = $intensity
          push(@Rinten,$intensity);
          push(@Rmass,$mass);
        }

      }

      $peakcolors_ref->[$i] = $lineclr;
    }

    my ($mass2, $intensity2);
    $mass2 = $specdata->{masses};
    $intensity2 = $specdata->{intensities};

    #### Now we resort to plotting all peaks by "never lifting the pen"
    #### and drawing it all in a continuous line with line() because this
    #### is much faster
    my $rx = pdl (\@Rmass,\@Rmass,\@Rmass)->xchg(0,1)->clump(2);
    #my $rx = pdl ($mass2,$mass2,$mass2)->xchg(0,1)->clump(2);
    my $ra = [(0) x scalar(@Rinten)];
    my $ry = pdl ($ra,\@Rinten,$ra)->xchg(0,1)->clump(2);
    my $rh = {Color => $black};
    $win -> line ($rx,$ry,$rh);

    my $bx = pdl (\@Bmass,\@Bmass,\@Bmass)->xchg(0,1)->clump(2);
    my $ba = [(0) x scalar(@Binten)];
    my $by = pdl ($ba,\@Binten,$ba)->xchg(0,1)->clump(2);
    my $bh = {Color => $redcol};
    $win -> line ($bx,$by,$bh);

    my $yx = pdl (\@Ymass,\@Ymass,\@Ymass)->xchg(0,1)->clump(2);
    my $ya = [(0) x scalar(@Yinten)];
    my $yy = pdl ($ya,\@Yinten,$ya)->xchg(0,1)->clump(2);
    my $yh = {Color => $bluecol};
    $win -> line ($yx,$yy,$yh);

    my $byx = pdl (\@BYmass,\@BYmass,\@BYmass)->xchg(0,1)->clump(2);
    my $bya = [(0) x scalar(@BYinten)];
    my $byy = pdl ($bya,\@BYinten,$bya)->xchg(0,1)->clump(2);
    my $byh = {Color => $grcol};
    $win -> line ($byx,$byy,$byh);

    $mzlist_ref->{Binten} = \@Bmaxinten;
    $mzlist_ref->{Yinten} = \@Ymaxinten;
    return ($win);
}


###############################################################################
# LabelResiduesOld   DEPRECATED; remove by June 2011
###############################################################################
sub LabelResiduesOld {
    my %args = @_;

    my $Ionmasses_ref = $args{'Ionmasses'};    # mzlist_ref in main pgm
    my $Bdata = pdl $Ionmasses_ref->{Bions};   # predicted m/z for ions
    my $Ydata = pdl $Ionmasses_ref->{Yions};   #   of this charge
    my $charge = $args{'Charge'};              # charge being considered
    my $win = $args{'Win'};                    # plot window

    # Binten, Yinten, etc. are max peak heights within +/- 2 of
    # predicted m/z of ions
    my $Binten_ref = $args{'Binten'};
    my @Binten = @$Binten_ref;
    my $Yinten_ref = $args{'Yinten'};
    my @Yinten = @$Yinten_ref;

    my $length = $args{'Length'};          # number residues in pep
    my $labht;                             # height of ion label in plot
    my $angle = $args{'Angle'} || 0;       # angle to plot label
    my $fjust = $args{'Fjust'};
    my ($Bcol,$Ycol,$bothcol);             # colors for different peaks
    my $i;
    my ($lineclr,$redcol,$bluecol,$grcol); # colors
    my $Ymax = $args{'Ymax'};              # max value on Y-axis
    my $Xmin = $args{'Xmin'};              # min value on X-axis
    my $Xmax = $args{'Xmax'};              # max value on X-axis
    my $interval = $Ymax / 50.0;           # 2% of Y-axis height, in intensity
    my $xshift = ($Xmax - $Xmin) / 200.0;  # 0.5% of X-axis width, in mz

    # Use brighter colors for drawing charge +1
    if ($charge == 1) {
      $redcol = $red;
      $bluecol = $blue;
      $grcol = $green;
    } else {
      $redcol = $pink;
      $bluecol = $navy;
      $grcol = $lt_green;
    }

    # For each residue in the peptide ...
    for ($i=0; $i < $length; $i++) {
      # If there is a peak here that is identified as a B-ion ...
      if (($Binten[$i] != 0) && ($i != ($length-1))) {
        my $val = $Ionmasses_ref->{indices}->[$i];
        ++$val;                         # which B-ion is this?
        my $index = "B$val\^$charge";   # text for label
        my $mass = $Bdata->at($i);      # predicted m/z for this ion
        # X-coords for endpoints of ion marker line
        my $matchx = pdl [$mass, $mass];
        my $y = $Binten[$i];            # max height of peaks +/- 2 of $mass
        # Y-coords for endpoints of marker line. Place just above
        # tallest peak within +/- 2 of predicted m/z for ion.
        my $matchy = pdl [$y+($interval/3.), $y+4*($interval/3.)];
        # 
        my $Yind = which($Ydata >= ($mass-2) & $Ydata <= ($mass+2));
        if ($Yind !~ 'Empty') {
          #### Green text and line for both ion match
          pgsci $grcol;
          $lineclr = $grcol;

          #### Location of label above tick mark (moved up)
          $labht = $y+8.5*($interval/3.);
        } else {
          #### Red text and line for B ion match
          pgsci $redcol;
          $lineclr = $redcol;

          #### Location of label above tick mark
          $labht = $y+5*($interval/3.);
        }
        #### Plot ion marker line
#        $win -> line($matchx, $matchy, {Color=>$lineclr});
#        $win -> hold;

        #### Add ion label
#       pgptext $mass+$xshift,$labht,$angle,$fjust,"$index"
#         if (($labht < $Ymax) && ($mass > $Xmin) && ($mass < $Xmax));
      }


      # If there is a peak here that is identified as a Y-ion ...
      if (($Yinten[$i] != 0) && ($i != 0)) {
        my $index = "Y$Ionmasses_ref->{rev_indices}->[$i]\^$charge";
        my $mass = $Ydata->at($i);
        my $matchx = pdl [$mass, $mass];
        my $y = $Yinten[$i];
        my $matchy = pdl [$y+($interval/3.), $y+4*($interval/3.)];
        my $Bind = which($Bdata >= ($mass-2) & $Bdata <= ($mass+2));
        if ($Bind !~ 'Empty') {
          #### Green text and line for both ion match
          pgsci $grcol;
          $lineclr = $grcol;

          #### Location of label above tick mark
          $labht = $y+5*($interval/3.);
        } else {
          #### Blue text and line for Y ion match
          pgsci $bluecol;
          $lineclr = $bluecol;

          #### Location of label above tick mark
          $labht = $y+5*($interval/3.);
        }
        #### Plot ion marker line
#        $win -> line($matchx, $matchy, {Color=>$lineclr});
#        $win -> hold;

        #### Add ion label
#        pgptext $mass+$xshift,$labht,$angle,$fjust,"$index"
#          if (($labht < $Ymax) && ($mass > $Xmin) && ($mass < $Xmax));
      }
    }

    return $win;
}

###############################################################################
# LabelUnidentifiedPeaksOld
###############################################################################
sub LabelUnidentifiedPeaksOld {
    my %args = @_;

    my $win = $args{'Win'};
    my $specdata = $args{'SpecData'};
    my $mz_threshold_factor = $args{'MZ_threshold'} || 0.1;

    my $labht;
    my $angle = $args{'Angle'} || 0;
    my $fjust = $args{'Fjust'};
    my $i;
    my $lineclr;
    my $Ymax = $args{'Ymax'};
    my $Xmin = $args{'Xmin'};
    my $Xmax = $args{'Xmax'};
    my $interval = $Ymax / 50.0;
    my $xshift = ($Xmax - $Xmin) / 200.0;

    my $mz_intens_threshold = $Ymax*$mz_threshold_factor;

    # For each unidentified peak above threshold intensity ...
    # (or far from any other peak)
    for (my $i = 0; $i < $specdata->{n_peaks}; $i ++) {
      # is this peak close to any other peaks?
      my $mass = $specdata->{masses}->[$i];
      my $prev_mz = $Xmin;
      my $next_mz = $Xmax;
      my $too_close;
      $prev_mz = $specdata->{masses}->[$i-1] if ($i > 0);
      $next_mz = $specdata->{masses}->[$i+1]
                      if ($i < $specdata->{n_peaks}-1);
      my $breathing_room = $xshift * 6.0;
      $too_close = (($mass - $prev_mz < $breathing_room) ||
                    ($next_mz - $mass < $breathing_room));

      my $y = $specdata->{intensities}->[$i];
      if (((! defined $specdata->{identified}->[$i]) ||
          ($specdata->{identified}->[$i] != 1 )) &&
          (($y > $mz_intens_threshold) || ! $too_close )) {
        my $label = sprintf ("%0.1f", $mass);
        my $matchx = pdl [$mass, $mass];
        my $y = $specdata->{intensities}->[$i];
        my $matchy = pdl [$y+($interval/3.), $y+4*($interval/3.)];
	pgsci $black;
	$lineclr = $black;
	#### Location of label above tick mark
	$labht = $y+5*($interval/3.);
        #### Plot marker line
        $win -> line($matchx, $matchy, {Color=>$lineclr});
        $win -> hold;
        #### Add m/z label
        pgptext $mass+$xshift,$labht,$angle,$fjust,"$label"
          if (($labht < $Ymax) && ($mass > $Xmin) && ($mass < $Xmax));
      }
    }
    return $win;
}

###############################################################################
# LabelUnidentifiedPeaks
###############################################################################
sub LabelUnidentifiedPeaks {
  my %args = @_;

  my $fragments_aref = $args{'Fragments'};
  my @fragments = @$fragments_aref;
  my $ymin_nl = $args{'YminNL'};

  for my $fragment_href (@fragments) {
    if ( ($fragment_href->{label_text} eq '') &&
         ($fragment_href->{intensity} >= $ymin_nl)) {
      my $mz = sprintf ("%0.1f", $fragment_href->{mz});
      print "mz = $mz<br>";
      $fragment_href->{label_text} = $mz;
    }
  }
}

###############################################################################
# Fragment
###############################################################################
sub Fragment {
    my $peptide = shift;
    my $length = length($peptide);
    my @residues = ();
    my $i;

    for ($i=0; $i<$length; $i++) {
      if (substr($peptide,$i+1,1) eq '[') {
        push (@residues, substr($peptide,$i,6));
        $i = $i + 5;
      } elsif (substr($peptide,$i+1,1) =~ /\W/) {
        push (@residues, substr($peptide,$i,2));
        $i = $i + 1;
      } else {
        push (@residues, substr($peptide,$i,1));
      }
    }

    #### Return residue array
    return @residues;
}

###############################################################################
# CalcIonsOld  -- DEPRECATED. Remove by June 2011. Superceded by
#                  getAllPossibleFragments.
#  given a charge and a peptide, compute the predicted B and Y ion masses
###############################################################################
sub CalcIonsOld {
    my %args = @_;

    my $residues_ref = $args{'Residues'};
    my @residues = @$residues_ref;
    my $charge = $args{'Charge'} || 1;
    my $massarray_ref = $args{'AAmasses'};
    my $mzlist_ref = $args{'mzlist_ref'};
    my %massarray = %$massarray_ref;
    my $length = scalar(@residues);
    my @modified_residues;

    my $Nterm = 1.0078;
    my $Yterm  = 19.0184;  ## H_2 + O
    my $Bion = 0.;
    my $Yion  = $Yterm;

    my @Bcolor = (14) x $length;
    my @Ycolor = (14) x $length;

    my $start = 0;
    my $i;

    #### If we start with a custom N-terminal mass, such as n[43]A
    ####  Bug fixed here TMF 10/12/10
    if ($residues[0] =~ /n\[(\d+)\](\w)/) {
      #$start = 1;
      my $massTag = $residues[0];
      my $integerMass = $1;
      # initialize $Bion to this N-terminal mass
      if ($massCalculator->{supported_modifications}->{average}->{$massTag}) {
	$Bion += $massCalculator->{supported_modifications}->{average}->{$massTag};
      } else {
	$Bion = $integerMass;
      }
      #$length--;
      # Strip the n[xx] from the string for this residue
      $residues[0] = $2;
    }

    my @masses;

    ### For each amino acid residue ...
    for ($i=0; $i<$length; $i++) {

      ### get the mass
      my $massTag = $residues[$i+$start];
      my $mass = $massarray{$massTag};
      unless ($mass) {
	if ($residues[$i+$start] =~ /\w\[(\d+)\]/) {
	  my $integerMass = $1;
	  if ($massCalculator->{supported_modifications}->{average}->{$massTag}) {
	    $mass = $massarray{substr($massTag,0,1)};
	    $mass += $massCalculator->{supported_modifications}->{average}->{$massTag};
	  } else {
	    $mass = $integerMass;
	  }
	} else {
	  print "WARNING: Unable to find mass for residues[$i]<BR>\n";
	}
      }

      ### ... and store it in an array
      $masses[$i] = $mass;
      $modified_residues[$i] = $massTag;
      $Yion += $mass;
    }

    ### Now, $Yion is the sum of all the masses, plus water, and $Bion
    ### is zero (or mass of N-terminal modification).
    my %mzlist=%{$mzlist_ref};
    my (@aminoacids, @indices, @rev_indices, @Bions, @Yions);

    #### Compute the ion masses. March down the peptide and get the B
    #### and Y ion masses.
    for ($i=0; $i<$length; $i++) {

      #### Get the Bion and Yion masses by adjusting the previous values
      $Bion += $masses[$i];
      $Yion -= $masses[$i-1] if ($i > 0);

      #### B index & Y index
      $indices[$i] = $i;
      $rev_indices[$i] = $length-$i;

      #### Store the B ion m/z & Y ion m/z (NOT mass) in an array
      $mzlist{Bions}->[$i]->[$charge] = ($Bion + $charge*$Nterm)/$charge;
      $mzlist{Yions}->[$i]->[$charge] = ($Yion + $charge*0.0)/$charge;
    }

    $mzlist{residues} = \@modified_residues; #array of one-letter
        #amino acid code plus a mass mod in brackets (?)
    $mzlist{indices} = \@indices;  # simply 1 through length
    $mzlist{Bions} = \@Bions;  #m/z values
    $mzlist{Yions} = \@Yions;  #m/z values
    $mzlist{rev_indices} = \@rev_indices;  #simply the reverse of indices
    $mzlist{length} = $length; #peptide length

    #### Return reference to a hash of array references
    return (\%mzlist);
}

###############################################################################
# printIons
###############################################################################
sub printIons {
  my %args = @_;

  my $mzlist_ref = $args{'mzlist_ref'};
  my $color = $args{'color'} || 0;
  my $html = $args{'html'} || 0;
  my $charge = $args{'charge'};
  my $length = $args{'length'};
  my $theoretical_spectrum_ref = $args{'theoretical_spectrum_ref'};

  my $buffer = '';

  $buffer .= "Residue  ion     B       Y      ion   +$charge\n";
  $buffer .= "------  -----  ------  ------  -----\n";

  my ($bcolbegin, $bcolend, $ycolbegin, $ycolend);

  #### Define HTML colors that correspond to those we used for plotting
  my %colors;
  $colors{$red} = "#FF0000";
  $colors{$blue} = "#0000FF";
  $colors{$green} = "#218D21";
  $colors{$pink} = "#F18080";
  $colors{$navy} = "#00088";
  $colors{$lt_green} = "#8FBE8F";


  #### Printing stuff
  for (my $i=0; $i < $length; $i++) {

    #### If the output is in HTML, define the colorizing tags
    if ($html) {

      #### If a color for this B ion mass, set color tags
      if ($mzlist_ref->{Bcolor}->[$i] >= $min_color_code) {
        $bcolbegin = "<FONT COLOR = $colors{$mzlist_ref->{Bcolor}->[$i]}>";
        $bcolend = "</FONT>";
      #### else no color (default black)
      } else {
        $bcolbegin = "";
        $bcolend = "";
      }

      #### If a color for this Y ion mass, set color tags
      if ($mzlist_ref->{Ycolor}->[$i] >= $min_color_code) {
        $ycolbegin = "<FONT COLOR = $colors{$mzlist_ref->{Ycolor}->[$i]}>";
        $ycolend = "</FONT>";
      #### else no color (default black)
      } else {
        $ycolbegin = "";
        $ycolend = "";
      }

    }


    #### Define the m/z columns formats and values
    my $B_format = '%7.1f';
    my $Y_format = '%7.1f';
    my $B_value = $mzlist_ref->{Bions}->[$i];
    my $Y_value = $mzlist_ref->{Yions}->[$i];


    #### Special case --'s for first row
    if ($i == 0) {
      $Y_format = '%7s';
      $Y_value = '--  ';

    #### Special case --'s for last row
    } elsif ($i == ($length-1)) {
      $B_format = '%7s';
      $B_value = '--  ';
    }

    #### Print out the data
    $buffer .= sprintf("%6s  %5s $bcolbegin$B_format$bcolend ".
      "$ycolbegin$Y_format$ycolend  %5s\n",
      $mzlist_ref->{residues}->[$i], "B".($i+1)."\^$charge",
      $B_value, $Y_value, "Y".($length-$i)."\^$charge");

    #### Fill the theoretical spectrum data in a different format
    #### (Residue,Index,Ion,Charge,m/z)
    $theoretical_spectrum_ref->[2*$length*($charge-1)+$i] =
      [$mzlist_ref->{residues}->[$i],$i+1,'B',$charge,$B_value];
    $theoretical_spectrum_ref->[2*$length*($charge-1)+2*$length-1-$i] =
      [$mzlist_ref->{residues}->[$i],$length-$i,'Y',
      $charge,$Y_value];


  } # end for

  $buffer .= "\n";

  return $buffer;

} # end printIons


###############################################################################
# printUserAnnotations
# get and display user annotations, if any
###############################################################################
sub printUserAnnotations {
    my %args = @_;

    my $buffer;
    my $total = 0; # this starts as a counter, then becomes a string
    my $show_form = 1;
    my $line_sep = "<tr><td colspan='2'><hr size='1' noshade></td></tr>";

    my $sql = qq~
	SELECT SA.spectrum_annotation_id, SA.comment, SA.date_modified,
	       SA.spectrum_identification_id, SA.identified_peptide_sequence, SA.identified_peptide_charge,
	       SL.spectrum_annotation_level_id, SL.level_name,
	       C.first_name, C.last_name,
	       UL.username
	  FROM $TBAT_SPECTRUM_ANNOTATION SA
    INNER JOIN $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
            ON ( SA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
    INNER JOIN $TB_CONTACT C
            ON ( annotator_contact_id = C.contact_id )
    INNER JOIN $TB_USER_LOGIN UL
            ON ( UL.contact_id = annotator_contact_id )
	 WHERE spectrum_id = '$args{spectrum_id}'
	   AND SA.record_status = 'N'
      ORDER BY SA.date_modified DESC
        ~;

    my @rows = $sbeams->selectSeveralColumns($sql);

    $buffer = qq~
	<table width="100%" class="table_setup">
	<tr class="orange_bg"><th>User annotations</th><td><a name="user_annotations">&nbsp;</a></td></tr>
	~;

    if (@rows) {
	foreach my $row (@rows)
	{
	    my ($annot_id, $comment, $date, $ident_id, $sequence, $charge, $level_id, $level, $first, $last, $uname) = @{$row};
	    $total++;

	    if ($args{modified_sequence}.$args{charge} eq $sequence.$charge) {
		$buffer .= "<tr id='${uname}${annot_id}_annot_tr'><th valign='top'>$level</th><td>$first $last ($date)<br />\n";
	    } else {
		my $link = $q->self_url();
		$link =~ s/\?.*//;  # clear querystring
		$link .= "?spectrum_identification_id=$ident_id;peptide=$sequence;assumed_charge=$charge";

		$buffer .= "<tr bgcolor='#dddddd' id='${uname}${annot_id}_annot_tr'><th valign='top'>$level<br /><a href='$link' style='color:red'>$sequence +$charge</a></th><td>$first $last ($date)<br />\n";
	    }

	    my $disp_comment = $comment;
	    $disp_comment =~ s|\n|<BR />\n|g; # display carriage returns
	    $buffer .= "$disp_comment\n";

	    if ( ($uname eq $current_username) &&
		 ($args{modified_sequence}.$args{charge} eq $sequence.$charge) ) {
		$show_form = 0;

		$buffer .= qq~
		    <br /><div align='right'><a href='javascript:showEditForm();'>Edit my annotation</a> | <a href='javascript:confirm_delete();'>Delete</a>
		    <FORM NAME="delete_annotation" METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
		    $args{form_fields}
		    <INPUT TYPE='hidden' NAME='spectrum_annotation_id' VALUE='$annot_id'>
   		    <INPUT TYPE='hidden' NAME='apply_action' VALUE='DELETE ANNOTATION'></FORM>
		    </div>
		    ~;

		$buffer .= "</td></tr>\n";

		$buffer .= &printUserAnnotationsForm(
						     form_type => 'update',
						     uname => $uname,
						     default_level_id => $level_id,
						     default_comment => $comment,
						     annot_id => $annot_id,
						     extra_form_fields => $args{form_fields}
						     );
	    }

	    $buffer .= "</td></tr>\n$line_sep\n";
	}

    } else {
	$buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td class='section_heading'>There are no user annotations for this spectrum<br /></td></tr>
	    $line_sep
	    ~;
    }


    if ($current_username eq 'guest') {
	my $url = $q->self_url();
	$url .= '&force_login=yes';

	$buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td><a href='$url'>Log into PeptideAtlas</a> to add an annotation for this spectrum<br /></td></tr>
	    $line_sep
	    ~;

    } elsif ($show_form) {
	$buffer .= "<tr id='${current_username}add_annot_tr'><th valign='top'><a href='javascript:showEditForm();'>Add annotation</a></th><td>&nbsp;</td></tr>\n";

	$buffer .= &printUserAnnotationsForm(
					     form_type => 'add',
					     uname => $current_username,
					     spectrum_id => $args{spectrum_id},
					     extra_form_fields => $args{form_fields}
					     );

	$buffer .= "</td></tr>\n$line_sep\n";
    }

    $buffer .= "</table>\n";

    # get average
    $sql = qq~
 	SELECT ROUND(AVG(SL.level_probability)*100,0) AS avg_prob_pct,
	       COUNT(*)
	  FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
    INNER JOIN $TBAT_SPECTRUM_ANNOTATION SA
            ON ( SA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
	 WHERE spectrum_id = '$args{spectrum_id}'
	   AND identified_peptide_sequence = '$args{modified_sequence}'
	   AND identified_peptide_charge = '$args{charge}'
	   AND SA.record_status = 'N'
        ~;

    @rows = $sbeams->selectSeveralColumns($sql);

    my ($avg, $num) = @{$rows[0]};
    if ($total != $num) {
	$total = "($total total)";
    } else {
	$total = '';
    }

    my $innerHTML;

    if ($num == 1) {
	$innerHTML = "There is <a href=\"#user_annotations\">one user annotation</a> $total for this spectrum, with a score of <b>$avg%</b>";
    } elsif ($num > 1) {
	$innerHTML = "There are <a href=\"#user_annotations\">$num user annotations</a> $total for this spectrum, with an average score of <b>$avg%</b>";
    }

    $buffer .=<< "EOJS" if $innerHTML;
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
    document.getElementById("annotations_summary").innerHTML = '$innerHTML';
    document.getElementById("annotations_head").style.display = 'table-row';
</SCRIPT>
EOJS

    return $buffer;
}


###############################################################################
# printUserAnnotationsForm
# get and display user annotations, if any
###############################################################################
sub printUserAnnotationsForm {
    my %args = @_;

    $args{form_type} ||= 'add';
    $args{uname} ||= 'user_anon';
    $args{default_level_id} ||= 0;
    $args{default_comment} ||= '';
    $args{annot_id} ||= 0;
    $args{extra_form_fields} ||= '';

    my $spacer = "&nbsp;"x5;

    my $trname = $args{uname};
    $trname .= ($args{form_type} eq 'add') ? 'add' : $args{annot_id};

    my $buffer = qq~
	<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
	<!--
	function showEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'none';
	    document.getElementById('${trname}_form_tr').style.display = 'table-row';
	}
        function hideEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'table-row';
	    document.getElementById('${trname}_form_tr').style.display = 'none';
	}

        function confirm_delete() {
	    var del = confirm("Are you sure you want to delete your comment?");
	    if (del==true) {
		document.delete_annotation.submit();
	    }
	}
        // -->
	</SCRIPT>
	~;

    # add a hidden <tr> for edit form
    my $sql = qq~
	SELECT spectrum_annotation_level_id, level_probability, level_name, level_description
	FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL
	WHERE record_status = 'N'
	ORDER BY sort_order
	~;

    my @levels = $sbeams->selectSeveralColumns($sql);

    my $select = "<SELECT NAME='user_spectrum_annotation'>\n";
    foreach my $levrow (@levels)
    {
	my ($lev_id, $lev_prob, $lev_name, $lev_desc) = @{$levrow};

	my $sel = ( "$args{default_level_id}" eq "$lev_id" ) ? 'SELECTED' : '';
	my $desc = $sbeams->escapeXML(value => $lev_desc);

	$select .= "<OPTION TITLE='$desc' VALUE='$lev_id' $sel>$lev_name</OPTION>\n";
    }
    $select .= "</SELECT>";

    my $form_action = "ADD";
    if ($args{form_type} eq 'update') {
	$form_action = "UPDATE";
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='spectrum_annotation_id' VALUE='$args{annot_id}'>";

    } else {
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='spectrum_id' VALUE='$args{spectrum_id}'>";
    }

    $buffer .= qq~
	<tr style='display:none' id='${trname}_form_tr'>
	<th valign='top'>
	<FORM METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
	$args{extra_form_fields}
	$select</th>
	<td><TEXTAREA ROWS='6' COLS='80' NAME='user_spectrum_commment'>$args{default_comment}</TEXTAREA><br />
	<div align='right'><INPUT TYPE='submit' NAME='apply_action' VALUE='$form_action ANNOTATION'>$spacer<a class='small_form_field' href='javascript:hideEditForm();'>CANCEL</a></div>
	~;

    # caller will close the td and tr
    return $buffer;

}

###############################################################################
# defineColors
###############################################################################
sub defineColors {

    #### Define colors for +1 peaks
    pgscr $red,1,0,0;                      # B ions
    pgscr $blue,0,0,1;                     # Y ions
    pgscr $green,0.13,0.55,0.13;           # B+Y ions near same m/z

    #### Define colors for +2, +3 peaks
    pgscr $pink,0.94,0.5,0.5;               # B ions; lightcoral
    pgscr $navy,0,0,.5;                     # Y ions; navy
    pgscr $lt_green,0.56,0.74,0.56;         # B+Y near same m/z; DarkSeaGreen
}

###############################################################################
# getAllPossibleFragments
#  Generate a complete list of possible fragments including neutral
#  losses, each with mz, type, label_text, label_y, and marker_y
###############################################################################
sub getAllPossibleFragments {
  my %args = @_;

  my $residues_aref = $args{'Residues'};
  my @residues = @$residues_aref;
  my $length = scalar(@residues);
  my $charges_aref = $args{'Charges'};
  my @charges = @$charges_aref;
  my $massarray_href = $args{'AAmasses'};
  my %massarray = %$massarray_href;
  my $mzlist_href = $args{'MassList'};
  my $precursor_charge = $args{'precursor_charge'};

  my @modified_residues;
  my $fragments_aref = [];

  my $Nterm = 1.0078;
  my $Yterm  = 19.0184;  ## H_2 + O
  my $Bion_mass = 0.;
  my $Yion_mass  = $Yterm;

  my @Bcolor = (14) x $length;
  my @Ycolor = (14) x $length;

  my $start = 0;
  my $i;

  #### If we start with a custom N-terminal mass, such as n[43]A
  ####  Bug fixed here TMF 10/12/10
  if ($residues[0] =~ /n\[(\d+)\](\w)/) {
    my $massTag = $residues[0];
    my $integerMass = $1;
    # initialze $Bion_mass to this N-terminal mass
    if ($massCalculator->{supported_modifications}->{average}->{$massTag}) {
      $Bion_mass += $massCalculator->{supported_modifications}->{average}->{$massTag};
    } else {
      $Bion_mass = $integerMass;
    }
    #$length--;
    # Strip the n[xx] from the string for this residue
    $residues[0] = $2;
  }

  my @masses;

  ### For each amino acid residue ...
  for ($i=0; $i<$length; $i++) {

    ### get the mass
    my $massTag = $residues[$i+$start];
    my $mass = $massarray{$massTag};
    unless ($mass) {
      if ($residues[$i+$start] =~ /\w\[(\d+)\]/) {
	my $integerMass = $1;
	if ($massCalculator->{supported_modifications}->{average}->{$massTag}) {
	  $mass = $massarray{substr($massTag,0,1)};
	  $mass +=
            $massCalculator->{supported_modifications}->{average}->{$massTag};
	} else {
	  $mass = $integerMass;
	}
      } else {
	print "WARNING: Unable to find mass for residues[$i]<BR>\n";
      }
    }

    ### ... and store it in an array
    $masses[$i] = $mass;
    $modified_residues[$i] = $massTag;
    $Yion_mass += $mass;
  }

  ### Now, $Yion_mass is the sum of all the masses, plus water, and $Bion_mass
  ### is zero (or mass of N-terminal modification).
  my (@aminoacids, @indices, @rev_indices);
  my (@Bions, @Yions);

  #### Compute the ion masses. March down the peptide and get the B
  #### and Y ion masses.
  for ($i=0; $i<$length; $i++) {

    #### Get the Bion and Yion masses by adjusting the previous values
    $Bion_mass += $masses[$i];
    $Yion_mass -= $masses[$i-1] if ($i > 0);

    #### B index & Y index
    $indices[$i] = $i+1;
    $rev_indices[$i] = $length-$i;


    for my $charge (@charges) {
      for my $nl_mass (0, @neutral_loss_masses) {

        my $integer_nl_mass = int($nl_mass);
        my $nl_string = "-$integer_nl_mass";
        $nl_string = "" if ($nl_mass == 0);
        my $nl_mz = $nl_mass / $charge;

        my $fragment_href = {};

	#### B ion
	my $ion_mz = ($Bion_mass + $charge*$Nterm)/$charge;
        my $label_text =  "B$indices[$i]\^$charge$nl_string";
        # special case for precursor losses
        if (($i == $length-1) && ($charge == $precursor_charge)) {
	  $label_text = sprintf ("P-%d", $integer_nl_mass+18);
        }
        $fragment_href->{mz} = $ion_mz - $nl_mz;
        $fragment_href->{type} = 'B';
        $fragment_href->{charge} = $charge;
        $fragment_href->{num} = $i;
        $fragment_href->{neutral_loss} = $nl_mass;
        $fragment_href->{color} = $red;
        $fragment_href->{color} = $pink if ($charge > 1);
        $fragment_href->{color} = $black if ($nl_mass > 0);
        $fragment_href->{label_text} = $label_text;
        $fragment_href->{label_y} = 0;
        $fragment_href->{marker_y} = 0;
        push (@$fragments_aref, $fragment_href);

	$Bions[$i]->[$charge] = $ion_mz;

        $fragment_href = {};

	#### Y ion
        # skip "ion" which is precursor minus water; it has an
        # identical B counterpart taken care of above
        if ($i > 0) {
	  $ion_mz = ($Yion_mass + $charge*0.0)/$charge;
	  $label_text =  "Y$rev_indices[$i]\^$charge$nl_string";
	  $fragment_href->{mz} = $ion_mz - $nl_mz;
	  $fragment_href->{type} = 'Y';
	  $fragment_href->{charge} = $charge;
	  $fragment_href->{num} = $i;
	  $fragment_href->{neutral_loss} = $nl_mass;
	  $fragment_href->{color} = $blue;
	  $fragment_href->{color} = $navy if ($charge > 1);
	  $fragment_href->{color} = $black if ($nl_mass > 0);
	  $fragment_href->{label_text} = $label_text;
	  $fragment_href->{label_y} = 0;
	  $fragment_href->{marker_y} = 0;
	  push (@$fragments_aref, $fragment_href);
        }

	$Yions[$i]->[$charge] = $ion_mz;
      }
    }
  }

  # fill mzlist data structure with gathered info on fragments
  $mzlist_href->{residues} = \@modified_residues; #array of one-letter
		  #amino acid code plus a mass mod in brackets (?)
  $mzlist_href->{indices} = \@indices;  # simply 1 through length
  $mzlist_href->{rev_indices} = \@rev_indices;  #simply the reverse of indices
  $mzlist_href->{length} = $length; #peptide length
  $mzlist_href->{Bions} = \@Bions;  #m/z for all frags at all charges, no neutr
  $mzlist_href->{Yions} = \@Yions;  # loss. For printing text chart.

  #### Return reference to an array of hash references
  return $fragments_aref;
}

###############################################################################
# getMatchedFragments
#     Filter the fragments to get only those close to an actual peak.
###############################################################################
sub  getMatchedFragments {
  my %args = @_;
  my $fragments_aref = $args{'Fragments'};
  my @fragments = @$fragments_aref;
  my $spectrum_href = $args{'SpecData'};
  my %spectrum = %$spectrum_href;
  my $frag_mz_tol = $args{'FragMzTol'};
  my $ymin_nl = $args{'YminNL'};

  my $matched_fragments_aref = [];

  my $s = 0;       # index into peak array
  my $n_peaks = $spectrum{n_peaks};

  # Sort fragments in ascending m/z
  sub by_mz { $a->{mz} <=> $b->{mz}; }
  @fragments = sort by_mz @fragments;

  for my $fragment (@fragments) {
    my $frag_mz = $fragment->{mz};
    my $spec_mz;
    $spec_mz = $spectrum_href->{masses}->[$s];
    while (($spec_mz < $frag_mz-$frag_mz_tol) && $s < $n_peaks) {
      $s++;
      $spec_mz = $spectrum_href->{masses}->[$s];
    }
    my $spec_intens = $spectrum_href->{intensities}->[$s];
    # if the peak is within tolerance, and above threshold intensity
    # (neutral loss identifications only), save it
    if ( ($spec_mz <= ( $frag_mz + $frag_mz_tol ) ) &&
         ( ($spec_intens > $ymin_nl) || ($fragment->{neutral_loss} == 0))) {
      push (@$matched_fragments_aref, $fragment);
      #print "$fragment->{label_text} $fragment->{neutral_loss}<br>\n";
    }
    last if ($s >= $n_peaks);
  }

  return $matched_fragments_aref;
}

###############################################################################
# matchFragmentsWithPeaks
#     Annotate fragments with appropriate heights for plotting labels
#     Fill in a data structure with info on each fragment, whether or
#     not that fragment is matched with a peak.
###############################################################################
sub  matchFragmentsWithPeaks {
  my %args = @_;
  my $fragments_aref = $args{'Fragments'};   #already sorted asc mz
  my @fragments = @$fragments_aref;
  my $spectrum_aref = $args{'SpecData'};     #array of arefs to [mz,intens]
  my @spectrum = @$spectrum_aref;
  my $frag_mz_tol = $args{'FragMzTol'};
  my $mzlist_ref = $args{'MZlist'};          # info on frags for text chart
  my $win = $args{'Win'};
  my $angle = $args{'Angle'} || 0;       # angle to plot label
  my $fjust = $args{'Fjust'};
  my $Ymax = $args{'Ymax'};              # max value on Y-axis
  my $Xmin = $args{'Xmin'};              # min value on X-axis
  my $Xmax = $args{'Xmax'};              # max value on X-axis
  my $interval = $Ymax / 50.0;           # 2% of Y-axis height, in intensity
  my $xshift = ($Xmax - $Xmin) / 200.0;  # 0.5% of X-axis width, in mz

  my $n_peaks = scalar @spectrum;
  my $label_height = 3.5*($interval/3.);     # Y-axis space needed for label
  my $extra_height = 0;                      # amount to raise current label
                                             #  to not collide with previous


  my ($start_idx, $end_idx);
  my $prev_maxinten = 0;

  my @fragments_sharing_latest_tallest_peak = ();
  my $n_fragments_sharing_latest_tallest_peak = 0;
  my $non_loss_fragment_sharing_latest_tallest_peak = 0;

  # For each predicted fragment ion ...
  for my $fragment (@fragments) {
    my $frag_mz = $fragment->{mz};

    # Get indices of peaks within +/- frag_mz_tol mz
    ($start_idx, $end_idx) = slideWindowAlongSpectrum (
                spectrum=>$spectrum_aref,
                prev_start_idx => $start_idx,
                new_mz => $frag_mz,
                FragMzTol => $frag_mz_tol,
	      );

    # Store these indices with the fragment
    $fragment->{first_peak} = $start_idx;
    $fragment->{last_peak} = $end_idx;

    # Find out which within window is tallest
    my $biggest_inten = $spectrum_aref->[$start_idx]->[1];
    my $biggest_idx = $start_idx;
    #print "<br>$frag_mz";
    for (my $i = $start_idx; $i <= $end_idx; $i++) {
      my $peak_inten = $spectrum_aref->[$i]->[1];
      #print "<br>   $spectrum_aref->[$i]->[0] $peak_inten";
      if ($peak_inten > $biggest_inten) {
	$biggest_inten = $peak_inten;
        $biggest_idx = $i;
      }
    }

    # Store that there is a peak for this fragment
    my $charge = $fragment->{charge};
    my $num = $fragment->{num};
    if ($fragment->{type} eq 'B') {
      $mzlist_ref->{Bions_obs}->[$num]->[$charge] = 1;
    } elsif ($fragment->{type} eq 'Y') {
      $mzlist_ref->{Yions_obs}->[$num]->[$charge] = 1;
    }

    # If tallest peak within window is same as tallest peak within
    # window for previous fragment, bump up the location of the label
    # But don't pile on neutral loss fragments if there is a non-loss
    # fragment.
    if ($biggest_inten == $prev_maxinten) {
      $n_fragments_sharing_latest_tallest_peak++;
      # if this is the first non_loss fragment we've seen, 
      # dump all the others.
      if ( ! $fragment->{neutral_loss} &&
           ! $non_loss_fragment_sharing_latest_tallest_peak ) {
        remove_labels(\@fragments_sharing_latest_tallest_peak);
	$non_loss_fragment_sharing_latest_tallest_peak = 1;
      # if this is a neutral loss fragment and we've already seen a
      # non-loss fragment, dump this one
      } elsif ($fragment->{neutral_loss} &&
           $non_loss_fragment_sharing_latest_tallest_peak ) {
        $fragment->{label_text} = '';
      # bump up
      } else {
	$extra_height += $label_height;
      }
      push (@fragments_sharing_latest_tallest_peak, $fragment);

    # Otherwise, don't bump, and reset variables related to tallest
    # peak in window.
    } else {
      $extra_height = 0;
      @fragments_sharing_latest_tallest_peak = ($fragment);
      $n_fragments_sharing_latest_tallest_peak = 1;
      $non_loss_fragment_sharing_latest_tallest_peak = 
        !$fragment->{neutral_loss};
      $prev_maxinten = $biggest_inten;
    }

    # assign heights to label and tick mark
    $fragment->{marker_y} = $biggest_inten+($interval/3.);
    $fragment->{label_y} = $biggest_inten + 5*($interval/3.) + $extra_height;


  }

  return $win;

  # Find indices of peaks within +/- frag_mz_tol of current ion.
  # Because we process the ions in order of increasing m/z, we can
  # avoid looking at all the peaks and can start with the peak that
  # was at m/z-frag_mz_tol for previous ion.
  sub slideWindowAlongSpectrum {
    my %args = @_;

    my $spectrum = $args{'spectrum'};         #array of arefs to (mz,intens)
    my $prev_start_idx =
                     $args{'prev_start_idx'}; #index of 1st element of prev win
    my $new_mz = $args{'new_mz'};             #center of new window
    my $frag_mz_tol = $args{'FragMzTol'};       #half window width

    my $new_start_mz = $new_mz - $frag_mz_tol;
    my $new_end_mz = $new_mz + $frag_mz_tol;
    my $n_peaks = scalar @$spectrum;

    my $new_start_idx;
    my $new_end_idx;
    
    # Find indices corresponding to first & last peaks within new
    # window.
    for (my $i=$prev_start_idx; $i<$n_peaks; $i++) {
      my $mz = $spectrum->[$i]->[0];
      $new_start_idx = $i;
      last if ($mz >= $new_start_mz);
    }
    $new_end_idx = $new_start_idx;
    for (my $i=$new_start_idx; $i<$n_peaks; $i++) {
      my $mz = $spectrum->[$i]->[0];
      last if ($mz > $new_end_mz);
      $new_end_idx = $i;
    }

    return ($new_start_idx, $new_end_idx);
  }

  sub remove_labels {
    my $fraglist_aref = shift;
    for my $frag (@$fraglist_aref) {
      $frag->{label_text} = '';
    }
  }
}

###############################################################################
# PlotPeaks
###############################################################################
sub PlotPeaks {
  my %args = @_;

  #### Fragment ions
  my $fragments_aref = $args{'Fragments'};   #already sorted asc mz
  my @fragments = @$fragments_aref;

  #### Spectrum data to be plotted
  my $specdata = $args{'SpecData'};

  #### Plot frame
  my $win = $args{'Win'};

  #### Peak Colors
  my $peakcolors_ref = $args{'PeakColors'};

  # Lists of peak mz and intensity. Each peak belongs to one mz and
  # one intensity list, by its color. Initialize each list to be empty.
  my %mz_by_color;
  my %inten_by_color;
  my $mz_by_color_href = \%mz_by_color;
  my $inten_by_color_href = \%inten_by_color;
  for my $color (@used_colors) {
    $mz_by_color{$color} = [];
    $inten_by_color{$color} = [];
  }

  my $i;
  my $lineclr;
  my ($mz, $intensity);
  my $frag_idx = 0;
  my $n_frags = scalar @fragments;

  # For each actual peak in the spectrum ...
  for ($i=0; $i<$specdata->{n_peaks}; $i++) {

    ### Get the mz and intensity for this peak
    $mz = $specdata->{masses}->[$i];
    $intensity = $specdata->{intensities}->[$i];

    ### See if it is within frag_mz_tol of either the previous
    ### or the next fragment. If so, assign it to the proper color.
    ### Otherwise, assign it to black.
    my $prev_frag = $fragments[$frag_idx];
    my $next_frag = $fragments[$frag_idx+1];
    my ( $prev_mz_diff, $next_mz_diff );
    my $prev_frag_within_tol = 0;
    my $next_frag_within_tol = 0;
    my $peak_color;

    # See if this peak is within frag_mz_tol of either the prev or the
    # next frag
    if ( ( $i >= $prev_frag->{first_peak} ) &&
	 ( $i <= $prev_frag->{last_peak} ) ) {
      $prev_mz_diff = abs ( $mz - $prev_frag->{mz} );
      $prev_frag_within_tol = 1;
    }
    if ( ( $frag_idx + 1 < $n_frags ) &&
	 ( $i >= $next_frag->{first_peak} ) &&
	 ( $i <= $next_frag->{last_peak} ) ) {
      $next_mz_diff = abs ( $mz - $next_frag->{mz} );
      $next_frag_within_tol = 1;
    }

    # Depending on what we found, assign peak to a color
    if (! ($prev_frag_within_tol || $next_frag_within_tol) ) {
      # this peak will be unlabelled, unless user has requested
      # labeling of unidentified peaks
      $peak_color = $black;
      $frag_idx++ if ( ( $i > $prev_frag->{last_peak} ) &&
                       ( $frag_idx+1 < $n_frags ) );
    } elsif  ($prev_frag_within_tol &&
                ( !$next_frag_within_tol ||
		( $prev_mz_diff < $next_mz_diff))) {
      # this peak should be colored as for previous fragment
      $peak_color = $prev_frag->{color};
      $specdata->{identified}->[$i] = 1;
    } elsif ( $next_frag_within_tol ) {
      # this peak should be colored as for next fragment.
      # increment fragment counter, because we are done with the last
      # fragment.
      $peak_color = $next_frag->{color};
      $frag_idx++ if $frag_idx+1 < $n_frags;
      $specdata->{identified}->[$i] = 1;
    }
    # push peak info onto lists for its color
    push(@{$inten_by_color_href->{$peak_color}}, $intensity);
    push(@{$mz_by_color_href->{$peak_color}}, $mz);

    #print "$frag_idx $prev_frag->{mz} $mz<br>\n";
   
    # We may not need this anymore?
    $peakcolors_ref->[$i] = $peak_color;
  }

  my ($mass2, $intensity2);
  $mass2 = $specdata->{masses};
  $intensity2 = $specdata->{intensities};

  #### Now we plot all peaks by "never lifting the pen" and drawing it
  #### all in a continuous line with line() because this is much faster
  for my $color (@used_colors) {
    my $mz_list_aref = $mz_by_color_href->{$color};
    my $inten_list_aref = $inten_by_color_href->{$color};
    my $n_color_peaks = scalar @{$inten_list_aref};
    #print "$n_color_peaks of color $color<br>";
    my $x = pdl ($mz_list_aref,$mz_list_aref,$mz_list_aref)->
               xchg(0,1)->clump(2);
    my $a = [(0) x $n_color_peaks];
    my $y = pdl ($a,$inten_list_aref,$a)->xchg(0,1)->clump(2);
    my $h = {Color => $color};
    $win -> line ($x,$y,$h);
  }

  return ($win);
}

###############################################################################
# LabelPeaks
###############################################################################
sub  LabelPeaks {
  my %args = @_;
  my $fragments_aref = $args{'Fragments'};   #already sorted asc mz
  my @fragments = @$fragments_aref;
  my $win = $args{'Win'};
  my $angle = $args{'Angle'} || 0;       # angle to plot label
  my $fjust = $args{'Fjust'};
  my $Ymax = $args{'Ymax'};              # max value on Y-axis
  my $Xmax = $args{'Xmax'};              # max value on X-axis
  my $Xmin = $args{'Xmin'};              # min value on X-axis
  my $interval = $Ymax / 50.0;           # 2% of Y-axis height, in intensity
  my $xshift = ($Xmax - $Xmin) / 200.0;  # 0.5% of X-axis width, in mz

  for my $fragment (@fragments) {
    my $frag_mz = $fragment->{mz};

    my $label = $fragment->{label_text};
    if ($label ne '') {
      #### Plot marker line
      pgsci $fragment->{color};
      my $lineclr = $fragment->{color};
      my $labht = $fragment->{label_y};
      my $matchx = pdl [$frag_mz, $frag_mz];
      my $mht = $fragment->{marker_y};
      my $matchy = pdl [$mht, $mht+3*($interval/3.)];
      $win -> line($matchx, $matchy, {Color=>$lineclr});
      $win -> hold;
      #### Add m/z label
      my $mz = $fragment->{mz};
      pgptext $mz+$xshift,$labht,$angle,$fjust,"$label"
	if (($labht < $Ymax) && ($mz > $Xmin) && ($mz < $Xmax));
    }
  }
}

###############################################################################
# printIonTable
###############################################################################
sub printIonTable {
  my %args = @_;

  my $mzlist_ref = $args{'mzlist_ref'};
  my $color = $args{'color'} || 0;
  my $html = $args{'html'} || 0;
  my $charge = $args{'charge'};
  my $length = $args{'length'};
  my $theoretical_spectrum_ref = $args{'theoretical_spectrum_ref'};

  my $buffer = '';

  $buffer .= "Residue  ion     B       Y      ion   +$charge\n";
  $buffer .= "------  -----  ------  ------  -----\n";
#  $buffer .= "Residue B-ion  B-pred  B-spec  B-inten    Y-ion  Y-pred Y-spec  Y-inten   +$charge\n";
#  $buffer .= "------  -----  ------  ------  -------    -----  ------ ------  -------\n";

  my ($bcolbegin, $bcolend, $ycolbegin, $ycolend);

  #### Define HTML colors that correspond to those we used for plotting
  my %colors;
  $colors{$red} = "#FF0000";
  $colors{$blue} = "#0000FF";
  $colors{$green} = "#218D21";
  $colors{$pink} = "#F18080";
  $colors{$navy} = "#00088";
  $colors{$lt_green} = "#8FBE8F";

  my $color_tag;


  #### Printing stuff
  for (my $i=0; $i < $length; $i++) {

    #### If the output is in HTML, define the colorizing tags
    if ($html) {

      #### If a color for this B ion mass, set color tags
      $color_tag = $pink;
      if ($charge == 1) {
        $color_tag = $red;
      }
      if ($mzlist_ref->{Bions_obs}->[$i]->[$charge] ) {
        $bcolbegin = "<FONT COLOR = $colors{$color_tag}>";
        $bcolend = "</FONT>";
      #### else no color (default black)
      } else {
        $bcolbegin = "";
        $bcolend = "";
      }

      #### If a color for this Y ion mass, set color tags
      $color_tag = $navy;
      if ($charge == 1) {
        $color_tag = $blue;
      }
      if ($mzlist_ref->{Yions_obs}->[$i]->[$charge] ) {
        $ycolbegin = "<FONT COLOR = $colors{$color_tag}>";
        $ycolend = "</FONT>";
      #### else no color (default black)
      } else {
        $ycolbegin = "";
        $ycolend = "";
      }

    }


    #### Define the m/z columns formats and values
    my $B_format = '%7.1f';
    my $Y_format = '%7.1f';
    my $B_value = $mzlist_ref->{Bions}->[$i]->[$charge];
    my $Y_value = $mzlist_ref->{Yions}->[$i]->[$charge];


    #### Special case --'s for first row
    if ($i == 0) {
      $Y_format = '%7s';
      $Y_value = '--  ';

    #### Special case --'s for last row
    } elsif ($i == ($length-1)) {
      $B_format = '%7s';
      $B_value = '--  ';
    }

    #### Print out the data
    $buffer .= sprintf("%6s  %5s $bcolbegin$B_format$bcolend ".
      "$ycolbegin$Y_format$ycolend  %5s\n",
      $mzlist_ref->{residues}->[$i], "B".($i+1)."\^$charge",
      $B_value, $Y_value, "Y".($length-$i)."\^$charge");

    #### Fill the theoretical spectrum data in a different format
    #### (Residue,Index,Ion,Charge,m/z)
    $theoretical_spectrum_ref->[2*$length*($charge-1)+$i] =
      [$mzlist_ref->{residues}->[$i],$i+1,'B',$charge,$B_value];
    $theoretical_spectrum_ref->[2*$length*($charge-1)+2*$length-1-$i] =
      [$mzlist_ref->{residues}->[$i],$length-$i,'Y',
      $charge,$Y_value];


  } # end for

  $buffer .= "\n";

  return $buffer;

} # end printIonTable
