#!/tools32/bin/perl
#!/usr/local/bin/perl

BEGIN {
push @INC, qw( /net/db/src/SSRCalc/ssrcalc .  /tools32/lib/perl5/5.8.0/i386-linux-thread-multi /tools32/lib/perl5/5.8.0 /tools32/lib/perl5/site_perl/5.8.0/i386-linux-thread-multi /tools32/lib/perl5/site_perl/5.8.0 /tools32/lib/perl5/site_perl );
}

###############################################################################
# Program     : ShowObservedSpectrum
#
# Description : This CGI program displays a single spectrum in PeptideAtlas
#
# Based upon the ShowSpectrum.cgi in the Proteomics module by
# Kerry & Eric Deutsch
#
###############################################################################


###############################################################################
# Basic SBEAMS setup
###############################################################################
use strict;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($q $sbeams $sbeamsMOD $PROG_NAME
             $current_username $massCalculator );

use SBEAMS::Connection qw($q);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;

use SBEAMS::Proteomics::PeptideMassCalculator;
#$massCalculator = new SBEAMS::Proteomics::PeptideMassCalculator;

use PGPLOT;
use PDL;
use PDL::Graphics::PGPLOT;

use File::Basename;

use Carp;
$SIG{__DIE__} = sub { &Carp::confess };
use CGI::Carp qw (fatalsToBrowser);

#$q = new CGI;
$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);

$PROG_NAME="ShowObservedSpectrum";

###############################################################################
# Define global variables if any and execute main()
###############################################################################
main();


###############################################################################
# Main Program:
#
# If $sbeams->Authenticate() succeeds, print header, process the CGI request,
# print the footer, and end.
###############################################################################
sub main {

  #### Do the SBEAMS authentication and exit if a username is not returned
  exit unless ($current_username = $sbeams->Authenticate(
    permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
      'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
    #connect_read_only=>1,
    allow_anonymous_access=>1,
  ));


  #### Process certain actions, then print the header, figure and do what the user wants, and print footer
  processDatabaseActions();
  $sbeamsMOD->display_page_header();
  processRequest();
  $sbeamsMOD->display_page_footer();

  $sbeams->display_page_footer(close_tables=>'YES',
    separator_bar=>'YES',display_footer=>'NO');

} # end main


###############################################################################
# Process insert/update/delete, if any, then redirect
###############################################################################
sub processDatabaseActions {
    my $redirect = 0;
    my %parameters;

    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);
    $sbeams->processStandardParameters(parameters_ref=>\%parameters);

    my $apply_action  = $q->param('apply_action');

    if ($apply_action eq "UPDATE ANNOTATION") {
	my %rowdata = (
		       spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
		       comment => $parameters{user_spectrum_commment}
		       );

	my $PK = $sbeams->updateOrInsertRow(
					    update => 1,
					    table_name => $TBAT_SPECTRUM_ANNOTATION,
					    rowdata_ref => \%rowdata,
					    PK => 'spectrum_annotation_id',
					    PK_value => $parameters{spectrum_annotation_id},
					    return_PK => 1,
					    add_audit_parameters => 1
					    );

	if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been updated." ); }
	else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem updating your annotation record." ); }

	$redirect++;

    } elsif ($apply_action eq "ADD ANNOTATION") {
	my %rowdata = (
		       annotator_contact_id => $sbeams->getCurrent_contact_id(),
		       spectrum_identification_id => $parameters{spectrum_identification_id},
		       spectrum_id => $parameters{spectrum_id},
		       identified_peptide_sequence => $parameters{peptide},
		       identified_peptide_charge => $parameters{assumed_charge},
		       spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
		       comment => $parameters{user_spectrum_commment}
		       );

	my $PK = $sbeams->updateOrInsertRow(
				   insert => 1,
				   table_name => $TBAT_SPECTRUM_ANNOTATION,
				   rowdata_ref => \%rowdata,
				   return_PK => 1,
				   add_audit_parameters => 1
				   );

	if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been added." ); }
	else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem inserting your annotation record." ); }

	$redirect++;

    } elsif ($apply_action eq "DELETE ANNOTATION") {
	my %rowdata = (
		       record_status => 'D'
		       );

	my $PK = $sbeams->updateOrInsertRow(
					    update => 1,
					    table_name => $TBAT_SPECTRUM_ANNOTATION,
					    rowdata_ref => \%rowdata,
					    PK => 'spectrum_annotation_id',
					    PK_value => $parameters{spectrum_annotation_id},
					    return_PK => 1,
					    add_audit_parameters => 1
					    );

	if ($PK) { $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been deleted." ); }
	else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem deleting your annotation record." ); }

	$redirect++;
    }

    if ($redirect) {
	$q->delete( 'apply_action' );
	print $q->redirect( $q->self_url() );
	exit;
    }

}


###############################################################################
# Print Entry Form
###############################################################################
sub processRequest {

    #### Define some general variables
    my ($i,$element,$key,$value,$sql);

    my %parameters;

    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);

    $sbeams->processStandardParameters(parameters_ref=>\%parameters);

    my $apply_action  = $q->param('apply_action');

    #$sbeams->printDebuggingInfo($q);

    my $assumed_charge = $parameters{'assumed_charge'};

    my $charge = $parameters{'charge'};
    my @charge;
    if ($charge) {
      @charge = split(',',$parameters{'charge'});
    } elsif ($assumed_charge) {
      my $icharge = 1;
      while ($icharge <= $assumed_charge && $icharge < 4) {
        push(@charge,$icharge);
	$icharge++;
      }
    }

    $parameters{'ionlab'} = "Horizontal" unless $parameters{'ionlab'};
    my ($labangle,$fjust);
    if ($parameters{'ionlab'} eq "Vertical") {
      $labangle = 90;
      $fjust = 0;
    } else {
      $labangle = 0;
      $fjust = 0.5;
    }

    print qq!
	<P>
	<FORM METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
    !;

    #### Set up the table and data column
    print qq!
	<TABLE BORDER=0 CELLPADDING=3 WIDTH="675">
	<TR VALIGN=top>
	<TD VALIGN=top >
	<PRE>\n!;

    #### If we have a spectrum_id, find the mass modifications
    if ($parameters{'spectrum_identification_id'})
    {
        my $sql = qq~
            SELECT peptide_sequence,peptide_charge,average_parent_mz,
                   MPI.modified_peptide_sequence,S.spectrum_id
              FROM $TBAT_SPECTRUM_IDENTIFICATION SI
              JOIN $TBAT_MODIFIED_PEPTIDE_INSTANCE MPI
                   ON ( SI.modified_peptide_instance_id = MPI.modified_peptide_instance_id )
              JOIN $TBAT_PEPTIDE_INSTANCE PI
                   ON ( MPI.peptide_instance_id = PI.peptide_instance_id )
             INNER JOIN $TBAT_PEPTIDE P
                   ON ( PI.peptide_id = P.peptide_id )
              LEFT JOIN $TBAT_SPECTRUM S
                   ON ( SI.spectrum_id = S.spectrum_id )
            WHERE spectrum_identification_id = '$parameters{spectrum_identification_id}'
        ~;

        my @rows = $sbeams->selectSeveralColumns($sql);

        foreach my $row (@rows)
        {
            my ($seq, $chg, $mz, $mod_seq, $spectrum_id) = @{$row};
            $parameters{'peptide'} = $mod_seq;
            $parameters{'assumed_charge'} = $chg;
            $parameters{'precursor_mass'} = $mz;
            $parameters{'protein_name'} = 'foo';
            $parameters{'protein_name_alt'} = 'bar';
            $parameters{'modified_sequence'} = $mod_seq;
            $parameters{'spectrum_id'} = $spectrum_id;
        }
    }

    if ( $parameters{peptide} ) {
	print "<TR><TD COLSPAN=2 CLASS=section_description ALIGN=CENTER>Spectrum for $parameters{modified_sequence} <SUP>+$parameters{assumed_charge}</SUP></TD></TR>\n";
	print '<TR ID="annotations_head" style="display:none"><TD ID="annotations_summary" COLSPAN="2">-- No annotations here --</TD></TR>';
    }

    # lots of lint here...
    my $peptide = $parameters{peptide};
    $peptide =~ s/^.\.//;
    $peptide =~ s/\..$//;
    my $precursor_mass = $parameters{'precursor_mass'};
    my $charge = $parameters{'assumed_charge'};
    my $protein_name = $parameters{'protein_name'};
    my $protein_name_alt = $parameters{'protein_name_alt'};
    my $modified_sequence = $parameters{'modified_sequence'};

    $parameters{assumed_charge} = $charge;


    #### Calculate peptide mass information
    my $masstype = $parameters{masstype} || 0;
    my ($AAmasses_ref) = InitializeMass($masstype);

    my %spectrum = get_spectrum(
        spectrum_id=>$parameters{spectrum_id});

    unless (%spectrum) 
    {
      print "ERROR: Unable to load spectrum\n";
      return;
    }

    my ($i,$mass,$intensity,$massmin,$xticks);
    my ($massmax,$intenmax)=(0,0);
    my @spectrum_array;

    for ($i=0; $i<$spectrum{n_peaks}; $i++) {
      $mass = $spectrum{masses}->[$i];
      $intensity = $spectrum{intensities}->[$i];
      push(@spectrum_array,[$mass,$intensity]);
      $massmin = $mass if ($i == 0);
      $massmax = $mass if ($mass > $massmax);
      $intenmax = $intensity if ($intensity > $intenmax);
    }

    #### Compute data and plot bounds
    $parameters{xmin} = int($massmin/200)*200 unless $parameters{xmin};
    $parameters{xmax} = int($massmax/200)*200+200 unless $parameters{xmax};

    unless (exists $parameters{ymax})
    {
        $parameters{ymax} = $intenmax * 1.1;
    }

    if ($q->param("reset") eq "ZOOM OUT")
    {
      $parameters{ymax} = $intenmax;
      $parameters{xmin} = int($massmin/100)*100;
      $parameters{xmax} = int($massmax/100)*100+100;
    }

    my $maxval = $intenmax;
    #$intenmax *= 1.3 / ( $parameters{zoom} || 1 );
    my $interval = $parameters{ymax} / 20;
    my $interval_power = ( $interval ) ? int( log($interval) / log(10) ) : 0;
    my $roundval = 10**$interval_power;
    #$intenmax = int($intenmax/$roundval)*$roundval;
    $parameters{ymax} = int( $parameters{ymax} /$roundval)*$roundval;
    my $ydiv = $parameters{ymax} / 5;

    #### Calculate fragment ions for the given peptide
    my @residues = Fragment($peptide);
    my $length = $#residues + 1;

    #### Initialize the plot environment
    my($progname)= basename $0;
    #my($tmpfile) = "$progname.$$.@{[time]}.gif";
    #### Reduce length because of PGPLOT 80 char limit??
    my($tmpfile) = "Spec.$$.@{[time]}.gif";

#   $parameters{gifwidth} = 640 unless $parameters{gifwidth};
#   $parameters{gifheight} = 480 unless $parameters{gifheight};
    $parameters{gifwidth} = 800 unless $parameters{gifwidth};
    $parameters{gifheight} = 400 unless $parameters{gifheight};

    if ($apply_action eq "PRINTABLE FORMAT") {
      $parameters{gifwidth} = 480;
      $parameters{gifheight} = 384;
    }

    #print "Writing GIF to: $PHYSICAL_BASE_DIR/tmp/images/$tmpfile\n";
    my $win = pg_setup(Device=>"$PHYSICAL_BASE_DIR/tmp/images/$tmpfile/gif",
        title=>"$parameters{peptide}",
        xmin=>$parameters{xmin}, xmax=>$parameters{xmax},
        ymax=>$parameters{ymax}, ydiv=>$ydiv, nyticks=>5,
        gifwidth=>$parameters{gifwidth},
        gifheight=>$parameters{gifheight}
    );

    pgsch 0.9;
    my $prec = sprintf ("%0.1f", $precursor_mass);
    pgmtext 'T',0.7,.01,0,"Peak value = $maxval  Precursor m/z = $prec";
#   pgmtext 'RV',-2,1.02,1,"Assumed charge = $parameters{assumed_charge}";
    pgmtext 'RV',-2,1.02,1,"Charge = $parameters{assumed_charge}";

    my @peakcolors;
    my @theoretical_spectrum;

    #### Loop over each desired charge
    my $charge;
    my $buffer = '';
    foreach $charge (@charge) {
      my ($masslist_ref) = CalcIons(Residues=>\@residues, Charge=>$charge,
                                    MassArray=>$AAmasses_ref);
      my ($B_ref,$Y_ref);

      #### Make the plot and figure out what the labels should be
      ($win,$B_ref,$Y_ref) = PlotPeaks(SpecData=>\%spectrum,
                                       Masslist=>$masslist_ref, Charge=>$charge,
                                       Win=>$win, Length=>$masslist_ref->{length},
                                       PeakColors=>\@peakcolors);

      #### Print out the peptide ion information
      $buffer .= printIons(masslist_ref=>$masslist_ref,color=>1,html=>1,
        charge=>$charge,length=>$masslist_ref->{length},
        theoretical_spectrum_ref=>\@theoretical_spectrum);

      #### Label the peaks on the plot
      LabelResidues(Ionmasses=>$masslist_ref, Binten=>$B_ref, Yinten=>$Y_ref,
                    Charge=>$charge, Win=>$win, Length=>$masslist_ref->{length},
                    Xmin=>$parameters{xmin}, Xmax=>$parameters{xmax},
                    Ymax=>$parameters{ymax}, Angle=>$labangle, Fjust=>$fjust);

    } # end foreach

    #### Label tall unidentified peaks with their m/z values, if requested
    #### Isn't working for re-display (i.e. zoom).
    if ( $parameters{mzlabels}) {
      my $mz_label_threshold = $parameters{mzlabels} || 0.05;
      if (($mz_label_threshold < 0 ) || ( $mz_label_threshold > 1.0 ) ||
            ($mz_label_threshold * 1 ne $mz_label_threshold)) {
	die("ERROR: mzlabels parameter must be number between 0.0 and 1.0");
      }
      LabelUnidentifiedPeaks( SpecData=>\%spectrum, Win=>$win, 
                  MZ_threshold=>$mz_label_threshold,
		  Xmin=>$parameters{xmin}, Xmax=>$parameters{xmax},
		  Ymax=>$parameters{ymax}, Angle=>$labangle, Fjust=>$fjust);
    }


    #### Draw Precursor mass symbol
    if ($parameters{precursor_mass}) {
      pgsci 2;    #### Default color
      pgsch 2;    #### Character size
      pgslw 5;    #### Line thinkness
      pgsclp(0);   #### Disable clipping
      pgpt(1,$parameters{precursor_mass},-0.34 * $interval,7);
      pgsch 1;    #### Character size
      pgpt(1,$parameters{precursor_mass},-0.34 * $interval,7);
    }


    #### Finish and close the plot
    $win->close();


    #### Set up the image cell
    print qq~</PRE>
	</TD>
	<TD VALIGN=top>
	<IMG SRC="$HTML_BASE_DIR/tmp/images/$tmpfile"><BR>
    ~;


    my $hidden_form_fields = qq~
        <INPUT TYPE="hidden" NAME="spectrum_identification_id" VALUE="$parameters{spectrum_identification_id}">
        <INPUT TYPE="hidden" NAME="assumed_charge" VALUE="$parameters{assumed_charge}">
        <INPUT TYPE="hidden" NAME="peptide" VALUE="$parameters{peptide}">
	~;

    print $hidden_form_fields;

    #### Charge selector
    my $onChange = "";
   $sql = "SELECT option_key,option_value FROM $TBAT_QUERY_OPTION " .
          " WHERE option_type = 'charge_constraint' " .
          " ORDER BY sort_order,option_value";
   my $optionlist = $sbeams->buildOptionList($sql,$parameters{'charge'});

   print qq~
       Charge: <SELECT NAME="charge" $onChange>
       $optionlist</SELECT>
   ~;

    print qq~
        <nobr>
	Xmin: <INPUT NAME="xmin" VALUE="$parameters{xmin}" SIZE="4" $onChange>
	Xmax: <INPUT NAME="xmax" VALUE="$parameters{xmax}" SIZE="4" $onChange>
	Ymax: <INPUT NAME="ymax" VALUE="$parameters{ymax}" SIZE="8" $onChange>
        <INPUT TYPE="submit" NAME="apply_action" VALUE="DISPLAY"/>
	<INPUT TYPE="submit" NAME="reset" VALUE="ZOOM OUT">
        <INPUT TYPE="submit" NAME="apply_action" VALUE="PRINTABLE FORMAT">
        </nobr>
    ~;



    #### Store the observed spectrum data as a recallable resultset
    my %dataset;
    $dataset{data_ref} = \@spectrum_array;
    $dataset{column_list_ref} = ['m/z','intensity'];
    my $rs_set_name = "SETME";
    $sbeams->writeResultSet(resultset_file_ref=>\$rs_set_name,
      resultset_ref=>\%dataset,
      file_prefix=>'spec_',
      query_parameters_ref=>\%parameters);


    #### Store the peptide data as a recallable resultset
    my %peptide_dataset;
    $peptide_dataset{data_ref} = \@theoretical_spectrum;
    $peptide_dataset{column_list_ref} = ['Residue','Index','Ion','Charge','m/z'];
    my $pep_rs_set_name = "SETME";
    $sbeams->writeResultSet(resultset_file_ref=>\$pep_rs_set_name,
      resultset_ref=>\%peptide_dataset,
      file_prefix=>'peptide_',
      query_parameters_ref=>\%parameters);

    #### Finish up the table and form
    print qq~<BR>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <BR>Download spectrum in Format: 
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$rs_set_name.tsv?rs_set_name=$rs_set_name&format=tsv">TSV</a>,
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$rs_set_name.xls?rs_set_name=$rs_set_name&format=excel">Excel</a>
        <BR>Download peptide data in Format: 
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$pep_rs_set_name.tsv?rs_set_name=$pep_rs_set_name&format=tsv">TSV</a>,
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$pep_rs_set_name.xls?rs_set_name=$pep_rs_set_name&format=excel">Excel</a>
        <BR>
	</TD>
	</TR>
	</TABLE>
        </FORM>
        <PRE>$buffer</PRE>
    ~;

    print &printUserAnnotations(
				spectrum_id => $parameters{'spectrum_id'},
				modified_sequence => $parameters{'modified_sequence'},
				charge => $parameters{'assumed_charge'},
				spectrum_identification_id => $parameters{'spectrum_identification_id'},
				form_fields => $hidden_form_fields
				) if ($parameters{'spectrum_identification_id'});

} # end printEntryForm


###############################################################################
# get_spectrum
###############################################################################
sub get_spectrum
{
  my %args = @_;

  my $spectrum_id = $args{'spectrum_id'};
  unless ($spectrum_id) {
    print "\nERROR: spectrum_id not passed.\n\n";
    return;
  }


  my $sql = qq~
    SELECT proteomics_search_batch_id,spectrum_name
      FROM $TBAT_SPECTRUM S
      JOIN $TBAT_SPECTRUM_IDENTIFICATION SI
           ON (S.spectrum_id = SI.spectrum_id )
      JOIN $TBAT_ATLAS_SEARCH_BATCH ASB
           ON (SI.atlas_search_batch_id = ASB.atlas_search_batch_id )
     WHERE S.spectrum_id = $spectrum_id
  ~;

  my @rows = $sbeams->selectSeveralColumns($sql);
  unless (@rows) {
    print "\nERROR: Unable to get search batch information for ".
      "spectrum_id '$spectrum_id'.\n\n";
    return;
  }
  my $search_batch_id = $rows[0]->[0];
  my $spectrum_name = $rows[0]->[1];
  my $fraction_tag;
  if ($spectrum_name =~ /^(.+)\.(\d+)\.(\d+)\.\d$/) {
    $fraction_tag = $1;
  } else {
    die("ERROR: Unable to parse fraction name from '$spectrum_name'");
  }

  #print "search_batch_id = $search_batch_id\n";
  #print "spectrum_name = $spectrum_name\n";
  #print "fraction_tag = $fraction_tag\n";


  use SBEAMS::PeptideAtlas::Spectrum;
  my $spectra = new SBEAMS::PeptideAtlas::Spectrum;
  $spectra->setSBEAMS($sbeams);

  my @mass_intensities = $spectra->getSpectrumPeaks(
    proteomics_search_batch_id => $search_batch_id,
    spectrum_name => $spectrum_name,
    fraction_tag => $fraction_tag,
  );


  #### If we still have no spectrum data, then bail out
  unless (@mass_intensities) {
    print "\nERROR: Unable to get m/z,intensity pairs for ".
      "spectrum_id '$spectrum_id'.\n\n";
    return;
  }

  #### Extract rows into two arrays of masses and intensities
  my (@masses,@intensities);
  for (my $i=0; $i<=$#mass_intensities; $i++) {
    push(@masses,$mass_intensities[$i]->[0]);
    push(@intensities,$mass_intensities[$i]->[1]);
  }

  my %spectrum;
  $spectrum{n_peaks} = $#mass_intensities + 1;


  #### Put data into hash and return
  $spectrum{masses} = \@masses;
  $spectrum{intensities} = \@intensities;

  return %spectrum;


}


###############################################################################
# InitializeMass -- returns reference to hash of amino acid mono-isotopic masses
###############################################################################
sub InitializeMass {
    my %AAmasses = (
    "G" => "57.02146",
    "A" => "71.03711",
    "S" => "87.02303",
    "P" => "97.05276",
    "V" => "99.06841",
    "T" => "101.04768",
    "C" => "103.00919",
    "L" => "113.08406",
    "I" => "113.08406",
    "N" => "114.04293",
    "D" => "115.02694",
    "Q" => "128.05858",
    "K" => "128.09496",
    "E" => "129.04259",
    "M" => "131.04049",
    "H" => "137.05891",
    "F" => "147.06841",
    "R" => "156.10111",
    "Y" => "163.06333",
    "W" => "186.07931",
    );

    return (\%AAmasses);
}

###############################################################################
# pg_setup
###############################################################################
sub pg_setup {
    my %args = @_;

    #### Default device is to screen (xserver)
    my $device = $args{'Device'} || "\/xs";
    #$device = "/xs";

    #### Plot title
    my $title = $args{'title'} || "";

    #### Default x limits are (0,2000)
    my $xmin = $args{'xmin'} || 0;
    my $xmax = $args{'xmax'} || 2000;

    #### Default y limits are (0,500000)
    my $ymin = $args{'ymin'} || 0;
    my $ymax = $args{'ymax'} || 500000;

    #### Default separation between ticks is 100000
    my $ytickdiv = $args{'ydiv'} || 100000;

    #### Default number of y ticks
    my $nyticks = ($args{'nyticks'}+1) || 4;

    #### Default image size is 640x480
    my $gifwidth = $args{'gifwidth'} || 640;
    my $gifheight = $args{'gifheight'} || 480;

    #### Set needed PGPLOT environment variables
    $ENV{"PGPLOT_GIF_WIDTH"} = $gifwidth;
    $ENV{"PGPLOT_GIF_HEIGHT"} = $gifheight;

    #### Try to set the proper location of rgb.txt
    if ($CONFIG_SETTING{PGPLOT_RGBTXT}) {
      $ENV{"PGPLOT_RGB"} = $CONFIG_SETTING{PGPLOT_RGBTXT};
    } elsif ( -e "/usr/share/X11/rgb.txt" ) {
      $ENV{"PGPLOT_RGB"} = "/usr/share/X11/rgb.txt";
    } else {
      $ENV{"PGPLOT_RGB"} = "/usr/X11R6/lib/X11/rgb.txt";
    }

    $ENV{"PGPLOT_FONT"} = $CONFIG_SETTING{PGPLOT_FONT} ||
      "/usr/local/lib/grfont.dat";
    $ENV{"PGPLOT_BACKGROUND"} = "white";

    #### Create a new graphics device
    #### WARNING: If the device is a filename, it apparently gets
    #### truncated at 80 characters!!!
    my $win = PDL::Graphics::PGPLOT::Window -> new({Device => "$device"});

    #### Set window limits
    pgswin $xmin, $xmax, 0, $ymax;

    #### Set viewport limits
    pgsvp .095,.9775,.065,.95;

    #### Set axis color to black (stealing lt. gray color)
    pgscr 15, 0,0,0;

    #### Set color index
    pgsci 15;

    #### Set character height
    pgsch 0.9;

    #### Set line width
    pgslw 1;

    #### Set character font (Normal)
    pgscf 1;

    #### Draw labeled frame around viewport: full frame (BC), labels on
    #### bottom and left of frame (N), major tick marks (T), y labels
    #### normal to y-axis (V), decimal labels instead of scientific
    #### notation (1), automatic x major ticks, $ytickdiv between y ticks,
    #### with $nyticks major divisions.
    pgbox 'BCNT',0,0,'BCNTV1',$ytickdiv,$nyticks;

    #### Reset character height (make labels larger)
    pgsch 1;

    #### Y label on left, centered vertically along axis
    pgmtxt 'L',3.8,.5,.5,'Intensity';

    #### X label on bottom, centered vertically along axis
    pgmtxt 'B',2.25,.5,.5,'m/z';

    #### Main title above, centered vertically along top
    pgmtxt 'T',1,.5,.5,"$title";

    #### Reset character height (want in-plot labels small)
    pgsch .8;

    #### Allow overplotting of this frame
    $win -> hold;

    return $win;
}

###############################################################################
# PlotPeaks
#  called once for each possible charge
###############################################################################
sub PlotPeaks {
    my %args = @_;

    #### Spectrum data to be plotted
    my $specdata = $args{'SpecData'};

    #### Ions to be plotted
    my $masslist_ref = $args{'Masslist'};

    #### Charge
    my $charge = $args{'Charge'};

    #### Plot frame
    my $win = $args{'Win'};

    #### Peak Colors
    my $peakcolors_ref = $args{'PeakColors'};

    #### Peak finding window. An arg isn't currently passed, so
    ####  default value 2 is used.
    my $window = $args{'Window'} || 2;

    #### Number of residues in matched peptide
    my $length = $args{'Length'};
    #### Intensity of tallest peak (if any) close to each ion's m/z.
    my @Bmaxinten = (0) x $length;
    my @Ymaxinten = (0) x $length;
    my @BYmaxinten = (0) x $length;

    # Lists of peak masses. Each peak belongs to one list.
    my @Bmass;
    my @Ymass;
    my @BYmass;
    my @Rmass;

    # Lists of peak intensities. Each peak belongs to one list.
    my @Binten;
    my @Yinten;
    my @BYinten;
    my @Rinten;
    #my @Rinten = (0) x $specdata->{n_peaks};


    my ($redcol,$bluecol,$grcol);

    #### Define pink color to be lightcoral
    pgscr 6,0.94,0.5,0.5;

    #### Define lt. blue color to be navy
    pgscr 11,0,0,.5;

    #### Define lt. green color to be DarkSeaGreen
    pgscr 10,0.56,0.74,0.56;

    #### Define red color to be red
    pgscr 2,1,0,0;

    #### Define blue color to be blue
    pgscr 4,0,0,1;

    #### Define green color to be ForestGreen
    pgscr 3,0.13,0.55,0.13;

    if ($charge == 1) {
      $redcol = 2;
      $bluecol = 4;
      $grcol = 3;
    } else {
      $redcol = 6;
      $bluecol = 11;
      $grcol = 10;
    }


    #### Convert lists of m/z values to piddle for easy sub-selecting
    #### These are lists of length $length of expected m/z values for
    ####  each predicted ion.
    my $bdata = pdl $masslist_ref->{Bions};
    my $ydata = pdl $masslist_ref->{Yions};

    #### Draw peaks
    my $i;
    my $lineclr;
    my ($mass, $intensity);

    # For each actual peak in the spectrum ...
    for ($i=0; $i<$specdata->{n_peaks}; $i++) {

      ### Get the mass and intensity for this peak
      $mass = $specdata->{masses}->[$i];
      $intensity = $specdata->{intensities}->[$i];

      #### Set default line color to Black
      $lineclr = $peakcolors_ref->[$i] || 14;

      ### Bind and Yind each contain the index into $bdata/$ydata
      ###  for any value within a small window around the current peak,
      ###  else 'Empty' if no value in that window.
      my $Bind = which($bdata >= ($mass-$window) & $bdata <= ($mass+$window));
      my $Yind = which($ydata >= ($mass-$window) & $ydata <= ($mass+$window));

      my $b = $Bind->at(0) if ($Bind !~ 'Empty');
      my $y = $Yind->at(0) if ($Yind !~ 'Empty');

      #### Figure out how to label this peak, if at all.

      #### If there are just B fragments with m/z near enough this peak ...
      ####   Don't label/colorize peaks corresponding to "fragments"
      ####   corresponding to entire peptide ($b = $length-1 or $y=0)
      if (($Bind !~ 'Empty') && ($b != $length-1) &&
         (($Yind =~ 'Empty') || ($y == 0))) {
        $lineclr = $redcol;
        # store the mass and intensity of this peak on a list for B-ions
        push(@Binten,$intensity);
        push(@Bmass,$mass);
        # Record that this peak has been identified
        $specdata->{identified}->[$i] = 1;
        # If there is more than one peak close to this
        # m/z, be sure to print the label above the tallest one
        if ($Bmaxinten[$b] < $intensity) {
          $Bmaxinten[$b] = $intensity;
          $masslist_ref->{Bcolor}->[$b] = $lineclr
            unless ($masslist_ref->{Bcolor}->[$b]);
        }

      #### Else if there are just Y fragments with m/z near enough this peak
      } elsif (($Yind !~ 'Empty') && ($y != 0) &&
	      (($Bind =~ 'Empty') || ($b == $length-1))) {
        $lineclr = $bluecol;
        push(@Yinten,$intensity);
        push(@Ymass,$mass);
        $specdata->{identified}->[$i] = 1;
        if ($Ymaxinten[$y] < $intensity) {
          $Ymaxinten[$y] = $intensity;
          $masslist_ref->{Ycolor}->[$y] = $lineclr;
        }

      #### Else if both B and Y fragments with m/z near enough this peak
      } elsif (($Bind !~ 'Empty') && ($Yind !~ 'Empty')) {
        $lineclr = $grcol;
        push(@BYinten,$intensity);
        push(@BYmass,$mass);
        $specdata->{identified}->[$i] = 1;
        if ($Ymaxinten[$y] < $intensity) {
          $Ymaxinten[$y] = $intensity;
          $masslist_ref->{Ycolor}->[$y] = $lineclr;
        }
        if ($Bmaxinten[$b] < $intensity) {
          $Bmaxinten[$b] = $intensity;
          $masslist_ref->{Bcolor}->[$b] = $lineclr;
        }

      #### else if there are no fragments with mass near enough this peak
      } else {
        # what is this for?
        if (($peakcolors_ref->[$i] != 2) & ($peakcolors_ref->[$i] != 3) &
            ($peakcolors_ref->[$i] != 4) & ($peakcolors_ref->[$i] != 6) &
            ($peakcolors_ref->[$i] != 10) & ($peakcolors_ref->[$i] != 11)) {
          #$Rinten[$i] = $intensity
          push(@Rinten,$intensity);
          push(@Rmass,$mass);
        }

      }

      $peakcolors_ref->[$i] = $lineclr;
    }

    my ($mass2, $intensity2);
    $mass2 = $specdata->{masses};
    $intensity2 = $specdata->{intensities};

    #### Now we resort to plotting all peaks by "never lifting the pen"
    #### and drawing it all in a continuous line with line() because this
    #### is much faster
    my $rx = pdl (\@Rmass,\@Rmass,\@Rmass)->xchg(0,1)->clump(2);
    #my $rx = pdl ($mass2,$mass2,$mass2)->xchg(0,1)->clump(2);
    my $ra = [(0) x scalar(@Rinten)];
    my $ry = pdl ($ra,\@Rinten,$ra)->xchg(0,1)->clump(2);
    my $rh = {Color => 14};
    $win -> line ($rx,$ry,$rh);

    my $bx = pdl (\@Bmass,\@Bmass,\@Bmass)->xchg(0,1)->clump(2);
    my $ba = [(0) x scalar(@Binten)];
    my $by = pdl ($ba,\@Binten,$ba)->xchg(0,1)->clump(2);
    my $bh = {Color => $redcol};
    $win -> line ($bx,$by,$bh);

    my $yx = pdl (\@Ymass,\@Ymass,\@Ymass)->xchg(0,1)->clump(2);
    my $ya = [(0) x scalar(@Yinten)];
    my $yy = pdl ($ya,\@Yinten,$ya)->xchg(0,1)->clump(2);
    my $yh = {Color => $bluecol};
    $win -> line ($yx,$yy,$yh);

    my $byx = pdl (\@BYmass,\@BYmass,\@BYmass)->xchg(0,1)->clump(2);
    my $bya = [(0) x scalar(@BYinten)];
    my $byy = pdl ($bya,\@BYinten,$bya)->xchg(0,1)->clump(2);
    my $byh = {Color => $grcol};
    $win -> line ($byx,$byy,$byh);

    return ($win,\@Bmaxinten,\@Ymaxinten);
}


###############################################################################
# LabelResidues
###############################################################################
sub LabelResidues {
    my %args = @_;

    my $Ionmasses_ref = $args{'Ionmasses'};
    my $Bdata = pdl $Ionmasses_ref->{Bions};
    my $Ydata = pdl $Ionmasses_ref->{Yions};
    my $charge = $args{'Charge'};
    my $win = $args{'Win'};
    my $Binten_ref = $args{'Binten'};
    my @Binten = @$Binten_ref;
    my $Yinten_ref = $args{'Yinten'};
    my @Yinten = @$Yinten_ref;
    my $length = $args{'Length'};
    my $labht;
    my $angle = $args{'Angle'} || 0;
    my $fjust = $args{'Fjust'};
    my ($Bcol,$Ycol,$bothcol);
    my $i;
    my ($lineclr,$redcol,$bluecol,$grcol);
    my $Ymax = $args{'Ymax'};
    my $Xmin = $args{'Xmin'};
    my $Xmax = $args{'Xmax'};
    my $interval = $Ymax / 50.0;
    my $xshift = ($Xmax - $Xmin) / 200.0;

    #### Define pink color to be lightcoral
    pgscr 6,0.94,0.5,0.5;

    #### Define lt. blue color to be navy
    pgscr 11,0,0,.5;

    #### Define lt. green color to be DarkSeaGreen
    pgscr 10,0.56,0.74,0.56;

    #### Define red color to be lightcoral
    pgscr 2,1,0,0;

    #### Define blue color to be navy
    pgscr 4,0,0,1;

    #### Define green color to be DarkSeaGreen
    pgscr 3,0.13,0.55,0.13;

    if ($charge == 1) {
      $redcol = 2;
      $bluecol = 4;
      $grcol = 3;
    } else {
      $redcol = 6;
      $bluecol = 11;
      $grcol = 10;
    }

    # For each residue in the peptide ...
    for ($i=0; $i < $length; $i++) {
      # If there is a peak here that is identified as a B-ion ...
      if (($Binten[$i] != 0) && ($i != ($length-1))) {
        my $val = $Ionmasses_ref->{indices}->[$i];
        ++$val;
        my $index = "B$charge\-$val";
        my $mass = $Bdata->at($i);
        my $matchx = pdl [$mass, $mass];
        my $y = $Binten[$i];
        my $matchy = pdl [$y+($interval/3.), $y+4*($interval/3.)];
        my $Yind = which($Ydata >= ($mass-2) & $Ydata <= ($mass+2));
        if ($Yind !~ 'Empty') {
          #### Green text and line for both ion match
          pgsci $grcol;
          $lineclr = $grcol;

          #### Location of label above tick mark (moved up)
          $labht = $y+8.5*($interval/3.);
        } else {
          #### Red text and line for B ion match
          pgsci $redcol;
          $lineclr = $redcol;

          #### Location of label above tick mark
          $labht = $y+5*($interval/3.);
        }
        #### Plot ion marker line
        $win -> line($matchx, $matchy, {Color=>$lineclr});
        $win -> hold;

        #### Add ion label
        pgptext $mass+$xshift,$labht,$angle,$fjust,"$index"
          if (($labht < $Ymax) && ($mass > $Xmin) && ($mass < $Xmax));
      }


      # If there is a peak here that is identified as a Y-ion ...
      if (($Yinten[$i] != 0) && ($i != 0)) {
        my $index = "Y$charge\-$Ionmasses_ref->{rev_indices}->[$i]";
        my $mass = $Ydata->at($i);
        my $matchx = pdl [$mass, $mass];
        my $y = $Yinten[$i];
        my $matchy = pdl [$y+($interval/3.), $y+4*($interval/3.)];
        my $Bind = which($Bdata >= ($mass-2) & $Bdata <= ($mass+2));
        if ($Bind !~ 'Empty') {
          #### Green text and line for both ion match
          pgsci $grcol;
          $lineclr = $grcol;

          #### Location of label above tick mark
          $labht = $y+5*($interval/3.);
        } else {
          #### Blue text and line for Y ion match
          pgsci $bluecol;
          $lineclr = $bluecol;

          #### Location of label above tick mark
          $labht = $y+5*($interval/3.);
        }
        #### Plot ion marker line
        $win -> line($matchx, $matchy, {Color=>$lineclr});
        $win -> hold;

        #### Add ion label
        pgptext $mass+$xshift,$labht,$angle,$fjust,"$index"
          if (($labht < $Ymax) && ($mass > $Xmin) && ($mass < $Xmax));
      }
    }

    return $win;
}

###############################################################################
# LabelUnidentifiedPeaks
###############################################################################
sub LabelUnidentifiedPeaks {
    my %args = @_;

    my $win = $args{'Win'};
    my $specdata = $args{'SpecData'};
    my $mz_threshold_factor = $args{'MZ_threshold'} || 0.1;

    my $labht;
    my $angle = $args{'Angle'} || 0;
    my $fjust = $args{'Fjust'};
    my $i;
    my $lineclr;
    my $Ymax = $args{'Ymax'};
    my $Xmin = $args{'Xmin'};
    my $Xmax = $args{'Xmax'};
    my $interval = $Ymax / 50.0;
    my $xshift = ($Xmax - $Xmin) / 200.0;

    my $mz_intens_threshold = $Ymax*$mz_threshold_factor;

    # For each unidentified peak above threshold intensity ...
    # (or far from any other peak)
    for (my $i = 0; $i < $specdata->{n_peaks}; $i ++) {
      # is this peak close to any other peaks?
      my $mass = $specdata->{masses}->[$i];
      my $prev_mz = $Xmin;
      my $next_mz = $Xmax;
      my $too_close;
      $prev_mz = $specdata->{masses}->[$i-1] if ($i > 0);
      $next_mz = $specdata->{masses}->[$i+1]
                      if ($i < $specdata->{n_peaks}-1);
      my $breathing_room = $xshift * 6.0;
      $too_close = (($mass - $prev_mz < $breathing_room) ||
                    ($next_mz - $mass < $breathing_room));

      my $y = $specdata->{intensities}->[$i];
      if (((! defined $specdata->{identified}->[$i]) ||
          ($specdata->{identified}->[$i] != 1 )) &&
          (($y > $mz_intens_threshold) || ! $too_close )) {
        my $label = sprintf ("%0.1f", $mass);
        my $matchx = pdl [$mass, $mass];
        my $y = $specdata->{intensities}->[$i];
        my $matchy = pdl [$y+($interval/3.), $y+4*($interval/3.)];
	pgsci 14;  #black
	$lineclr = 14;
	#### Location of label above tick mark
	$labht = $y+5*($interval/3.);
        #### Plot marker line
        $win -> line($matchx, $matchy, {Color=>$lineclr});
        $win -> hold;
        #### Add m/z label
        pgptext $mass+$xshift,$labht,$angle,$fjust,"$label"
          if (($labht < $Ymax) && ($mass > $Xmin) && ($mass < $Xmax));
      }
    }
    return $win;
}

###############################################################################
# Fragment
###############################################################################
sub Fragment {
    my $peptide = shift;
    my $length = length($peptide);
    my @residues = ();
    my $i;

    for ($i=0; $i<$length; $i++) {
      if (substr($peptide,$i+1,1) eq '[') {
        push (@residues, substr($peptide,$i,6));
        $i = $i + 5;
      } elsif (substr($peptide,$i+1,1) =~ /\W/) {
        push (@residues, substr($peptide,$i,2));
        $i = $i + 1;
      } else {
        push (@residues, substr($peptide,$i,1));
      }
    }

    #### Return residue array
    return @residues;
}

###############################################################################
# CalcIons
#  given a charge and a peptide, compute the predicted B and Y ion masses
###############################################################################
sub CalcIons {
    my %args = @_;

    my $residues_ref = $args{'Residues'};
    my @residues = @$residues_ref;
    my $charge = $args{'Charge'} || 1;
    my $massarray_ref = $args{'MassArray'};
    my %massarray = %$massarray_ref;
    my $length = scalar(@residues);
    my @modified_residues;

    my $Nterm = 1.0078;
    my $Yterm  = 19.0184;  ## H_2 + O
    my $Bion = 0.;
    my $Yion  = $Yterm;

    my @Bcolor = (14) x $length;
    my @Ycolor = (14) x $length;

    my $start = 0;
    my $i;

    #### If we start with a custom N-terminal mass, such as n[43]A
    ####  Bug fixed here TMF 10/12/10
    if ($residues[0] =~ /n\[(\d+)\](\w)/) {
      #$start = 1;
      my $massTag = $residues[0];
      my $integerMass = $1;
      # initialze $Bion to this N-terminal mass
      if ($massCalculator->{supported_modifications}->{average}->{$massTag}) {
	$Bion += $massCalculator->{supported_modifications}->{average}->{$massTag};
      } else {
	$Bion = $integerMass;
      }
      #$length--;
      # Strip the n[xx] from the string for this residue
      $residues[0] = $2;
    }

    my @masses;

    ### For each amino acid residue ...
    for ($i=0; $i<$length; $i++) {

      ### get the mass
      my $massTag = $residues[$i+$start];
      my $mass = $massarray{$massTag};
      unless ($mass) {
	if ($residues[$i+$start] =~ /\w\[(\d+)\]/) {
	  my $integerMass = $1;
	  if ($massCalculator->{supported_modifications}->{average}->{$massTag}) {
	    $mass = $massarray{substr($massTag,0,1)};
	    $mass += $massCalculator->{supported_modifications}->{average}->{$massTag};
	  } else {
	    $mass = $integerMass;
	  }
	} else {
	  print "WARNING: Unable to find mass for residues[$i]<BR>\n";
	}
      }

      ### ... and store it in an array
      $masses[$i] = $mass;
      $modified_residues[$i] = $massTag;
      $Yion += $mass;
    }

    ### Now, $Yion is the sum of all the masses, plus water, and $Bion
    ### is zero (or mass of N-terminal modification).
    my %masslist;
    my (@aminoacids, @indices, @rev_indices, @Bions, @Yions);

    #### Compute the ion masses. March down the peptide and get the B
    #### and Y ion masses.
    for ($i=0; $i<$length; $i++) {

      #### Get the Bion and Yion masses by adjusting the previous values
      $Bion += $masses[$i];
      $Yion -= $masses[$i-1] if ($i > 0);

      #### B index & Y index
      $indices[$i] = $i;
      $rev_indices[$i] = $length-$i;

      #### Store the B ion mass & Y ion m/z (NOT mass) in an array
      $Bions[$i] = ($Bion + $charge*$Nterm)/$charge;
      #$Yions[$i] = ($Yion + $charge*$Nterm)/$charge;
      $Yions[$i] = ($Yion + $charge*0.0)/$charge;
    }

    $masslist{residues} = \@modified_residues; #array of one-letter
        #amino acid code plus a mass mod in brackets (?)
    $masslist{indices} = \@indices;  # simply 1 through length
    $masslist{Bions} = \@Bions;  #m/z values
    $masslist{Yions} = \@Yions;  #m/z values
    $masslist{rev_indices} = \@rev_indices;  #simply the reverse of indices
    $masslist{length} = $length; #peptide length

    #### Return reference to a hash of array references
    return (\%masslist);
}

###############################################################################
# printIons
###############################################################################
sub printIons {
  my %args = @_;

  my $masslist_ref = $args{'masslist_ref'};
  my $color = $args{'color'} || 0;
  my $html = $args{'html'} || 0;
  my $charge = $args{'charge'};
  my $length = $args{'length'};
  my $theoretical_spectrum_ref = $args{'theoretical_spectrum_ref'};

  my $buffer = '';

  $buffer .= "Residue  ion     B       Y      ion   +$charge\n";
  $buffer .= "------  -----  ------  ------  -----\n";

  my ($bcolbegin, $bcolend, $ycolbegin, $ycolend);

  my %colors;
  $colors{2} = "#FF0000";
  $colors{4} = "#0000FF";
  $colors{3} = "#218D21";
  $colors{6} = "#F18080";
  $colors{11} = "#00088";
  $colors{10} = "#8FBE8F";


  #### Printing stuff
  for (my $i=0; $i < $length; $i++) {

    #### If the output is in HTML, define the colorizing tags
    if ($html) {

      #### If a color for this B ion mass, set color tags
      if ($masslist_ref->{Bcolor}->[$i] >= 2) {
        $bcolbegin = "<FONT COLOR = $colors{$masslist_ref->{Bcolor}->[$i]}>";
        $bcolend = "</FONT>";
      #### else no color (default black)
      } else {
        $bcolbegin = "";
        $bcolend = "";
      }

      #### If a color for this Y ion mass, set color tags
      if ($masslist_ref->{Ycolor}->[$i] >= 2) {
        $ycolbegin = "<FONT COLOR = $colors{$masslist_ref->{Ycolor}->[$i]}>";
        $ycolend = "</FONT>";
      #### else no color (default black)
      } else {
        $ycolbegin = "";
        $ycolend = "";
      }

    }


    #### Define the m/z columns formats and values
    my $B_format = '%7.1f';
    my $Y_format = '%7.1f';
    my $B_value = $masslist_ref->{Bions}->[$i];
    my $Y_value = $masslist_ref->{Yions}->[$i];


    #### Special case --'s for first row
    if ($i == 0) {
      $Y_format = '%7s';
      $Y_value = '--  ';

    #### Special case --'s for last row
    } elsif ($i == ($length-1)) {
      $B_format = '%7s';
      $B_value = '--  ';
    }

    #### Print out the data
    $buffer .= sprintf("%6s  %5s $bcolbegin$B_format$bcolend ".
      "$ycolbegin$Y_format$ycolend  %5s\n",
      $masslist_ref->{residues}->[$i], "B$charge-".($i+1),
      $B_value, $Y_value, "Y$charge-".($length-$i));

    #### Fill the theoretical spectrum data in a different format
    #### (Residue,Index,Ion,Charge,m/z)
    $theoretical_spectrum_ref->[2*$length*($charge-1)+$i] =
      [$masslist_ref->{residues}->[$i],$i+1,'B',$charge,$B_value];
    $theoretical_spectrum_ref->[2*$length*($charge-1)+2*$length-1-$i] =
      [$masslist_ref->{residues}->[$i],$length-$i,'Y',
      $charge,$Y_value];


  } # end for

  $buffer .= "\n";

  return $buffer;

} # end printIons


###############################################################################
# printUserAnnotations
# get and display user annotations, if any
###############################################################################
sub printUserAnnotations {
    my %args = @_;

    my $buffer;
    my $total = 0; # this starts as a counter, then becomes a string
    my $show_form = 1;
    my $line_sep = "<tr><td colspan='2'><hr size='1' noshade></td></tr>";

    my $sql = qq~
	SELECT SA.spectrum_annotation_id, SA.comment, SA.date_modified,
	       SA.spectrum_identification_id, SA.identified_peptide_sequence, SA.identified_peptide_charge,
	       SL.spectrum_annotation_level_id, SL.level_name,
	       C.first_name, C.last_name,
	       UL.username
	  FROM $TBAT_SPECTRUM_ANNOTATION SA
    INNER JOIN $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
            ON ( SA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
    INNER JOIN $TB_CONTACT C
            ON ( annotator_contact_id = C.contact_id )
    INNER JOIN $TB_USER_LOGIN UL
            ON ( UL.contact_id = annotator_contact_id )
	 WHERE spectrum_id = '$args{spectrum_id}'
	   AND SA.record_status = 'N'
      ORDER BY SA.date_modified DESC
        ~;

    my @rows = $sbeams->selectSeveralColumns($sql);

    $buffer = qq~
	<table width="100%" class="table_setup">
	<tr class="orange_bg"><th>User annotations</th><td><a name="user_annotations">&nbsp;</a></td></tr>
	~;

    if (@rows) {
	foreach my $row (@rows)
	{
	    my ($annot_id, $comment, $date, $ident_id, $sequence, $charge, $level_id, $level, $first, $last, $uname) = @{$row};
	    $total++;

	    if ($args{modified_sequence}.$args{charge} eq $sequence.$charge) {
		$buffer .= "<tr id='${uname}${annot_id}_annot_tr'><th valign='top'>$level</th><td>$first $last ($date)<br />\n";
	    } else {
		my $link = $q->self_url();
		$link =~ s/\?.*//;  # clear querystring
		$link .= "?spectrum_identification_id=$ident_id;peptide=$sequence;assumed_charge=$charge";

		$buffer .= "<tr bgcolor='#dddddd' id='${uname}${annot_id}_annot_tr'><th valign='top'>$level<br /><a href='$link' style='color:red'>$sequence +$charge</a></th><td>$first $last ($date)<br />\n";
	    }

	    my $disp_comment = $comment;
	    $disp_comment =~ s|\n|<BR />\n|g; # display carriage returns
	    $buffer .= "$disp_comment\n";

	    if ( ($uname eq $current_username) &&
		 ($args{modified_sequence}.$args{charge} eq $sequence.$charge) ) {
		$show_form = 0;

		$buffer .= qq~
		    <br /><div align='right'><a href='javascript:showEditForm();'>Edit my annotation</a> | <a href='javascript:confirm_delete();'>Delete</a>
		    <FORM NAME="delete_annotation" METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
		    $args{form_fields}
		    <INPUT TYPE='hidden' NAME='spectrum_annotation_id' VALUE='$annot_id'>
   		    <INPUT TYPE='hidden' NAME='apply_action' VALUE='DELETE ANNOTATION'></FORM>
		    </div>
		    ~;

		$buffer .= "</td></tr>\n";

		$buffer .= &printUserAnnotationsForm(
						     form_type => 'update',
						     uname => $uname,
						     default_level_id => $level_id,
						     default_comment => $comment,
						     annot_id => $annot_id,
						     extra_form_fields => $args{form_fields}
						     );
	    }

	    $buffer .= "</td></tr>\n$line_sep\n";
	}

    } else {
	$buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td class='section_heading'>There are no user annotations for this spectrum<br /></td></tr>
	    $line_sep
	    ~;
    }


    if ($current_username eq 'guest') {
	my $url = $q->self_url();
	$url .= '&force_login=yes';

	$buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td><a href='$url'>Log into PeptideAtlas</a> to add an annotation for this spectrum<br /></td></tr>
	    $line_sep
	    ~;

    } elsif ($show_form) {
	$buffer .= "<tr id='${current_username}add_annot_tr'><th valign='top'><a href='javascript:showEditForm();'>Add annotation</a></th><td>&nbsp;</td></tr>\n";

	$buffer .= &printUserAnnotationsForm(
					     form_type => 'add',
					     uname => $current_username,
					     spectrum_id => $args{spectrum_id},
					     extra_form_fields => $args{form_fields}
					     );

	$buffer .= "</td></tr>\n$line_sep\n";
    }

    $buffer .= "</table>\n";

    # get average
    $sql = qq~
 	SELECT ROUND(AVG(SL.level_probability)*100,0) AS avg_prob_pct,
	       COUNT(*)
	  FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
    INNER JOIN $TBAT_SPECTRUM_ANNOTATION SA
            ON ( SA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
	 WHERE spectrum_id = '$args{spectrum_id}'
	   AND identified_peptide_sequence = '$args{modified_sequence}'
	   AND identified_peptide_charge = '$args{charge}'
	   AND SA.record_status = 'N'
        ~;

    @rows = $sbeams->selectSeveralColumns($sql);

    my ($avg, $num) = @{$rows[0]};
    if ($total != $num) {
	$total = "($total total)";
    } else {
	$total = '';
    }

    my $innerHTML;

    if ($num == 1) {
	$innerHTML = "There is <a href=\"#user_annotations\">one user annotation</a> $total for this spectrum, with a score of <b>$avg%</b>";
    } elsif ($num > 1) {
	$innerHTML = "There are <a href=\"#user_annotations\">$num user annotations</a> $total for this spectrum, with an average score of <b>$avg%</b>";
    }

    $buffer .=<< "EOJS" if $innerHTML;
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
    document.getElementById("annotations_summary").innerHTML = '$innerHTML';
    document.getElementById("annotations_head").style.display = 'table-row';
</SCRIPT>
EOJS

    return $buffer;
}


###############################################################################
# printUserAnnotationsForm
# get and display user annotations, if any
###############################################################################
sub printUserAnnotationsForm {
    my %args = @_;

    $args{form_type} ||= 'add';
    $args{uname} ||= 'user_anon';
    $args{default_level_id} ||= 0;
    $args{default_comment} ||= '';
    $args{annot_id} ||= 0;
    $args{extra_form_fields} ||= '';

    my $spacer = "&nbsp;"x5;

    my $trname = $args{uname};
    $trname .= ($args{form_type} eq 'add') ? 'add' : $args{annot_id};

    my $buffer = qq~
	<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
	<!--
	function showEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'none';
	    document.getElementById('${trname}_form_tr').style.display = 'table-row';
	}
        function hideEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'table-row';
	    document.getElementById('${trname}_form_tr').style.display = 'none';
	}

        function confirm_delete() {
	    var del = confirm("Are you sure you want to delete your comment?");
	    if (del==true) {
		document.delete_annotation.submit();
	    }
	}
        // -->
	</SCRIPT>
	~;

    # add a hidden <tr> for edit form
    my $sql = qq~
	SELECT spectrum_annotation_level_id, level_probability, level_name, level_description
	FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL
	WHERE record_status = 'N'
	ORDER BY sort_order
	~;

    my @levels = $sbeams->selectSeveralColumns($sql);

    my $select = "<SELECT NAME='user_spectrum_annotation'>\n";
    foreach my $levrow (@levels)
    {
	my ($lev_id, $lev_prob, $lev_name, $lev_desc) = @{$levrow};

	my $sel = ( "$args{default_level_id}" eq "$lev_id" ) ? 'SELECTED' : '';
	my $desc = $sbeams->escapeXML(value => $lev_desc);

	$select .= "<OPTION TITLE='$desc' VALUE='$lev_id' $sel>$lev_name</OPTION>\n";
    }
    $select .= "</SELECT>";

    my $form_action = "ADD";
    if ($args{form_type} eq 'update') {
	$form_action = "UPDATE";
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='spectrum_annotation_id' VALUE='$args{annot_id}'>";

    } else {
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='spectrum_id' VALUE='$args{spectrum_id}'>";
    }

    $buffer .= qq~
	<tr style='display:none' id='${trname}_form_tr'>
	<th valign='top'>
	<FORM METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
	$args{extra_form_fields}
	$select</th>
	<td><TEXTAREA ROWS='6' COLS='80' NAME='user_spectrum_commment'>$args{default_comment}</TEXTAREA><br />
	<div align='right'><INPUT TYPE='submit' NAME='apply_action' VALUE='$form_action ANNOTATION'>$spacer<a class='small_form_field' href='javascript:hideEditForm();'>CANCEL</a></div>
	~;

    # caller will close the td and tr
    return $buffer;

}
