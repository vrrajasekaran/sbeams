#!/usr/local/bin/perl

###############################################################################
# Program     : ShowObservedSpectrum
#
# Description : This CGI program displays a single spectrum in PeptideAtlas
#
# Based upon the ShowSpectrum.cgi in the Proteomics module by
# Kerry & Eric Deutsch
#
###############################################################################


###############################################################################
# Basic SBEAMS setup
###############################################################################
use strict;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($q $sbeams $sbeamsMOD $PROG_NAME
             $current_username $massCalculator $TESTONLY $VERBOSE );

use SBEAMS::Connection qw($q);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;
use SBEAMS::PeptideAtlas::PeptideFragmenter;

use SBEAMS::Proteomics::Tables;
use SBEAMS::Proteomics::PeptideMassCalculator;
use SBEAMS::Proteomics::SpecViewer;
use SBEAMS::PeptideAtlas::ProtInfo;

use File::Basename;
use Data::Dumper;

use lib "/net/db/projects/Proteomics/lib";
#use lib "/net/db/projects/Proteomics/devED/lib";
use Proteomics::Spectra::UniversalSpectrumIdentifier;
use Proteomics::Response qw(processParameters);
use Proteomics::Config;
use Proteomics::Spectra::Spectrum;

use Carp;
$SIG{__DIE__} = sub { &Carp::confess };
use CGI::Carp qw (fatalsToBrowser);

#$q = new CGI;
$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);

$PROG_NAME="ShowObservedSpectrum";
my $CLASS = $PROG_NAME;
my $DEBUG = 0;
my $VERBOSE = 0;

# Allowable neutral losses
my @neutral_loss_masses = ();

###############################################################################
# Define global variables if any and execute main()
###############################################################################
main();


###############################################################################
# Main Program:
#
# If $sbeams->Authenticate() succeeds, print header, process the CGI request,
# print the footer, and end.
###############################################################################
sub main {

  #### Do the SBEAMS authentication and exit if a username is not returned
  exit unless ($current_username = $sbeams->Authenticate(
    permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
      'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
    #connect_read_only=>1,
    allow_anonymous_access=>1,
  ));


  #### Process certain actions, then print the header, figure and do what the user wants, and print footer
  processDatabaseActions();
  $sbeamsMOD->display_page_header();
  processRequest();
  $sbeamsMOD->display_page_footer();

  $sbeams->display_page_footer(close_tables=>'YES',
    separator_bar=>'YES',display_footer=>'NO');

} # end main


###############################################################################
# Process insert/update/delete, if any, then redirect
###############################################################################
sub processDatabaseActions {
    my $redirect = 0;
    my %parameters;

    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);
    $sbeams->processStandardParameters(parameters_ref=>\%parameters);

    my $apply_action  = $q->param('apply_action');

    my $prot_info = new SBEAMS::PeptideAtlas::ProtInfo;
    $VERBOSE = 0;
    $TESTONLY = 0;
		$prot_info->setSBEAMS($sbeams);
		$prot_info->setVERBOSE($VERBOSE);
		$prot_info->setTESTONLY($TESTONLY);

    ## get original value 
    my $orig_spectrum_annotation_level = 0; 
    if($parameters{spectrum_annotation_id}){
      my $spectrum_annotation_id = $parameters{spectrum_annotation_id};
      my $sql = qq~ 
        SELECT max(spectrum_annotation_level_id)
        FROM $TBAT_SPECTRUM_ANNOTATION 
        WHERE spectrum_annotation_id = $spectrum_annotation_id
      ~;
      my @result = $sbeams->selectOneColumn($sql);
      $orig_spectrum_annotation_level = $result[0];
    }
    if ($apply_action eq "UPDATE ANNOTATION") {
			my %rowdata = (
		       spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
		       comment => $parameters{user_spectrum_commment}
		       );
			my $PK = $sbeams->updateOrInsertRow(
					    update => 1,
					    table_name => $TBAT_SPECTRUM_ANNOTATION,
					    rowdata_ref => \%rowdata,
					    PK => 'spectrum_annotation_id',
					    PK_value => $parameters{spectrum_annotation_id},
					    return_PK => 1,
					    add_audit_parameters => 1
					    );

			if ($PK) { 
        my $action = '';
        if ($orig_spectrum_annotation_level <= 2 && $parameters{user_spectrum_annotation} > 2 ){
				  $action = 'remove';
        }elsif($orig_spectrum_annotation_level > 2 && $parameters{user_spectrum_annotation} <= 2 ){
           $action = 'add';
        }
        if($action){
					$prot_info -> update_protInfo (
						spectrum_annotation_id => $parameters{spectrum_annotation_id}, 
						atlas_build_id=>$parameters{atlas_build_id},
						action => $action);
        }
        $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been updated." ); 
      }
			else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem updating your annotation record." ); }

			$redirect++;
    } elsif ($apply_action eq "ADD ANNOTATION") {
			my %rowdata = (
		       annotator_contact_id => $sbeams->getCurrent_contact_id(),
		       spectrum_identification_id => $parameters{spectrum_identification_id},
		       spectrum_id => $parameters{spectrum_id},
		       identified_peptide_sequence => $parameters{peptide},
		       identified_peptide_charge => $parameters{assumed_charge},
		       spectrum_annotation_level_id => $parameters{user_spectrum_annotation},
		       comment => $parameters{user_spectrum_commment}
		       );

			my $PK = $sbeams->updateOrInsertRow(
				   insert => 1,
				   table_name => $TBAT_SPECTRUM_ANNOTATION,
				   rowdata_ref => \%rowdata,
				   return_PK => 1,
				   add_audit_parameters => 1
				   );

			if ($PK) { 
        if ($parameters{user_spectrum_annotation} > 2 ){
					$prot_info -> update_protInfo (
						spectrum_annotation_id => $PK,
						atlas_build_id=>$parameters{atlas_build_id},
						action => 'remove',
          );
        }
        $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been added." ); 
      }
			else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem inserting your annotation record." ); }

			$redirect++;

    } elsif ($apply_action eq "DELETE ANNOTATION") {
			my %rowdata = (
		       record_status => 'D'
		       );

			my $PK = $sbeams->updateOrInsertRow(
					    update => 1,
					    table_name => $TBAT_SPECTRUM_ANNOTATION,
					    rowdata_ref => \%rowdata,
					    PK => 'spectrum_annotation_id',
					    PK_value => $parameters{spectrum_annotation_id},
					    return_PK => 1,
					    add_audit_parameters => 1
					    );

			if ($PK) { 
        ## annotation has low value, need to add back obs
        if ($orig_spectrum_annotation_level > 2){
					$prot_info -> update_protInfo (
						spectrum_annotation_id => $PK,
						atlas_build_id=>$parameters{atlas_build_id},
						action => 'add',
					);
        }
        $sbeams->set_page_message( type => 'Info',  msg => "Your annotation record has been deleted." ); 
      }
			else     { $sbeams->set_page_message( type => 'Error', msg => "ERROR: There was a problem deleting your annotation record." ); }

			$redirect++;

		}

		if ($redirect) {
			$q->delete( 'apply_action' );
			print $q->redirect( $q->self_url() );
			exit;
		}

}


###############################################################################
# Process Request
###############################################################################
sub processRequest {

    #### Define some general variables
    my ($i,$element,$key,$value,$sql);

    #### Parse general parameters
    my %parameters;
    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);
    $sbeams->processStandardParameters(parameters_ref=>\%parameters);
    my $apply_action  = $q->param('apply_action');

    #$sbeams->printDebuggingInfo($q);

    #### Define the spectrum array. Need something fancier than this
    my @spectrum_array;
    my $charge = $parameters{assumed_charge};
    my $peptidoform = $parameters{peptide};
    my $scanNumber = 0;
    my $observedPrecursorMz = 0.0;
    my $spectrumName = '';

    #### If a Universal Spectral Identifier is supplied, interpret it
    my $usiStr = $q->param('USI') || $q->param('usi');
    if ( $usiStr ) {
      my $result = interpretUSI( usiStr=>$usiStr, outputDestination=>'STDOUT' );
      if ( $result->{status} eq 'OK' ) {
        $peptidoform = $result->{peptidoform} if ( $result->{peptidoform} );
        $charge = $result->{charge} if ( $result->{charge} );
	$spectrumName = $usiStr;
	my $filePath = $result->{mzMLFilePath};
	$scanNumber = $result->{index};
	my $getSpectrumResult = getSpectrumFromMzmlFile( filePath=> $filePath, scanNumber=>$scanNumber, verbose=>0, debug=>0, quiet=>0, outputDestination=>'STDOUT' );
	if ( $getSpectrumResult->{status} eq 'OK' ) {
	  @spectrum_array = @{$getSpectrumResult->{mz}};
	  $observedPrecursorMz = $getSpectrumResult->{observedPrecursorMz};
        } else {
	  print "ERROR: Unable to read peaks.\n";
          return;
        }
      } else {
        print "ERROR: Unable to provide USI $usiStr\n";
        return;
      }

    } 


    #### If we have a spectrum_id, find the mass modifications
    if ($parameters{'spectrum_identification_id'}) {
      unless ($parameters{'atlas_build_id'}) {
        print "ERROR: need atlas_build_id parameter.\n";
        return;
      }
      my $sql = qq~
            SELECT peptide_sequence,peptide_charge,monoisotopic_parent_mz,
                   MPI.modified_peptide_sequence,
	           S.spectrum_id, S.spectrum_name, S.start_scan, S.fragmentation_type_id
              FROM $TBAT_SPECTRUM_IDENTIFICATION SI
              JOIN $TBAT_MODIFIED_PEPTIDE_INSTANCE MPI
                   ON ( SI.modified_peptide_instance_id = MPI.modified_peptide_instance_id )
              JOIN $TBAT_PEPTIDE_INSTANCE PI
                   ON ( MPI.peptide_instance_id = PI.peptide_instance_id )
             INNER JOIN $TBAT_PEPTIDE P
                   ON ( PI.peptide_id = P.peptide_id )
              LEFT JOIN $TBAT_SPECTRUM S
                   ON ( SI.spectrum_id = S.spectrum_id )
            WHERE spectrum_identification_id = '$parameters{spectrum_identification_id}'
      ~;

      my @rows = $sbeams->selectSeveralColumns($sql);

      foreach my $row (@rows) {
	my ($seq, $chg, $mz, $mod_seq, $spectrum_id, $spectrum_name, $start_scan,$fragmentation_type_id) = @{$row};
	$peptidoform = $mod_seq unless ( $peptidoform );
	$charge = $chg;
	$observedPrecursorMz = $mz;
	$parameters{'spectrum_id'} = $spectrum_id;
	$spectrumName = $spectrum_name;
	$scanNumber = $start_scan;
	$parameters{'fragmentation_type_id'} = $fragmentation_type_id;
      }

      #### Try to determine the USI for this spectrum
      my $sql = qq~
            SELECT sample_accession,repository_identifiers
              FROM $TBAT_SPECTRUM_IDENTIFICATION SI
              JOIN $TBAT_SPECTRUM SPEC
                   ON ( SI.spectrum_id = SPEC.spectrum_id )
              JOIN $TBAT_SAMPLE S
                   ON ( SPEC.sample_id = S.sample_id )
            WHERE spectrum_identification_id = '$parameters{spectrum_identification_id}'
      ~;

      @rows = $sbeams->selectSeveralColumns($sql);

      #print "sample_accession \t repository_identifiers<BR>\n";
      my ($sample_accession,$repository_identifiers);
      foreach my $row ( @rows ) {
	#print join("\t",@{$row})."<BR>\n";
	($sample_accession,$repository_identifiers) = @{$row};
      }

      if ( $repository_identifiers ) {
	#print "try to parse $repository_identifiers<BR>\n";
	my $datasetIdentifier = '';
	my @identifiers = split("[,;]",$repository_identifiers);
	foreach my $identifier ( @identifiers ) {
	  next if ( $identifier =~ /RPXD/ );
	  if ( $identifier =~ /(PXD\d+)/ ) {
	    $datasetIdentifier = $1;
	    my $msrunName = $spectrumName;
	    $msrunName =~ s/\.\d+\.\d+\.\d+$//;
	    $usiStr = "mzspec:$datasetIdentifier\:\:$msrunName:scan:$scanNumber:$peptidoform/$charge";
	    #print "USI=$usiStr<BR>\n";
	    $parameters{USI} = $usiStr;
	  }
        }
      }
    }


    #### Show the universal spectrum identifier input box
    my $htmlBuffer = getUSIInputForm( parameters => \%parameters );
    if ($sbeams->output_mode() eq 'html') {
      print $htmlBuffer;
    } else {
      print "Please specify the USI or PeptideAtlas spectrum_identification_id\n";
    }

    #### If there's no USI and no spectrum identifier, then just quietly finish after displaying the USI input form
    unless ( $usiStr || $parameters{'spectrum_identification_id'} ) {
      if ($sbeams->output_mode() eq 'html') {
        print "Please specify the desired Universal Spectrum Identifier above an click [VIEW]<BR>\n";
      }
      return;
    }

    #### If the user is specifying some alternate interpretations, switch to those
    # ToDo: should check these values for integrity
    $peptidoform = $parameters{alt_sequence} if ( $parameters{alt_sequence});
    $charge = $parameters{'alt_charge'} if ( $parameters{'alt_charge'} );

    #### Display the header
    if ( $peptidoform ) {
      print "<H2 CLASS=section_description ALIGN=CENTER>Spectrum for $peptidoform <SUP>+$charge</SUP></H2>\n";
      print '<h3 ID="annotations_head" style="display:none"><div ID="annotations_summary" COLSPAN="2">-- No annotations here --</div></h3>';
    }

    # still some lint here...
    #my $precursor_mass = $parameters{'precursor_mass'};


    #### If we don't already have the spectrum
    my $proteomics_search_batch_id = -1;
    unless ( @spectrum_array ) {

      #### Get the peak list for this spectrum
      my %spectrum;
      ($proteomics_search_batch_id, %spectrum) = get_spectrum(
        spectrum_identification_id => $parameters{spectrum_identification_id},
        atlas_build_id => $parameters{atlas_build_id},
        parameters => \%parameters,
      );

      #### If the spectrum did not come back, then we error out
      unless (%spectrum) {
        print "ERROR: Unable to load spectrum\n";
        return;
      }

      my ($i,$mass,$intensity,$massmin);
      my ($massmax,$intenmax)=(0,0);

      #### Build a Lorikeet-ready mass,intensity pair array for Lorikeet
      for ($i=0; $i<$spectrum{n_peaks}; $i++) {
        $mass = $spectrum{mz}->[$i];
        $intensity = $spectrum{intensities}->[$i];
        push(@spectrum_array,[$mass,$intensity]);
        $massmin = $mass if ($i == 0);
        $massmax = $mass if ($mass > $massmax);
        $intenmax = $intensity if ($intensity > $intenmax);
      }

    }

    ### Run the heuristic PSM evaluator if requested
    if ($parameters{'eval'}) {
      print "<b>Heuristic PSM evaluation:</b><br>\n";

      #### Get the expected fragments for this peptide
      #### returns \@sortedProductIons where each ion is a hash ref
      #### with mz, series (e.g. y), ordinal, charge, label, label_st,
      #### bond (dipeptide)
      #### label has ^2 notation. label_st has ++ notation.
      my $fragmenter = new SBEAMS::PeptideAtlas::PeptideFragmenter;
      my $sortedProductIons_aref = $fragmenter->getExpectedFragments(
				modifiedSequence =>$peptidoform,
				charge=>$charge,
      );
      my @sortedProductIons = @{$sortedProductIons_aref};


      #### Get the observed fragments for this spectrum from the spectrast file.

      #### Get the data_location of the spectrum and raw speclib file
      use SBEAMS::PeptideAtlas::Spectrum;
      my $spectrum = new SBEAMS::PeptideAtlas::Spectrum;
      my $data_location = $spectrum->get_data_location( proteomics_search_batch_id => $proteomics_search_batch_id );
      ($data_location) = $spectrum->groom_data_location( data_location => $data_location );

      #### Get peaks and annotations from raw library text file, if exists
      use SBEAMS::PeptideAtlas::PSMEvaluator;
      my $evaluator = new SBEAMS::PeptideAtlas::PSMEvaluator;
      my @annotated_peaks = $evaluator->get_annotated_peaks_from_speclib(
				data_location => $data_location,
				spectrum_name => $parameters{spectrum_name},
      );

      #### Hand the expected and observed fragments to the heuristic PSM
      #### evaluator!!!
      if (scalar @annotated_peaks) {
				my $evaluation = $evaluator->evaluate_PSM_heuristically(
				annotated_peaks_aref => \@annotated_peaks,
				sorted_product_ions_aref => $sortedProductIons_aref,
				modified_sequence => $peptidoform,
				charge => $charge,
				);
				print "$evaluation<br>\n";
      } else {
				print "Cannot retrieve annotated peaks; cannot evaluate.<br>\n";
      }
    }

    #### Serialize the spectrum so that it can be parsed by the spectrum library parser
    #### This is wasteful. FIXME
    my @spectrumBuffer;
    push(@spectrumBuffer,"Name: $peptidoform/$charge");
    push(@spectrumBuffer,"PrecursorMZ: $parameters{'precursor_mass'}");
    push(@spectrumBuffer,"NumPeaks: ".scalar(@spectrum_array));
    foreach my $peak ( @spectrum_array ) {
      push(@spectrumBuffer,"$peak->[0]\t$peak->[1]\t?");
    }


    #### Print some debugging information
    if ( 0 == 1 ) {
      print "<PRE>\n";
      print "charge=$charge,\n";
      print "peptidoform = $peptidoform,\n";
      print "precursor_mass    = $parameters{'precursor_mass'},\n";
      print "scanNumber = $scanNumber\n";
      print "spectrumName = $spectrumName\n";
      #print Data::Dumper->Dump([\@spectrum_array]);
      print "</PRE>\n";
    }

    #### Since the Lorikeet spectrum viewer apparently can't display a raw spectrum, fake an identification
    unless ( $peptidoform ) {
      print "<BR><font color=\"red\">The Lorikeet spectrum viewer is currently unable to display a spectrum without any peptide ion interpretation. A temporary hack while we fix this is to set the sequence to 'MYSTERYPEPTIDE/2'</font><BR><BR>\n";
      $peptidoform = "MYSTERYPEPTIDE";
      $charge = 1;
    }


    #### Set up the default ion series settings to display
    my $series;
    if ( $charge == 1 ) {
      $series = '1,0,0';
    } elsif ( $charge == 2 ) {
      $series = '1,1,0';
    } else {
      $series = '1,1,1';
    }

    #### Process the spectrum with my own annotater
    my $spectrum = Proteomics::Spectra::Spectrum->new(peptideIon=>"$peptidoform/$charge");
    #### Read the spectrum in from the text buffer
    $spectrum->parseLibrarySpectrumEntry(buffer=>\@spectrumBuffer);
    $spectrum->reannotate( ppm => 1 );

    #### If requested, create a Javascript data buffer for the spectrum with my annotations
    my $jsSpectrumDataString;
    if ( $parameters{SAWB_annotation} && $parameters{SAWB_annotation} eq "Reannotated" ) {
      $jsSpectrumDataString  = $spectrum->display(format=>'Lorikeet');
      $series = '0,0,0';
    }

    #### For CID
    $parameters{'ShowA'} ||= "[$series]";
    $parameters{'ShowB'} ||= "[$series]";
    $parameters{'ShowC'} ||= '[0,0,0]';
    $parameters{'ShowX'} ||= '[0,0,0]';
    $parameters{'ShowY'} ||= "[$series]";
    $parameters{'ShowZ'} ||= '[0,0,0]';

    #### For HR IT ETD  and  LR IT ETD, show the c and z ions instead
    if ($parameters{'fragmentation_type_id'} == 2 || $parameters{'fragmentation_type_id'} == 6) {
      $parameters{'ShowA'} = '[0,0,0]';
      $parameters{'ShowB'} = '[0,0,0]';
      $parameters{'ShowC'} = "[$series]";
      $parameters{'ShowX'} = '[0,0,0]';
      $parameters{'ShowY'} = '[0,0,0]';
      $parameters{'ShowZ'} = "[$series]";
    }

    #### Create a SpecViewer object and generate a Lorikeet display
    if ( $peptidoform ) {
      my $lorikeet = new SBEAMS::Proteomics::SpecViewer;
      print $lorikeet->generateSpectrum(
          charge            => $charge,
          modified_sequence => $peptidoform,
          precursor_mass    => $observedPrecursorMz || 100,
          scan              => $scanNumber,
          name              => $spectrumName,
          a_ions            => $parameters{'ShowA'},
          b_ions            => $parameters{'ShowB'},
          c_ions            => $parameters{'ShowC'},
          x_ions            => $parameters{'ShowX'},
          y_ions            => $parameters{'ShowY'},
          z_ions            => $parameters{'ShowZ'},
          spectrum          => \@spectrum_array,
          selWinLow         => $parameters{selWinLow},
          selWinHigh        => $parameters{selWinHigh},
          ms1scanLabel      => $parameters{ms1scanLabel},
          ms1peaks          => $parameters{ms1peaks},
	      jsSpectrumDataString => $jsSpectrumDataString
        );
    } else {
      print "<BR><BR>The Lorikeet spectrum viewer is currently unable to display spectrum without any peptide ion interpretation. A temporary hack while we fix this is to set the sequence to 'PEPTIDE'<BR><BR>\n";
    }


    #### Store the observed spectrum data as a recallable resultset
    my %dataset;
    $dataset{data_ref} = \@spectrum_array;
    $dataset{column_list_ref} = ['m/z','intensity'];
    my $rs_set_name = "SETME";
    $sbeams->writeResultSet(resultset_file_ref=>\$rs_set_name,
      resultset_ref=>\%dataset,
      file_prefix=>'spec_',
      query_parameters_ref=>\%parameters
    );


    #### show hyperlinks for downloading the spectrum in various formats
    print qq~
        <BR>Download spectrum in Format: 
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$rs_set_name.tsv?rs_set_name=$rs_set_name&format=tsv">TSV</a>,
        <a href="$CGI_BASE_DIR/GetResultSet.cgi/$rs_set_name.xls?rs_set_name=$rs_set_name&format=excel">Excel</a>
        <BR><BR>
    ~;


    #### write hidden in HTML some important parameters that need to be preserved
    my $hidden_form_fields = qq~
        <INPUT TYPE="hidden" NAME="spectrum_identification_id" VALUE="$parameters{spectrum_identification_id}">
        <INPUT TYPE="hidden" NAME="atlas_build_id" VALUE="$parameters{atlas_build_id}">
        <INPUT TYPE="hidden" NAME="assumed_charge" VALUE="$parameters{assumed_charge}">
        <INPUT TYPE="hidden" NAME="peptide" VALUE="$parameters{peptide}">
        <INPUT TYPE="hidden" NAME="USI" VALUE="$usiStr">
    ~;

    print &printUserAnnotations(
			spectrum_id => $parameters{'spectrum_id'},
			modified_sequence => $peptidoform,
			charge => $parameters{'assumed_charge'},
			spectrum_identification_id => $parameters{'spectrum_identification_id'},
			form_fields => $hidden_form_fields
    ) if ($parameters{'spectrum_identification_id'});

    #### Display the spectrum analysis workbench
    spectrumAnalysisWorkbench(
      parameters => \%parameters,
      spectrum_array => \@spectrum_array,
      bufferedSpectrum => \@spectrumBuffer,
      peptideIon => "$peptidoform/$charge",
      hidden_form_fields => $hidden_form_fields,
    );

} # end processRequest


###############################################################################
# spectrumAnalysisWorkbench
###############################################################################
sub spectrumAnalysisWorkbench {
  my %args = @_;
  my $parameters = $args{parameters};
  my $peptideIon = $args{peptideIon};
  my $spectrum_array = $args{spectrum_array};
  my $bufferedSpectrum = $args{bufferedSpectrum};
  my $hidden_form_fields = $args{hidden_form_fields};

  #### Display the workbench controls
  displayWorkbenchControls(
    parameters => $parameters,
    hidden_form_fields => $hidden_form_fields,
  );

  #### Display the spectrum as a text peak list
  showSpectrumText(
    parameters => $parameters,
    spectrumBuffer => $bufferedSpectrum,
    peptideIon => $peptideIon,
  );

}


###############################################################################
# displayWorkbenchControls
###############################################################################
sub displayWorkbenchControls {
  my %args = @_;
  my $parameters = $args{parameters};
  my $hidden_form_fields = $args{hidden_form_fields};

  my $displayModeControl = buildSelectListControl(
    name => 'SAWB_DisplayMode',
    value => $parameters->{SAWB_DisplayMode},
    default => 'reannotatedSimple',
    parameters => $parameters,
    optionList => [
      'original' => 'Original Spectrum',
      'reannotatedSimple' => 'Reannotated Spectrum - Simple',
      'reannotatedFull' => 'Reannotated Spectrum - Full',
      'Lorikeet' => 'Lorikeet Arrays',
      'denovo' => 'Interpret spectrum de Novo',
    ],
  );

  my $normalizationControl = buildSelectListControl(
    name => 'SAWB_normalization',
    value => $parameters->{SAWB_normalization},
    default => 'peakTo100',
    parameters => $parameters,
    optionList => [
      'none' => 'None',
      'peakTo100' => 'Normalize peak to 100%',
    ],
  );

  my $annotationControl = buildSelectListControl(
    name => 'SAWB_annotation',
    value => $parameters->{SAWB_annotation},
    default => 'Lorikeet',
    parameters => $parameters,
    optionList => [
      'Lorikeet' => 'Lorikeet default annotations',
      'Reannotated' => 'Reannotated interpretations',
    ],
  );

  my $tmp = $parameters->{SAWB_minimumIntensity} || '';
  my $minimumIntensityFilterControl = qq~<INPUT TYPE="text" NAME="SAWB_minimumIntensity" LENGTH=15 VALUE="$tmp">~;

  #### If not manually set, set the high/low resolution control based on a possible fragmentation_type_id
  if ( !defined($parameters->{SAWB_resolutionHighLow}) ) {
    if ( $parameters->{fragmentation_type_id} ) {
      if ($parameters->{fragmentation_type_id} == 5 || $parameters->{fragmentation_type_id} == 6) {
	$parameters->{SAWB_resolutionHighLow} = 'low';
      }
    }
  }

  #### Create the high/low resolution control
  my $resolutionHighLowControl = buildSelectListControl(
    name => 'SAWB_resolutionHighLow',
    value => $parameters->{SAWB_resolutionHighLow},
    default => 'high',
    parameters => $parameters,
    optionList => [
      'high' => 'High',
      'low' => 'Low',
    ],
  );


  #### If not manually set, set the fragmentation control based on a possible fragmentation_type_id
  if ( !defined($parameters->{SAWB_fragmentation}) ) {
    if ( $parameters->{fragmentation_type_id} ) {
      if ($parameters->{fragmentation_type_id} == 2 || $parameters->{fragmentation_type_id} == 6) {
	$parameters->{SAWB_fragmentation} = 'ETD';
      }
    }
  }

  #### Create the fragmentation type control
  my $fragmentationControl = buildSelectListControl(
    name => 'SAWB_fragmentation',
    value => $parameters->{SAWB_fragmentation},
    default => 'CID',
    parameters => $parameters,
    optionList => [
      'CID' => 'CID',
      'ETD' => 'ETD',
    ],
  );

  print qq~
    <table width="100%" class="table_setup">
    <tr class="orange_bg"><th>Spectrum&nbsp;Analysis&nbsp;Workbench</th><td><a name="SAWB">&nbsp;</a></td></tr>
    </table>
  ~;


  #### Determine defaults for alternate sequence
  my $alt_sequence = $parameters->{alt_sequence} || '';
  my $alt_charge = $parameters->{alt_charge} || $parameters->{assumed_charge} || '2';

  #### Create the alternate charge control
  my $alternateChargeControl = buildSelectListControl(
    name => 'alt_charge',
    value => $alt_charge,
    default => '2',
    parameters => $parameters,
    optionList => [
      '1' => '1',
      '2' => '2',
      '3' => '3',
      '4' => '4',
      '5' => '5',
    ],
  );

  print qq~<table border=1><tr><td>
    <FORM METHOD="post" ACTION="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
      $hidden_form_fields
      Alternate sequence: <INPUT TYPE="text" NAME="alt_sequence" SIZE="40" VALUE="$alt_sequence"></INPUT>
      $alternateChargeControl<BR>
      Visual Display: $annotationControl<BR>
      Text Display: $displayModeControl<BR>
      Normalization: $normalizationControl
      Minimum Intensity: $minimumIntensityFilterControl<BR>
      Resolution: $resolutionHighLowControl &nbsp;&nbsp;&nbsp;
      Fragmentation: $fragmentationControl
      <BR>
      <INPUT TYPE='submit' VALUE='REFRESH'>
    </FORM>
    </TD></TR></TABLE>
  ~;

  return;

}


###############################################################################
# buildSelectListControl
###############################################################################
sub buildSelectListControl {
  my $METHOD = 'buildSelectListControl';
  my %args = @_;
  my $parameters = $args{parameters} || die("ERROR [buildSelectListControl]: parameters not passed");
  my $name = $args{name} || die("ERROR [buildSelectListControl]: name not passed");
  my $value = $args{value} || '';
  my $default = $args{default} || '';
  my $optionList = $args{optionList} || die("ERROR [buildSelectListControl]: optionList not passed");

  if ( $default && $value eq '' ) {
    $value = $default;
    $parameters->{$name} = $value;
  }

  my $buffer = qq~<SELECT NAME="$name">\n~;

  my @optionList = @{$optionList};
  while ( @optionList ) {
    my $optionKey = shift(@optionList);
    my $optionPrettyName = shift(@optionList);
    my $selected = '';
    $selected = ' SELECTED' if ( $value eq $optionKey );
    $buffer .= qq~  <OPTION$selected VALUE="$optionKey">$optionPrettyName</OPTION>\n~;
  }

  $buffer .= qq~</SELECT>\n~;

  return $buffer;

}


###############################################################################
# showSpectrumText
###############################################################################
sub showSpectrumText {
  my %args = @_;
  my $parameters = $args{parameters};
  my $peptideIon = $args{'peptideIon'};
  my $spectrumBuffer = $args{'spectrumBuffer'};

  my $spectrum = Proteomics::Spectra::Spectrum->new(peptideIon=>$peptideIon);

  #### If ETD is specified, then set that fragmenation type to ETD
  if ($parameters->{SAWB_fragmentation} eq 'ETD') {
    $spectrum->setFragmentationType('ETD');
  }

  #print "<PRE>\n";
  #$spectrum->getCalculatedFragments();
  #$spectrum->show();
  #print "</PRE>\n";

  #### Read the spectrum in from the text buffer
  $spectrum->parseLibrarySpectrumEntry(buffer=>$spectrumBuffer);

  #### If normalization was requested, apply it
  if ( $parameters->{SAWB_normalization} eq 'none' ) {
  } elsif ( $parameters->{SAWB_normalization} eq 'peakTo100' ) {
    $spectrum->normalizeSpectrum(normalizationType=>'maxPeak',newLevel=>100);
  } else {
    print "Unrecognized SAWB_normalization '$parameters->{SAWB_normalization}'\n";
  }

  #### If a minimum filtering threshold was specified, apply it
  if ( $parameters->{SAWB_minimumIntensity} =~ /^\s*([\d\.\-\+]+)\s*$/ ) {
    $spectrum->filter( minimumIntensity => $1 );
  }

  print "<PRE>\n";


  #### Set the reannotation resolution
  my $usePPMTolerance = 1;
  $usePPMTolerance = 0 if ( $parameters->{SAWB_resolutionHighLow} eq 'low' );

  if ( $parameters->{SAWB_DisplayMode} eq 'original' ) {
    $spectrum->show(format=>'simple');

  } elsif ( $parameters->{SAWB_DisplayMode} eq 'reannotatedSimple' ) {
    $spectrum->reannotate( ppm => $usePPMTolerance );
    $spectrum->show(format=>'simple');

  } elsif ( $parameters->{SAWB_DisplayMode} eq 'reannotatedFull' ) {
    $spectrum->reannotate( ppm => $usePPMTolerance );
    $spectrum->show(format=>'full');

  } elsif ( $parameters->{SAWB_DisplayMode} eq 'Lorikeet' ) {
    $spectrum->reannotate( ppm => $usePPMTolerance );
    $spectrum->show(format=>'Lorikeet');

  } elsif ( $parameters->{SAWB_DisplayMode} eq 'denovo' ) {
    my %deNovoModifications = ( 'C[160]'=>1 );
    if ( $peptideIon =~ /n\[145\]/ ) {
      %deNovoModifications = ( 'n[145]'=> 1,'K[272]'=>1,'C[160]'=>1 );
    }
    if ( $peptideIon =~ /n\[230\]/ ) {
      %deNovoModifications = ( 'n[230]'=> 1,'K[357]'=>1,'C[160]'=>1 );
    }
    if ( $peptideIon =~ /n\[43\]/ ) {
      %deNovoModifications = ( 'n[43]'=> 1,'C[160]'=>1 );
    }
    $spectrum->readSequenceDeNovo(
      modifications => \%deNovoModifications,
      ppm => $usePPMTolerance,
      #bestTolerance => 7,
      #stdTolerance => 7,
    );
    $spectrum->show(format=>'simple');

  } else {
    print "Unrecognized SAWB_DisplayMode '$parameters->{SAWB_DisplayMode}'\n";
    $spectrum->show(format=>'simple');
  }

  print "\n\n\n";
  print "</PRE>\n";

  return;
}


###############################################################################
# get_spectrum
###############################################################################
sub get_spectrum
{
  my %args = @_;

  my $spectrum_identification_id = $args{'spectrum_identification_id'};
  my $atlas_build_id = $args{'atlas_build_id'};
  my $parameters = $args{parameters};
  unless ($spectrum_identification_id) {
    print "\nERROR: get_spectrum needs spectrum_identification_id. ".
          "Got atlas_build_id $atlas_build_id.\n\n";
    return;
  }
  unless ($atlas_build_id) {
    print "\nERROR: get_spectrum needs atlas_build_id. ".
          "Got spectrum_identification_id $spectrum_identification_id.\n\n";
    return;
  }

  my $sql = qq~
    SELECT proteomics_search_batch_id,spectrum_name,ab.data_path
      FROM $TBAT_SPECTRUM S
      JOIN $TBAT_SPECTRUM_IDENTIFICATION SI
           ON (S.spectrum_id = SI.spectrum_id )
      JOIN $TBAT_ATLAS_SEARCH_BATCH ASB
           ON (SI.atlas_search_batch_id = ASB.atlas_search_batch_id )
      JOIN $TBAT_ATLAS_BUILD_SAMPLE ABS ON (ABS.SAMPLE_ID = ASB.SAMPLE_ID)
      JOIN $TBAT_ATLAS_BUILD AB ON (AB.ATLAS_BUILD_ID = ABS.ATLAS_BUILD_ID)
     WHERE SI.spectrum_identification_id = $spectrum_identification_id 
     AND   ab.atlas_build_id = $atlas_build_id
  ~;

  my @rows = $sbeams->selectSeveralColumns($sql);
  unless (@rows) {
    print "\nERROR: Unable to get search batch information for ".
      "spectrum_identification_id '$spectrum_identification_id'.\n\n";
    return;
  }
  my $search_batch_id = $rows[0]->[0];
  my $spectrum_name = $rows[0]->[1];
  my $build_path = $rows[0]->[2];
  my $fraction_tag;
  if ($spectrum_name =~ /^(.+)\.(\d+)\.(\d+)\.\d$/) {
    $fraction_tag = $1;
  } else {
    die("ERROR: Unable to parse fraction name from '$spectrum_name'");
  }

  #print "search_batch_id = $search_batch_id\n";
  #print "spectrum_name = $spectrum_name\n";
  #print "fraction_tag = $fraction_tag\n";


  use SBEAMS::PeptideAtlas::Spectrum;
  my $spectra = new SBEAMS::PeptideAtlas::Spectrum;
  $spectra->setSBEAMS($sbeams);

  my @mass_intensities = ();
 
  #### Get the data_location of the spectrum
  my $data_location = $spectra->get_data_location(
    proteomics_search_batch_id => $search_batch_id,
  );
  if ($data_location =~ /.*archive\//){
    $data_location =~ s/.*archive\///;
  }

  my $library_idx_file = "/regis/sbeams/archive/$data_location/RAW.specidx";
  my $comp_idx_file = "/regis/sbeams/archive/$data_location/RAW.compspecidx";
  #print "Library file=$library_idx_file\n";

  if ( !-e $library_idx_file && !-e $comp_idx_file ) { 
    $build_path ="/net/db/projects/PeptideAtlas/pipeline/output/$build_path"; 
    $build_path =~ /.*\/(.*)\/DATA_FILES/;
    $library_idx_file ="$build_path/$1_all_raw.specidx";
    $comp_idx_file ="$build_path/$1_all_raw.compspecidx";
  }

  #### 2014-05-07 Eric disables RAW library reading because spectra are seriously altered!
  #if ( 0 && ( -e $library_idx_file || -e $comp_idx_file ) ){
  my %spectrum;
  @mass_intensities = $spectra->getSpectrumPeaks_plotmsms(
    proteomics_search_batch_id => $search_batch_id,
    spectrum_name => $spectrum_name,
    fraction_tag => $fraction_tag,
    parameters => $parameters,
  );

  @mass_intensities = $spectra->getSpectrumPeaks(
    proteomics_search_batch_id => $search_batch_id,
    spectrum_name => $spectrum_name,
    fraction_tag => $fraction_tag,
  ) if ( ! @mass_intensities);

  if ( ! @mass_intensities and (-e $library_idx_file || -e $comp_idx_file )) {
    @mass_intensities = $spectra->getSpectrumPeaks_Lib(
    spectrum_name => $spectrum_name,
    library_idx_file => $library_idx_file,
   );
  }


  #### If we still have no spectrum data, then bail out
  unless (@mass_intensities) {
    print "\nERROR: Unable to get m/z,intensity pairs for ".
      "spectrum_identification_id '$spectrum_identification_id'.\n\n";
    return;
  }

  #### Extract rows into two arrays of masses and intensities
  my (@masses,@intensities);
  for (my $i=0; $i<=$#mass_intensities; $i++) {
    push(@masses,$mass_intensities[$i]->[0]);
    push(@intensities,$mass_intensities[$i]->[1]);
  }

  $spectrum{n_peaks} = $#mass_intensities + 1;


  #### Put data into hash and return
  $spectrum{mz} = \@masses;
  $spectrum{intensities} = \@intensities;


  # have to return scalar before hash
  return ($search_batch_id, %spectrum);

}


###############################################################################
# printUserAnnotations
# get and display user annotations, if any
###############################################################################
sub printUserAnnotations {
    my %args = @_;

    my $buffer;
    my $total = 0; # this starts as a counter, then becomes a string
    my $show_form = 1;
    my $line_sep = "<tr><td colspan='2'><hr size='1' noshade></td></tr>";

    my $sql = qq~
	SELECT SA.spectrum_annotation_id, SA.comment, SA.date_modified,
	       SA.spectrum_identification_id, SA.identified_peptide_sequence, SA.identified_peptide_charge,
	       SL.spectrum_annotation_level_id, SL.level_name,
	       C.first_name, C.last_name,
	       UL.username
	  FROM $TBAT_SPECTRUM_ANNOTATION SA
    INNER JOIN $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
            ON ( SA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
    INNER JOIN $TB_CONTACT C
            ON ( annotator_contact_id = C.contact_id )
    INNER JOIN $TB_USER_LOGIN UL
            ON ( UL.contact_id = annotator_contact_id )
	 WHERE spectrum_id = '$args{spectrum_id}'
	   AND SA.record_status = 'N'
      ORDER BY SA.date_modified DESC
        ~;

    my @rows = $sbeams->selectSeveralColumns($sql);

    $buffer = qq~
	<table width="100%" class="table_setup">
	<tr class="orange_bg"><th>User annotations</th><td><a name="user_annotations">&nbsp;</a></td></tr>
	~;

    if (@rows) {
	foreach my $row (@rows)
	{
	    my ($annot_id, $comment, $date, $ident_id, $sequence, $charge, $level_id, $level, $first, $last, $uname) = @{$row};
	    $total++;

	    if ($args{modified_sequence}.$args{charge} eq $sequence.$charge) {
		$buffer .= "<tr id='${uname}${annot_id}_annot_tr'><th valign='top'>$level</th><td>$first $last ($date)<br />\n";
	    } else {
		my $link = $q->self_url();
		$link =~ s/\?.*//;  # clear querystring
		$link .= "?spectrum_identification_id=$ident_id;peptide=$sequence;assumed_charge=$charge";

		$buffer .= "<tr bgcolor='#dddddd' id='${uname}${annot_id}_annot_tr'><th valign='top'>$level<br /><a href='$link' style='color:red'>$sequence +$charge</a></th><td>$first $last ($date)<br />\n";
	    }

	    my $disp_comment = $comment;
	    $disp_comment =~ s|\n|<BR />\n|g; # display carriage returns
	    $buffer .= "$disp_comment\n";

	    if ( ($uname eq $current_username) &&
		 ($args{modified_sequence}.$args{charge} eq $sequence.$charge) ) {
		$show_form = 0;

		$buffer .= qq~
		    <br /><div align='right'><a href='javascript:showEditForm();'>Edit my annotation</a> | <a href='javascript:confirm_delete();'>Delete</a>
		    <FORM NAME="delete_annotation" METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
		    $args{form_fields}
		    <INPUT TYPE='hidden' NAME='spectrum_annotation_id' VALUE='$annot_id'>
   		    <INPUT TYPE='hidden' NAME='apply_action' VALUE='DELETE ANNOTATION'></FORM>
		    </div>
		    ~;

		$buffer .= "</td></tr>\n";

		$buffer .= &printUserAnnotationsForm(
						     form_type => 'update',
						     uname => $uname,
						     default_level_id => $level_id,
						     default_comment => $comment,
						     annot_id => $annot_id,
						     extra_form_fields => $args{form_fields}
						     );
	    }

	    $buffer .= "</td></tr>\n$line_sep\n";
	}

    } else {
	$buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td class='section_heading'>There are no user annotations for this spectrum<br /></td></tr>
	    $line_sep
	    ~;
    }


    if ($current_username eq 'guest') {
	my $url = $q->self_url();
	$url .= '&force_login=yes';

	$buffer .= qq~
	    <tr><td>&nbsp;</td>
	    <td><a href='$url'>Log into PeptideAtlas</a> to add an annotation for this spectrum<br /></td></tr>
	    $line_sep
	    ~;

    } elsif ($show_form) {
	$buffer .= "<tr id='${current_username}add_annot_tr'><th valign='top'><a href='javascript:showEditForm();'>Add annotation</a></th><td>&nbsp;</td></tr>\n";

	$buffer .= &printUserAnnotationsForm(
					     form_type => 'add',
					     uname => $current_username,
					     spectrum_id => $args{spectrum_id},
					     extra_form_fields => $args{form_fields}
					     );

	$buffer .= "</td></tr>\n$line_sep\n";
    }

    $buffer .= "</table>\n";

    # get average
    $sql = qq~
 	SELECT ROUND(AVG(SL.level_probability)*100,0) AS avg_prob_pct,
	       COUNT(*)
	  FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL SL
    INNER JOIN $TBAT_SPECTRUM_ANNOTATION SA
            ON ( SA.spectrum_annotation_level_id = SL.spectrum_annotation_level_id )
	 WHERE spectrum_id = '$args{spectrum_id}'
	   AND identified_peptide_sequence = '$args{modified_sequence}'
	   AND identified_peptide_charge = '$args{charge}'
	   AND SA.record_status = 'N'
        ~;

    @rows = $sbeams->selectSeveralColumns($sql);

    my ($avg, $num) = @{$rows[0]};
    if ($total != $num) {
	$total = "($total total)";
    } else {
	$total = '';
    }

    my $innerHTML;

    if ($num == 1) {
	$innerHTML = "There is <a href=\"#user_annotations\">one user annotation</a> $total for this spectrum, with a score of <b>$avg%</b>";
    } elsif ($num > 1) {
	$innerHTML = "There are <a href=\"#user_annotations\">$num user annotations</a> $total for this spectrum, with an average score of <b>$avg%</b>";
    }

    $buffer .=<< "EOJS" if $innerHTML;
<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
    document.getElementById("annotations_summary").innerHTML = '$innerHTML';
    document.getElementById("annotations_head").style.display = 'table-row';
</SCRIPT>
EOJS

    return $buffer;
}


###############################################################################
# printUserAnnotationsForm
# get and display user annotations, if any
###############################################################################
sub printUserAnnotationsForm {
    my %args = @_;

    $args{form_type} ||= 'add';
    $args{uname} ||= 'user_anon';
    $args{default_level_id} ||= 0;
    $args{default_comment} ||= '';
    $args{annot_id} ||= 0;
    $args{extra_form_fields} ||= '';

    my $spacer = "&nbsp;"x5;

    my $trname = $args{uname};
    $trname .= ($args{form_type} eq 'add') ? 'add' : $args{annot_id};

    my $buffer = qq~
	<SCRIPT LANGUAGE="JavaScript" TYPE="text/javascript">
	<!--
	function showEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'none';
	    document.getElementById('${trname}_form_tr').style.display = 'table-row';
	}
        function hideEditForm() {
	    document.getElementById('${trname}_annot_tr').style.display = 'table-row';
	    document.getElementById('${trname}_form_tr').style.display = 'none';
	}

        function confirm_delete() {
	    var del = confirm("Are you sure you want to delete your comment?");
	    if (del==true) {
		document.delete_annotation.submit();
	    }
	}
        // -->
	</SCRIPT>
	~;

    # add a hidden <tr> for edit form
    my $sql = qq~
	SELECT spectrum_annotation_level_id, level_probability, level_name, level_description
	FROM $TBAT_SPECTRUM_ANNOTATION_LEVEL
	WHERE record_status = 'N'
	ORDER BY sort_order
	~;

    my @levels = $sbeams->selectSeveralColumns($sql);

    my $select = "<SELECT NAME='user_spectrum_annotation'>\n";
    foreach my $levrow (@levels)
    {
	my ($lev_id, $lev_prob, $lev_name, $lev_desc) = @{$levrow};

	my $sel = ( "$args{default_level_id}" eq "$lev_id" ) ? 'SELECTED' : '';
	my $desc = $sbeams->escapeXML(value => $lev_desc);

	$select .= "<OPTION TITLE='$desc' VALUE='$lev_id' $sel>$lev_name</OPTION>\n";
    }
    $select .= "</SELECT>";

    my $form_action = "ADD";
    if ($args{form_type} eq 'update') {
	$form_action = "UPDATE";
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='spectrum_annotation_id' VALUE='$args{annot_id}'>";

    } else {
	$args{extra_form_fields} .= "<INPUT TYPE='hidden' NAME='spectrum_id' VALUE='$args{spectrum_id}'>";
    }

    $buffer .= qq~
	<tr style='display:none' id='${trname}_form_tr'>
	<th valign='top'>
	<FORM METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
	$args{extra_form_fields}
	$select</th>
	<td><TEXTAREA ROWS='6' COLS='80' NAME='user_spectrum_commment'>$args{default_comment}</TEXTAREA><br />
	<div align='right'><INPUT TYPE='submit' NAME='apply_action' VALUE='$form_action ANNOTATION'>$spacer<a class='small_form_field' href='javascript:hideEditForm();'>CANCEL</a></div>
        </FORM>
	~;

    # caller will close the td and tr
    return $buffer;

}


###############################################################################
# getUSIInputForm
###############################################################################
sub getUSIInputForm {
  my $METHOD = 'getUSIInputForm';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my %parameters = @_;

  #### Set up a response object
  my $response = Proteomics::Response->new();

  #### Process standard parameters
  my $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );

  #### Process specific parameters
  my $cgiParameters = processParameters( name=>'parameters', required=>0, allowUndef=>0, response=>$response, parameters=>\%parameters, caller=>$METHOD );

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );
 
  my $usi = $cgiParameters->{USI};
  $usi = "" unless ( $usi );

  my $buffer = qq~<TABLE BORDER=0><TR><TD>
       <SCRIPT LANGUAGE="JavaScript">
       function fillInUSI(input_field) {
         exampleNumber = Math.floor((Math.random()*3))
         if ( exampleNumber == 0 ) {
           document.USIForm.USI.value = "mzspec:PXD000561:Adult_Urinarybladder_bRP_Elite_71_f14:scan:1872:FSGSSSGADR/2";
         } else if ( exampleNumber == 0 ) {
           document.USIForm.USI.value = "mzspec:PXD000865:00603_F01_P004608_B00F_A00_R1:scan:14453:SSLLDVLAAR/2";
         } else {
           document.USIForm.USI.value = "mzspec:PXD002255:ES_XP_Ubi_97H_HCD_349:scan:9617:LAEIYVNSSFYK/2";
         }
         return;
       }
       </SCRIPT>
    <FORM NAME="USIForm" METHOD="post" action="$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROG_NAME">
    <font size="+1">Universal Spectrum Identifier:</font>&nbsp;&nbsp;&nbsp;<a target="_blank" href="https://github.com/HUPO-PSI/UniversalSpectrumIdentifier">(what's this?)</a>&nbsp;&nbsp;&nbsp;
          <INPUT TYPE="button" NAME="example_button" VALUE="example" onClick="fillInUSI(example_button)"><BR>
    <INPUT TYPE="text" NAME="USI" SIZE="100" VALUE="$usi"></INPUT>
    <INPUT TYPE='submit' VALUE='VIEW'>
    </FORM>
    </TD></TR></TABLE>
  ~;

  return $buffer;

}


###############################################################################
# interpretUSI
###############################################################################
sub interpretUSI {
  my $METHOD = 'interpretUSI';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my %parameters = @_;

  #### Set up a response object
  my $response = Proteomics::Response->new();

  #### Process standard parameters
  my $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );

  #### Process specific parameters
  my $usiStr = processParameters( parameters=>\%parameters, caller=>$METHOD, name=>'usiStr', required=>1, allowUndef=>0, response=>$response );

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );
 
  #### There may be some error messages for info messages coming, so switch to PRE mode
  print "<PRE>\n";

  #### Parse the passed USI
  my $usi = Proteomics::Spectra::UniversalSpectrumIdentifier->new( usi=>$usiStr );
  my $result = $usi->parse( verbose=>$verbose, debug=>$verbose,  outputDestination=>$outputDestination );

  #### If the USI string was not successfully parsed, then just return
  if ( $result->{status} ne 'OK' ) {
    #print "Provided identifier=$usiStr\n";
    $result->show();
    $response->mergeResponse( sourceResponse=>$result, verbose=>0, debug=>0, outputDestination=>$outputDestination );
    print "</PRE>\n";
    return $response;
  }

  my $datasetIdentifier = $usi->{datasetIdentifier};
  my $msRunName = $usi->{msRunName};
  my $indexFlag = $usi->{indexFlag};
  my $index = $usi->{index};
  my $interpretation = $usi->{interpretation};
  my $peptidoform = $usi->{peptidoform};
  my $charge = $usi->{charge};

  #print "datasetIdentifier=$datasetIdentifier\n";
  my $sql = qq~ 
    SELECT SAMPLE_ID,
           SAMPLE_ACCESSION,
           S.SEARCH_BATCH_ID,
           IS_PUBLIC,
           REPOSITORY_IDENTIFIERS,
           DATA_LOCATION
      FROM $TBAT_SAMPLE S
      JOIN $TBPR_SEARCH_BATCH SB ON ( SB.search_batch_id = S.search_batch_id )
     WHERE repository_identifiers LIKE '\%$usi->{datasetIdentifier}\%'
    ~;
  my @rows = $sbeams->selectSeveralColumns($sql);
  my $nRows = scalar(@rows);
  if ($nRows == 0){
    my $sql = qq~
      SELECT DATASET_ID,
             NULL,
             NULL,
             'Y', 
             DATASET_IDENTIFIER,
             LOCAL_DATA_LOCATION
      FROM $TBAT_PUBLIC_DATA_REPOSITORY
      WHERE DATASET_IDENTIFIER LIKE '\%$usi->{datasetIdentifier}\%'
      AND LOCAL_DATA_LOCATION like '%sbeams%'
    ~;
    @rows = $sbeams->selectSeveralColumns($sql);
    $nRows = scalar(@rows);
  }

  my $foundFile = '';
  my $nFoundFiles = 0;

  if ( $nRows == 0 ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'DatasetNotHere', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Dataset '$datasetIdentifier' is not stored here at PeptideAtlas.");
    print "</PRE>\n";
    return $response;
  } else {
    #print "INFO: found $nRows sample(s) matching dataset '$usi->{datasetIdentifier}'<BR>\n";
    foreach my $row ( @rows ) {
      my ($sample_id,$sample_accession,$search_batch_id,$is_public,$repository_identifiers,$data_location) = @{$row};
      unless ( -d $data_location ) {
        #### Also try the data/ directory as sometimes one can find it there
        if ( $data_location =~ /^(.+\/)/ ) {
          my $data_location2 = $1;
          $data_location2 .= "data";
          if ( -d $data_location2 ) {
            $data_location = $data_location2;
            $response->logEvent( level=>'WARNING', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
              message=>"Looked for dataset '$datasetIdentifier' in '$data_location' and did not find it. But then looked in '$data_location2' and found it there. This is not ideal, but we can try to continue.");
          } else {
            $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'InvalidDataLocation', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
              message=>"Although the dataset '$datasetIdentifier' was found, the internal data location appears to be invalid. This needs to be fixed. Please report this error. Looking for data location '$data_location'");
          }
        }
      }

      #### Try to find the mzML file corresponding to this run
      my @files = glob("$data_location/$msRunName.*");
      if ( scalar(@files) > 0 ) {
        foreach my $file ( @files ) {
          if ( $file =~ /mzML/ ) {
            $nFoundFiles++;
            $foundFile = $file;
          }
        }

      #### If the mzML is not found, try going up a level and looking again
      } else {
        @files = glob("$data_location/../$msRunName.*");
        if ( scalar(@files) > 0 ) {
          foreach my $file ( @files ) {
            if ( $file =~ /mzML/ ) {
              $nFoundFiles++;
              $foundFile = $file;
            }
          }
        }
      } # end else

    }
  }

  if ( $nFoundFiles == 0 ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'MsRunNotFound', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Although the dataset '$datasetIdentifier' was found, no mzML file root '$msRunName' was found");
  } elsif ( $nFoundFiles > 1 ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'FoundMultipleMatchingMsRuns', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Under dataset '$datasetIdentifier', multiple mzML files with file root '$msRunName' were found. This cannot be properly handled yet");
  } else {
    #print "INFO: Found data file for this MS run: $foundFile\n";
    $response->{datasetIdentifier} = $datasetIdentifier;
    $response->{mzMLFilePath} = $foundFile;
    $response->{msRunName} = $msRunName;
    $response->{index} = $index;
    $response->{indexFlag} = $indexFlag;
    $response->{interpretation} = $interpretation;
    $response->{peptidoform} = $peptidoform;
    $response->{charge} = $charge;
  }

  print "</PRE>\n";
  return $response;
}


###############################################################################
# getSpectrumFromMzmlFile
###############################################################################
sub getSpectrumFromMzmlFile {
  my $METHOD = 'getSpectrumFromMzmlFile';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my %parameters = @_;

  #### Set up a response object
  my $response = Proteomics::Response->new();

  #### Process standard parameters
  my $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  my $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );

  #### Process specific parameters
  my $filePath = processParameters( name=>'filePath', required=>1, allowUndef=>0, response=>$response, parameters=>\%parameters, caller=>$METHOD );
  my $scanNumber = processParameters( name=>'scanNumber', required=>1, allowUndef=>0, response=>$response, parameters=>\%parameters, caller=>$METHOD );

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );
 
  #### Check to make sure the file exists
  unless ( -e $filePath ) {
    $response->logEvent( level=>'ERROR', errorCode=>'MsRunFileNotFound', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Specified filePath '$filePath' is not a file");
    return $response;
  }

  #### Create a virtual filename to fetch the spectrum
  my $filename = "/proteomics/sw/tpp/bin/readmzXML $filePath $scanNumber |";
  print "Fetch command: $filename\n" if ($verbose);

  #### Try to open the spectrum for reading
  unless (open(DTAFILE,$filename)) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'MsRunFileNotReadable', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Specified filePath '$filePath' exists, but cannot be read");
    return $response;
  }

  #### Read the spectrum data
  my @mz_intensities;
  my $observedPrecursorMz = 0;
  while (my $line = <DTAFILE>) {
    $line =~ s/[\r\n]//g;
    print "$line<BR>\n" if ($verbose);

    #### Extract the precursor mz information from that line
    if ( $line =~ /precursorMZ: ([\d\.]+)/ ) {
      $observedPrecursorMz = $1;
      next;
    }

    #### Skip if this isn't a mass intensity line
    next if ($line !~ /mass.*inten/);

    #### Extract and store mass intensity information
    $line =~ /mass\s+(\S+)\s+inten\s+(\S+)/;
    push(@mz_intensities,[$1,$2]);
  }
  close(DTAFILE);

  #### If there were no values, print diagnostics and return
  unless (@mz_intensities) {
    $response->logEvent( level=>'ERROR', errorCode=>'NoPeaksRead', verbose=>$verbose, debug=>$debug, quiet=>$quiet,
      message=>"No peaks returned from extraction attempt of scan $scanNumber from file '$filePath'");
    return $response;
 }

  #### Return result
  $response->logEvent( level=>'INFO', minimumVerbosity=>1, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>scalar(@mz_intensities)." mass-inten pairs read");

  $response->{mz} = \@mz_intensities;
  $response->{observedPrecursorMz} = $observedPrecursorMz;
  return $response;

} # end getSpectrumFromMzmlFile
