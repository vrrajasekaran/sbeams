#!/usr/local/bin/perl

###############################################################################
# Program     : GetProtein
# $Id$
#
# Description : Prints summary of a given protein given selection
#               atlas build and protein name.
#
# SBEAMS is Copyright (C) 2000-2005 Institute for Systems Biology
# This program is governed by the terms of the GNU General Public License (GPL)
# version 2 as published by the Free Software Foundation.  It is provided
# WITHOUT ANY WARRANTY.  See the full description of GPL terms in the
# LICENSE file distributed with this software.
#
###############################################################################


###############################################################################
# Set up all needed modules and objects
###############################################################################
use strict;
use Getopt::Long;
use FindBin;
$|++;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($sbeams $sbeamsMOD $q $current_contact_id $current_username
             $PROG_NAME $USAGE %OPTIONS $QUIET $VERBOSE $DEBUG $DATABASE
             $TABLE_NAME $PROGRAM_FILE_NAME $CATEGORY $DB_TABLE_NAME
             @MENU_OPTIONS);

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::TabMenu;
$sbeams = new SBEAMS::Connection;

use SBEAMS::BioLink;
my $biolink = SBEAMS::BioLink->new();
$biolink->setSBEAMS($sbeams);

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);

use SBEAMS::PeptideAtlas::KeySearch;
my $keySearch = new SBEAMS::PeptideAtlas::KeySearch;
$keySearch->setSBEAMS($sbeams);


###############################################################################
# Set program name and usage banner for command like use
###############################################################################
$PROG_NAME = $FindBin::Script;
$USAGE = <<EOU;
Usage: $PROG_NAME [OPTIONS] key=value key=value ...
Options:
  --verbose n         Set verbosity level.  default is 0
  --quiet             Set flag to print nothing at all except errors
  --debug n           Set debug flag

 e.g.:  $PROG_NAME [OPTIONS] [keyword=value],...

EOU

#### Process options
unless (GetOptions(\%OPTIONS,"verbose:s","quiet","debug:s")) {
  print "$USAGE";
  exit;
}

$VERBOSE = $OPTIONS{"verbose"} || 0;
$QUIET = $OPTIONS{"quiet"} || 0;
$DEBUG = $OPTIONS{"debug"} || 0;

if ($DEBUG) {
  print "Options settings:\n";
  print "  VERBOSE = $VERBOSE\n";
  print "  QUIET = $QUIET\n";
  print "  DEBUG = $DEBUG\n";
}



###############################################################################
# Set Global Variables and execute main()
###############################################################################
main();
exit(0);



###############################################################################
# Main Program:
#
# Call $sbeams->Authenticate() and exit if it fails or continue if it works.
###############################################################################
sub main {

  #### Do the SBEAMS authentication and exit if a username is not returned
  exit unless ($current_username = $sbeams->Authenticate(
      permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
      'PeptideAtlas_readonly'],
      #connect_read_only=>1,
      allow_anonymous_access=>1,
  ));


  #### Read in the default input parameters
  my %parameters;
  my $n_params_found = $sbeams->parse_input_parameters(
      q=>$q,
      parameters_ref=>\%parameters);
  #$sbeams->printDebuggingInfo($q);

  #### Process generic "state" parameters before we start
  $sbeams->processStandardParameters(parameters_ref=>\%parameters);

  #### Decide what action to take based on information so far
  if ($parameters{action} eq "???") {
      # Some action

  } else {
      my $project_id = $sbeamsMOD->getProjectID(
          atlas_build_id => $parameters{atlas_build_id}
          );
      $sbeamsMOD->display_page_header(project_id => $project_id);
      handle_request(ref_parameters=>\%parameters);
      $sbeamsMOD->display_page_footer();
  }


} # end main



###############################################################################
# Handle Request
###############################################################################
sub handle_request {

  my %args = @_;

  my $spacer = $sbeams->getGifSpacer( 900 );
  my $htmlmode = ( $sbeams->output_mode() eq 'html' ) ? 1 : 0;


  #### Process the arguments list
  my $ref_parameters = $args{'ref_parameters'}
      || die "ref_parameters not passed";

  my %parameters = %{$ref_parameters};


  # put a spacer so that showing hidden content doesn't mangle the layout
  print "<BR>$spacer\n" if $htmlmode;

  #### Get the HTML to display the tabs
  my $tabMenu = $sbeamsMOD->getTabMenu(
    parameters_ref => \%parameters,
    program_name => $PROG_NAME,
  );
  print $tabMenu->asHTML() if ($sbeams->output_mode() eq 'html');


  #### Get the current atlas_build_id based on parameters or session
  my $atlas_build_id = $sbeamsMOD->getCurrentAtlasBuildID(
    parameters_ref => \%parameters,
  );
  if (defined($atlas_build_id) && $atlas_build_id < 0) {
    return;
  }
  $parameters{atlas_build_id} = $atlas_build_id;


  #### Get the search keyword
  my $protein_name = $parameters{"protein_name"};

  #### If a new protein_name was supplied, store it
  if ($protein_name) {
    $sbeams->setSessionAttribute(
      key => 'PeptideAtlas_protein_name',
      value => $protein_name,
    );

  #### Else see if we had one stored
  } else {
    $protein_name = $sbeams->getSessionAttribute(
      key => 'PeptideAtlas_protein_name',
    );
    if ($protein_name) {
      $parameters{'apply_action'} = 'GO';
    }
  }


  #### Define some variables for a query and resultset
  my %resultset = ();
  my $resultset_ref = \%resultset;
  my (%url_cols,%hidden_cols,%max_widths,$show_sql);


  #### Read in the standard form values
  my $apply_action  = $parameters{'action'} || $parameters{'apply_action'};
  my $TABLE_NAME = $parameters{'QUERY_NAME'};


  #### Set some specific settings for this program
  my $CATEGORY="Get Protein";
  my $PROGRAM_FILE_NAME = $PROG_NAME;
  my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";
  my $help_url = "$CGI_BASE_DIR/help_popup.cgi";


  #### If the apply action was to recall a previous resultset, do it
  my %rs_params = $sbeams->parseResultSetParams('q' => $q);
  my $n_params_found = 0;

  if ($apply_action eq "VIEWRESULTSET") {
    $sbeams->readResultSet(
      resultset_file=>$rs_params{set_name},
      resultset_ref=>$resultset_ref,
      query_parameters_ref=>\%parameters,
      resultset_params_ref=>\%rs_params,
    );
    $n_params_found = 99;
  }

  #### Get a list of accessible project_ids
  my @accessible_project_ids = $sbeams->getAccessibleProjects();
  my $accessible_project_ids = join( ",", @accessible_project_ids ) || '0';


  #### Get a hash of available atlas builds
  my $sql = qq~
      SELECT atlas_build_id,atlas_build_name
      FROM $TBAT_ATLAS_BUILD
      WHERE project_id IN ( $accessible_project_ids )
      AND record_status!='D'
  ~;
  my %atlas_build_names = $sbeams->selectTwoColumnHash($sql);


  #### Get a list of id's sorted by name
  my $sql = qq~
      SELECT atlas_build_id,atlas_build_name
      FROM $TBAT_ATLAS_BUILD
      WHERE project_id IN ( $accessible_project_ids )
      AND record_status!='D'
      ORDER BY atlas_build_name
  ~;
  my @ordered_atlas_build_ids = $sbeams->selectOneColumn($sql);


  #### If the output_mode is HTML, then display the form
  if ($sbeams->output_mode() eq 'html') {

      print qq~
        <script LANGUAGE="Javascript">
          function switchAtlasBuild() {
            document.SearchForm.apply_action.value = "GO";
            document.SearchForm.submit();
          }
        </script>
      ~;

      print "<P>";

      print "<nobr>";

      print $q->start_form(-method=>"POST",
                           -action=>"$base_url",
			   -name=>"SearchForm",
                          );

      print "PeptideAtlas Build: ";

      print $q->popup_menu(-name => "atlas_build_id",
                           -values => [ @ordered_atlas_build_ids ],
                           -labels => \%atlas_build_names,
                           -default => $atlas_build_id,
                           -onChange => 'switchAtlasBuild()',
			  );

      #print "&nbsp;&nbsp;&nbsp;";
      print "<BR>";

      print "Protein Name: ";

      print $q->textfield( "protein_name", $protein_name);
      print $q->hidden( "apply_action", '');

      print "&nbsp;&nbsp;&nbsp;";

      print $q->submit(-name => "action",
                       -value => 'QUERY',
                       -label => 'GO');
      print $q->endform;

      print "</nobr>";

      print "</P>";
  }



  #########################################################################
  #### Process all the constraints

  #### If atlas_build_id was not selected, stop here
  unless ($atlas_build_id) {
    if ($sbeams->output_mode() eq 'html') {
      print "Please select an atlas build, type in a protein name ".
        "(e.g. ENSP00000290230 for human Ensembl protein), and ".
	"click GO";
    } else {
      $sbeams->reportException(
          state => 'ERROR',
          type => 'INSUFFICIENT CONSTRAINTS',
          message => 'You must provide an atlas_build_id',
      );
    }
    return;
  }


  #### If biosequence_name was not selected, stop here
  unless ($protein_name) {
    if ($sbeams->output_mode() eq 'html') {
      print "Please type in a protein name ".
        "(e.g. ENSP00000290230 for human Ensembl protein), and ".
	"click GO";
    } else {
      $sbeams->reportException(
          state => 'ERROR',
          type => 'INSUFFICIENT CONSTRAINTS',
          message => 'You must provide a protein_name',
      );
    }
    return;
  }



  #### Build ATLAS_BUILD constraint
  my $atlas_build_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"AB.atlas_build_id",
      constraint_type=>"int_list",
      constraint_name=>"Atlas Build",
      constraint_value=>$atlas_build_id );
  return if ($atlas_build_clause eq '-1');


  #### Build PROTEIN_NAME constraint
  my $biosequence_name_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"BS.biosequence_name",
      constraint_type=>"plain_text",
      constraint_name=>"Protein Name",
      constraint_value=>$protein_name );
  return if ($biosequence_name_clause eq '-1');


  #### Define the SQL statement to find the biosequence
  $sql = qq~
       SELECT BS.biosequence_id, BS.biosequence_name
         FROM $TBAT_ATLAS_BUILD AB
        INNER JOIN $TBAT_BIOSEQUENCE_SET BSS
              ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
        INNER JOIN $TBAT_BIOSEQUENCE BS
              ON ( BSS.biosequence_set_id = BS.biosequence_set_id )
       WHERE 1 = 1
          $atlas_build_clause
          $biosequence_name_clause
  ~;


  my %biosequences = $sbeams->selectTwoColumnHash($sql);
  my $n_biosequences = scalar(keys(%biosequences));


  #### If the protein was not found, report the problem
  if ($n_biosequences == 0) {
    if ($sbeams->output_mode() eq 'html') {
      print qq~
        The protein entered '$protein_name' was not found in the
        atlas build '$atlas_build_names{$atlas_build_id}'. Please check
        that the correct build was selected and that the protein name
        was correctly specified.
      ~;
    } else {
      $sbeams->reportException(
          state => 'ERROR',
          type => 'RECORD NOT FOUND',
          message => "The protein entered '$protein_name' was not found ".
            "in the atlas build '$atlas_build_names{$atlas_build_id}'.",
      );
    }
    return;
  }


  #### If more than one protein was found, list them
  if ($n_biosequences > 1) {
    if ($sbeams->output_mode() eq 'html') {
      print qq~
        Several ($n_biosequences) entries were returned from your request
        for '$protein_name' in the
        atlas build '$atlas_build_names{$atlas_build_id}'. Please select
        the appropriate one:<BR><BR>
      ~;
      while (my ($key,$value) = each (%biosequences)) {
	print "$value<BR>";
      }

    } else {
      $sbeams->reportException(
          state => 'ERROR',
          type => 'TOO MANY RECORDS',
          message => qq~More than one ($n_biosequences) was returned from 
             your request
             for '$protein_name' in the
             atlas build '$atlas_build_names{$atlas_build_id}'.~,
      );
    }
    return;
  }


  #### Extract the one biosequence_id
  my ($biosequence_id) = keys(%biosequences);


  #### Return some information about this biosequence
  $sql = qq~
       SELECT BS.biosequence_id, BS.biosequence_name,BS.biosequence_gene_name,
              BS.biosequence_accession, BS.biosequence_desc,
              BS.biosequence_seq,BSS.set_name,
              DBX.accessor,DBX.accessor_suffix,
              BAG.annotated_gene_id,
              BPS.transmembrane_class,
              BPS.transmembrane_topology,
              BPS.has_signal_peptide,
              BPS.has_signal_peptide_probability,
              BPS.signal_peptide_length,
              BPS.signal_peptide_is_cleaved
         FROM $TBAT_BIOSEQUENCE_SET BSS
        INNER JOIN $TBAT_BIOSEQUENCE BS
              ON ( BSS.biosequence_set_id = BS.biosequence_set_id )
         LEFT JOIN $TBAT_DBXREF DBX
              ON ( BS.dbxref_id = DBX.dbxref_id )
         LEFT JOIN $TBAT_BIOSEQUENCE_ANNOTATED_GENE BAG
              ON ( BAG.biosequence_id = BS.biosequence_id )
         LEFT JOIN $TBAT_BIOSEQUENCE_PROPERTY_SET BPS
              ON ( BS.biosequence_id = BPS.biosequence_id )
       WHERE BS.biosequence_id = $biosequence_id
  ~;
  my @rows = $sbeams->selectHashArray($sql);
  my $biosequence = $rows[0];

  # Widget to allow show/hide of overview section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprotein_overview',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );


  #### Print out a summary of the protein
  if ($sbeams->output_mode() eq 'html') {
    my $section_header = $sbeamsMOD->encodeSectionHeader(
      text => $biosequence->{biosequence_name},
      link => $link
    );

    print qq~
      <TABLE width="600">
        $section_header
    ~;
    print $sbeamsMOD->encodeSectionItem(
      key=>'Protein Name',
 tr_info => $tr,
      value=>$biosequence->{biosequence_name},
      #url=>"$biosequence->{accessor}$biosequence->{biosequence_accession}$biosequence->{accessor_suffix}",
    );

    print $sbeamsMOD->encodeSectionItem(
      key=>'Gene Name',
 tr_info => $tr,
      value=>$biosequence->{biosequence_gene_name},
    );

    print $sbeamsMOD->encodeSectionItem(
      key=>'Description',
 tr_info => $tr,
      value=>$biosequence->{biosequence_desc},
    );

    my @synonyms = $keySearch->getProteinSynonyms(
      resource_name => $biosequence->{biosequence_name}
    );

    foreach my $synonym ( @synonyms ) {
      my $url;
      $url = "$synonym->[2]$synonym->[0]$synonym->[3]" if ($synonym->[2]);
      print $sbeamsMOD->encodeSectionItem(
        key=>$synonym->[1],
        value=>$synonym->[0],
 tr_info => $tr,
        url=>$url,
      );
    }

    # If we have annotations
    if ( $biosequence->{annotated_gene_id} ){
      my $annot = $biolink->get_leaf_annotations( annotated_gene_id => $biosequence->{annotated_gene_id} );
      my %fx = ( C => 'Cellular Location',
                 F => 'Molecular Function',
                 P => 'Biological Process' );
      for my $type ( qw(F P C) ) {
        my $key = $type . 'pri';
        if ( $annot->{$key} ) {
          my $display = $sbeams->truncateStringWithMouseover( len => 80,
                                                 string => $annot->{$key});

          print $sbeamsMOD->encodeSectionItem( key   => $fx{$type},
 tr_info => $tr,
                                               value => $display );
        }
      }
    }

  }

  #### Define the desired columns in the query
  #### [friendly name used in url_cols,SQL,displayed column title]
  my @column_array = (
    ["peptide_accession","P.peptide_accession","Peptide Accession"],
    ["preceding_residue","PI.preceding_residue","Pre AA"],
    ["peptide_sequence","P.peptide_sequence","Peptide Sequence"],
    ["following_residue","PI.following_residue","Fol AA"],
    ["suitability_score","0.0001","Suitability Score"],
    ["best_probability","STR(PI.best_probability,7,3)","Best Prob"],
    ["best_adjusted_probability","STR(PI.best_adjusted_probability,7,3)","Best Adjusted Prob"],
    ["n_observations","PI.n_observations","N Obs"],
    ["empirical_proteotypic_score","STR(PI.empirical_proteotypic_score,7,2)","Empirical Proteotypic Score"],
    ["SSRCalc_relative_hydrophobicity","STR(P.SSRCalc_relative_hydrophobicity,7,2)","SSRCalc Relative Hydrophob"],
    ["n_protein_mappings","PI.n_protein_mappings","N Protein Mappings"],
    ["n_genome_locations","PI.n_genome_locations","N Genome Locations"],
    ["sample_ids","PI.sample_ids","Sample IDs"],
    ["is_subpeptide_of","PI.is_subpeptide_of","Parent Peptides"],
  );

  #### Build the columns part of the SQL statement
  my %colnameidx = ();
  my @column_titles = ();
  ## Sends @column_array_ref to build_SQL_columns_list, which
  ## (1) appends the 2nd element in array to $columns_clause
  ## (2) fills %colnameidx_ref as a hash with key = 1st element
  ## and value = 3rd element, and (3) fills @column_titles_ref
  ## array with the 3rd element
  my $columns_clause = $sbeams->build_SQL_columns_list(
    column_array_ref=>\@column_array,
    colnameidx_ref=>\%colnameidx,
    column_titles_ref=>\@column_titles
  );


  #### Define a query to return peptides for this protein
  $sql = qq~
     SELECT DISTINCT $columns_clause
     FROM $TBAT_PEPTIDE_INSTANCE PI
    INNER JOIN $TBAT_PEPTIDE P
          ON ( PI.peptide_id = P.peptide_id )
     LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
          ON ( PI.peptide_instance_id = PM.peptide_instance_id )
    INNER JOIN $TBAT_ATLAS_BUILD AB
          ON ( PI.atlas_build_id = AB.atlas_build_id )
     LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
          ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
     LEFT JOIN $TB_ORGANISM O
          ON ( BSS.organism_id = O.organism_id )
     LEFT JOIN $TBAT_BIOSEQUENCE BS
          ON ( PM.matched_biosequence_id = BS.biosequence_id )
     LEFT JOIN $TBAT_DBXREF DBX ON ( BS.dbxref_id = DBX.dbxref_id )
    WHERE 1 = 1
          AND AB.atlas_build_id IN ( $atlas_build_id )
	  AND BS.biosequence_id = $biosequence_id
    ORDER BY P.peptide_accession
  ~;


  #### Define the hypertext links for columns that need them
  %url_cols = (
    'Peptide Accession' => "$CGI_BASE_DIR/PeptideAtlas/GetPeptide?_tab=3&atlas_build_id=$atlas_build_id&searchWithinThis=Peptide+Name&searchForThis=%V&action=QUERY",
  );

  %hidden_cols = (
    'Suitability Score' => 1,
    'Pre AA' => 1,
    'Fol AA' => 1,
  );



  #########################################################################
  #### If QUERY or VIEWRESULTSET was selected, display the data
  if ($apply_action =~ /(QUERY|GO|VIEWRESULTSET)/) {

    #### Show the SQL that will be or was executed
    $sbeams->display_sql(sql=>$sql) if ($show_sql);

    #### If the action contained QUERY, then fetch the results from
    #### the database
    if ($apply_action =~ /(QUERY|GO)/i) {

      #### Fetch the results from the database server
      $sbeams->fetchResultSet(
        sql_query=>$sql,
        resultset_ref=>$resultset_ref,
      );

      #### Store the resultset and parameters to disk resultset cache
      $rs_params{set_name} = "SETME";
      $sbeams->writeResultSet(
        resultset_file_ref=>\$rs_params{set_name},
        resultset_ref=>$resultset_ref,
        query_parameters_ref=>\%parameters,
        resultset_params_ref=>\%rs_params,
        query_name=>"$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME",
      );
    }


    #### Get protein structure information
    my $protein_structure = getProteinStructure(
      biosequence_id => $biosequence_id,
    );

    my ( $obs, $peptides ) = getPeptideCount( biosequence => $biosequence,
                                            resultset_ref => $resultset_ref );

    # Straggler for protein section, doh!
    print $sbeamsMOD->encodeSectionItem(
 tr_info => $tr,
      key=>'Total peptides',
      value=>$obs
    ) . "</TABLE>\n" if $htmlmode;


  #############################################################
  ## Display the sequence graphic ##

  # Widget to allow show/hide of graphic section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprotein_graphic',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );

     
    my $graphic_section = getSequenceGraphic( build_id => $atlas_build_id,
                                         protein_data  => $biosequence,
                                               tr_info => $tr,
                                              );

    my $graphic_head = $sbeamsMOD->encodeSectionHeader( text => "Sequence Motifs", link => $link );
    print "<TABLE width=600>$graphic_head </TABLE> $graphic_section" if $htmlmode;

    #### Display the annotated sequence
    displayAnnotatedSequence(
         peptides => $peptides,
      biosequence => $biosequence,
      resultset_ref=>$resultset_ref,
      protein_structure => $protein_structure,
    );

    #### Display the annotated sequence
    #displayAnnotatedSequence(
    #  biosequence => $biosequence,
    #  resultset_ref=>$resultset_ref,
    #  line_length => 700000,
    #  enzyme => 'trypsin',
    #  protein_structure => $protein_structure,
    #);


  #############################################################
  # Widget to allow show/hide of observed peptides section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprotein_observedlist',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );


    my $observed_header = $sbeamsMOD->encodeSectionHeader(
                           text => 'Observed Peptides',
                           link => $link );

    print qq~ <TABLE width="600">$observed_header</TABLE><TABLE><TR $tr><TD COLSPAN=2>~ if $htmlmode;

    #### Create Cytoscape format files if selected
    my $java_web_start = { template => 'GetProtein' };
    if ($sbeams->output_mode() eq 'cytoscape') {
      prepareJavaWebStartFiles(
        rs_params_ref=>\%rs_params,
        resultset_ref=>$resultset_ref,
        query_parameters_ref=>\%parameters,
        url_cols_ref=>\%url_cols,
        column_titles_ref=>\@column_titles,
        hidden_cols_ref=>\%hidden_cols,
        java_web_start=>$java_web_start,
      );
    }


    #### Since we don't display the controls, make the default page size
    #### huge, otherwise the user may not see all peptides
    $rs_params{page_size} = 500;

    #### Display the resultset
    $sbeams->displayResultSet(
      resultset_ref=>$resultset_ref,
      query_parameters_ref=>\%parameters,
      rs_params_ref=>\%rs_params,
      url_cols_ref=>\%url_cols,
      hidden_cols_ref=>\%hidden_cols,
      max_widths=>\%max_widths,
      column_titles_ref=>\@column_titles,
      base_url=>$base_url,
      cytoscape=>$java_web_start,
    );


    #### Display a hyperlink for viewing this information in Cytoscape
    if ($sbeams->output_mode() eq 'html') {
      my $GetProtein_hlink = "$CGI_BASE_DIR/PeptideAtlas/GetProtein?atlas_build_id=$atlas_build_id&protein_name=$parameters{protein_name}&output_mode=cytoscape&action=GO";
      print qq~<TABLE><TR><TD><A HREF="$GetProtein_hlink"><IMG BORDER="0" SRC="$HTML_BASE_DIR/images/PAcyto_icon.png"></A></TD><TD valign="center"><A HREF="$GetProtein_hlink">[View peptides and related proteins as a network with Cytoscape]</A></TD></TR></TABLE><BR>~;
    }


    #### Display the resultset controls
#    $sbeams->displayResultSetControls(
#      resultset_ref=>$resultset_ref,
#      query_parameters_ref=>\%parameters,
#      rs_params_ref=>\%rs_params,
#      base_url=>$base_url,
#    );

    print "</TD></TR></TABLE>" if $htmlmode;


    #############################################################
    #### Display selected peptides - Experimental

    #### Widget to allow show/hide of section
    my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprotein_bestpeptideslist',
      visible => 0,
      tooltip => 'Show/Hide Section',
      imglink => 1,
      sticky => 1,
     );

    #### Display the section header
    my $bestPeptidesHeader = $sbeamsMOD->encodeSectionHeader(
      text => 'Best Peptides',
      link => $link
    );
    print qq~ <TABLE width="600">$bestPeptidesHeader</TABLE><TABLE><TR $tr><TD COLSPAN=2>~ if $htmlmode;

    #### Calculate the best peptides to use
    use SBEAMS::PeptideAtlas::BestPeptideSelector;
    my $bestPeptideSelector = new SBEAMS::PeptideAtlas::BestPeptideSelector;
    $bestPeptideSelector->setSBEAMS($sbeams);
    my $best_peptide_information = $bestPeptideSelector->getBestPeptides(
      atlas_build_id => $atlas_build_id,
      biosequence_id => $biosequence_id,
      query_parameters_ref=>\%parameters,
      resultset_ref => $resultset_ref,
      column_titles_ref=>\@column_titles,
    );

    #### Display the best peptide information
    my $samples = $bestPeptideSelector->getBestPeptidesDisplay(
      atlas_build_id => $atlas_build_id,
      best_peptide_information  => $best_peptide_information,
      query_parameters_ref=>\%parameters,
      column_titles_ref=>\@column_titles,
      link => $link,
      base_url=>$base_url,
      tr_info => $tr,
    );
    print "<TABLE width='600'>$samples</TABLE>" if $htmlmode;
    print "</TD></TR></TABLE>" if $htmlmode;


    #############################################################
    ## Display the samples list ##

    # Widget to allow show/hide of samples section
    my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprotein_samplelist',
                                                  visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                 imglink => 1,
                                                  sticky => 1 );

    my $sample_ids = getSampleList( resultset_ref=>$resultset_ref,);
    my $samples = $sbeamsMOD->getSampleDisplay( sample_ids => $sample_ids,
                                                      link => $link,
                                                      tr_info => $tr );
    print "<TABLE width='600'>$samples</TABLE>" if $htmlmode;


  #### If QUERY was not selected, then tell the user to enter some parameters
  } else {
    if ($sbeams->invocation_mode() eq 'http') {
      print "<H4>Select parameters above and press QUERY</H4>\n";
    } else {
      print "You need to supply some parameters to contrain the query\n";
    }
  }


} # end handle_request


sub getSequenceGraphic {

  ## read passed args, set up variables ##
  my %args = @_;

  my $tmhmm = $args{protein_data}->{transmembrane_topology};
  my $id =  $args{protein_data}->{biosequence_id};
  my $protseq = $args{protein_data}->{biosequence_seq};
  my $protlen = length( $protseq );

  # Had initially used the peptide query above, but the start/end coordinates 
  # were problematic.  Thus we need to do it again.
  my $sql = qq~
     SELECT DISTINCT
           P.peptide_accession,
           P.peptide_sequence,
           PI.n_genome_locations,
           PM.start_in_biosequence,
           PM.end_in_biosequence
    FROM $TBAT_PEPTIDE_INSTANCE PI INNER JOIN $TBAT_PEPTIDE P
      ON ( PI.peptide_id = P.peptide_id )
    LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
      ON ( PI.peptide_instance_id = PM.peptide_instance_id )
    INNER JOIN $TBAT_ATLAS_BUILD AB
      ON ( PI.atlas_build_id = AB.atlas_build_id )
    LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
      ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
    WHERE AB.atlas_build_id IN ( $args{build_id} )
	  AND PM.matched_biosequence_id = $id
    ORDER BY P.peptide_accession
  ~;
  my @rows = $sbeams->selectSeveralColumns( $sql );

  # Set up hash for storing point by point coverage info
  my %coverage;
  for my $idx ( 1..$protlen ) { $coverage{$idx} = 0; }

  # Define color mapping for various features.
  my %colors = ( Signal => 'cornflowerblue',
                 Anchor => 'lightskyblue',
          Transmembrane => 'greenyellow',
          Intracellular => 'coral',
          Extracellular => 'mediumseagreen',
               Coverage => 'beige',
             Translated => 'gainsboro',
               Observed => 'goldenrod' );

  # Define CSS classes
  my $sp = '&nbsp;' x 4;
  my $style =<<"  END_STYLE";
  <STYLE>
   .obs_sing { background-color: $colors{Observed} ;border-style: solid; border-color:gray; border-width: 1px  }
   .obs_multi { background-color: white ;border-style: solid; border-color:gray; border-width: 1px  }
   .tm_dom { background-color: $colors{Transmembrane} ;border-style: solid; border-color:gray; border-width: 1px  }
   .in_dom { background-color: $colors{Intracellular} ;border-style: solid; border-color:gray; border-width: 1px  }
   .ex_dom { background-color: $colors{Extracellular} ;border-style: solid; border-color:gray; border-width: 1px  }
   .anc_seq { background-color: $colors{Anchor};border-style: solid; border-color:gray; border-width: 1px  }
   .sig_seq { background-color: $colors{Signal};border-style: solid; border-color:gray; border-width: 1px  }
   .trans_seq { background-color: $colors{Translated};border-style: solid; border-color:gray; border-width: 1px  }
   .pep_cov { background-color: $colors{Coverage};border-style: solid; border-color:gray; border-width: 1px  }
   .outline { border-style: solid; border-color:gray; border-width: 1px }
   .sm_txt {  font-family: Helvetica, Arial, sans-serif; font-size: 8pt}
  </STYLE>
  END_STYLE


  ## Create main panel + sequence 'ruler' ##

  my $panel = Bio::Graphics::Panel->new( -length    => $protlen + 2,
                                         -key_style => 'between',
                                         -width     => 800,
                                      -empty_tracks => 'suppress',
                                         -pad_top   => 5,
                                        -pad_bottom => 5,
                                         -pad_left  => 10,
                                         -pad_right => 50 );

#  open( FIL, ">/tmp/colors.html" );
#  print FIL "<HTML><HEAD></HEAD><BODY><TABLE WIDTH=600>\n";
#  my @c = $panel->color_names();
#  for my $c ( @c ) { print FIL "<TR><TD BGCOLOR=$c WIDTH=5%>$sp</TD><TD>$c$sp$sp</TD></TR>\n"; }
#  print FIL "</TABLE></BODY></HTML>\n";
#  close FIL;

  my $ruler = Bio::SeqFeature::Generic->new( -end => $protlen,
                                           -start => 2,
                                    -display_name => 'Sequence Position');

  my $sequence = Bio::SeqFeature::Generic->new( -end => $protlen,
                                              -start => 1,
                                       -display_name => 'Sequence Position');

  ## Generage observed peptide tracks ##

  # Loop over peptides
  my @peptides;
  my %pep_info;
  my ( $multi, $single );
  foreach my $row (@rows) {
    my $acc  =  $row->[0];
    my $seq  =  $row->[1];
    my $score = ( $row->[2] > 1 ) ? 0 : 1;
    my $start =  $row->[3];
    my $stop  =  $row->[4];
    # accession isn't necessarily unique, need compound key...
    my $ugly_key = $acc . '::::' . $start . $stop; 
    my $f = Bio::SeqFeature::Generic->new(
                             -start => $start, 
                               -end => $stop,
                           -primary => $acc,
                      -display_name => $ugly_key,
                             -score => $score );

    push @peptides, $f;

    # Record the coverage for this peptide
    for my $idx ( $start..$stop ) { $coverage{$idx}++; }

    # count peptide type, to build appropriate legend 
    if ( $score ) {
      $single++; 
    } else {
      $multi++;
    }

    $pep_info{$ugly_key} = "$start - $stop, $seq";
  }

  # Calculate the coverage 'domains' 
  my @coverage;
  my $cstart = 0;
  my $cend = 0;
  my $in_coverage = 0;
  for my $key ( sort{ $a <=> $b } keys( %coverage ) ) {
    if ( !$in_coverage ) { # Not in coverage
      if ( $coverage{$key} ) {
        $cstart = $key;
        $cend = $key;
        $in_coverage = 1;
      } else {
        $in_coverage = 0;
        # No-op
      }
    } else { # Already in coverage
      if ( $coverage{$key} ) {
        # Start stays the same, increment end
        $cend = $key;
        $in_coverage = 1;
      } else {
        $in_coverage = 0;
        # Its showtime!
        my $f = Bio::SeqFeature::Generic->new( -start   => $cstart,
                                               -end     => $cend,
                                               -primary => 'Coverage',
                                               -display_name => 'Coverage' );
        push @coverage, $f;
        $cstart = 0;
        $cend = 0;
      }
    }
  }
  if ( $cend ) {
    my $f = Bio::SeqFeature::Generic->new( -start   => $cstart,
                                           -end     => $cend,
                                           -primary => 'Coverage',
                                      -display_name => 'Coverage' );
    push @coverage, $f;
  }


  ## Generate TMHMM-derived tracks ##

  # parse domain info
  my $tm_info = $biolink->get_transmembrane_info ( tm_info => $tmhmm, 
                                                       end => $protlen );
  # loop over domains, create features for each
  my @intra;
  my @extra;
  my @tmm;
  foreach my $region (@$tm_info) {
    my $primary = $region->[0];
    my $tag = $primary;
		
    my $f = Bio::SeqFeature::Generic->new(
                                 -start        => $region->[1],
                                 -end          => $region->[2] ,
                             -primary          => $primary ,
                             -display_name     => $primary ,
                             -tag              => { $primary => $tag }
                                         );
    if ( $tag =~ /Intracellular/i ) {
      push @intra, $f;
    } elsif ( $tag =~ /Extracellular/i ) {
      push @extra, $f;
    } else {
      push @tmm, $f;
    }
  }


  ## Generate Signal P related tracks ##

  my @signalp;
  my ( $anchor, $signal );
  if ( $args{protein_data}->{has_signal_peptide} ) {

    my $seqtype;
    if ( $args{protein_data}->{signal_peptide_is_cleaved} =~ /y/i ) {
      $seqtype = 'Signal';
      $signal++;
    } else {
      $seqtype = 'Anchor';
      $anchor++;
    }

    my $f = Bio::SeqFeature::Generic->new( -start => 1,
                                             -end => 1 + $args{protein_data}->{signal_peptide_length},
                                    -display_name => $seqtype ,
                                           -label => 0
                                         );

    push @signalp, $f;

  }


  ## Add all the tracks to the panel ##

  $panel->add_track( $ruler,
	                 	-glyph  => 'anchored_arrow',
                    -tick   => 2,
                    -height => 8,
                    -key  => 'Sequence Position' );

  # Add observed peptide track
  $panel->add_track( \@peptides,
                      -glyph       => 'graded_segments',
                      -bgcolor     => $colors{Observed},
                      -fgcolor     => 'black',
                      -font2color  => '#882222',
                      -key         => 'Observed Peptides',
                      -bump        => 1,
                      -height      => 8,
                      -label       => sub { my $f = shift; my $n = $f->display_name(); $n =~ s/(.*)::::.*/$1/g; return $n },
                      -min_score   => 0,
                      -max_score   => 1,
                     );

  # Add signalP track
  my $sigtype = ( $anchor ) ? 'Anchor' : 'Signal';
  $panel->add_track(
			\@signalp,
			-glyph       => 'segments',
			-bgcolor     => $colors{$sigtype},
			-fgcolor     => 'black',
			-key         => $sigtype . ' Sequence',
			-bump        => +1,
			-height      => 8,
      -legend      => 1,
			-label       => 0,
  );


  my %tracs = ( Intracellular => \@intra,
                Extracellular => \@extra,
                Transmembrane => \@tmm,
              );

  # Add tmhmm-related tracks
  for my $t ( qw( Transmembrane Intracellular Extracellular ) ) {
      $panel->add_track(
			$tracs{$t},
			-glyph       => 'segments',
			-bgcolor     => $colors{$t},
			-fgcolor     => 'black',
			-font2color  => 'red',
			-key         => "${t} Domain",
			-bump        => +1,
			-height      => 8,
      -legend      => 1,
			-label       => 0,
		);
  }

  # Add coverage track
  $panel->add_track( \@coverage,
                      -glyph       => 'segments',
                      -bgcolor     => $colors{Coverage},
                      -fgcolor     => 'black',
                      -key         => 'Sequence Coverage',
                      -connector   => 'solid',
                      -bump        => 0,
                      -height      => 8,
                      -label       => 0, # sub { my $f = shift; return $f->display_name},
      );

  $panel->add_track( $ruler,
	                 	-glyph  => 'anchored_arrow',
                    -tick   => 2,
                    -height => 8,
                    -key  => 'Sequence Position' );

  
#  $panel->add_track( $sequence,
#                    -glyph   => 'segments',
#                -bgcolor     => $colors{Translated},
#                      -key   => 'Translated Sequence',
#                     -tick   => 2 );

  # Set up graphic legend
  my @legend; 
  push @legend, "<TR> <TD CLASS=obs_sing>$sp</TD> <TD class=sm_txt>Observed peptide with single genome mapping</TD> </TR>\n" if $single;
  push @legend, "<TR> <TD CLASS=obs_multi>$sp</TD> <TD class=sm_txt>Observed peptide with ambiguous genome mapping</TD> </TR>\n" if $multi;
  push @legend, "<TR> <TD CLASS=sig_seq>$sp</TD> <TD class=sm_txt>Signal sequence predicted by Signal P</TD> </TR>\n" if $signal; 
  push @legend, "<TR> <TD CLASS=anc_seq>$sp</TD> <TD class=sm_txt>Anchor sequence predicted by Signal P</TD> </TR>\n" if $anchor;
  push @legend, "<TR> <TD CLASS=tm_dom>$sp</TD> <TD class=sm_txt>Transmembrane domain predicted by TMHMM</TD> </TR>\n" if @tmm;
  push @legend, "<TR> <TD CLASS=in_dom>$sp</TD> <TD class=sm_txt>Intracellular domain predicted by TMHMM</TD> </TR>\n" if @intra;
  push @legend, "<TR> <TD CLASS=ex_dom>$sp</TD> <TD class=sm_txt>Extracellular domain predicted by TMHMM</TD> </TR>\n" if @extra;
  push @legend, "<TR> <TD CLASS=pep_cov>$sp</TD> <TD class=sm_txt>Protein coverage by observed peptides</TD> </TR>\n" if @coverage;
#  push @legend, "<TR> <TD CLASS=trans_seq>$sp</TD> <TD class=sm_txt>Entire Translated Protein Sequence</TD> </TR>\n";

  my $legend = '';
  for my $item ( @legend ) {
    $legend .= $item;
  }

  # Create image map from panel objects. 
  # links and mouseover coords for peptides, mouseover coords only for others
  my $baselink = "$CGI_BASE_DIR/PeptideAtlas/GetPeptide?_tab=3&atlas_build_id=$args{build_id}&searchWithinThis=Peptide+Name&searchForThis=_PA_Accession_&action=QUERY";
  my $pid = $$;
  my @objects = $panel->boxes();
  my $map = "<MAP NAME='$pid'>\n";
  for my $obj ( @objects ) {
    my $hkey_name = $obj->[0]->display_name();
    my $link_name = $hkey_name;
    $link_name =~ s/(.*)::::.*/$1/g;  # Grrr...
    if ( $link_name =~ /^PAp\d+$/ ) { # Peptide, add link + mouseover coords/sequence
      my $coords = join( ", ", @$obj[1..4] );
      my $link = $baselink;
      $link =~ s/_PA_Accession_/$link_name/g;
      $map .= "<AREA SHAPE='RECT' COORDS='$coords' TITLE='$pep_info{$hkey_name}' TARGET='_peptides' HREF='$link'>\n";
    } else {
      my $f = $obj->[0];
      my $coords = join( ", ", @$obj[1..4] );
      my $text = $f->start() . '-' . $f->end();
      $map .= "<AREA SHAPE='RECT' COORDS='$coords' TITLE='$text'>\n";
    }
  }
  $map .= '</MAP>';


  # Create image in tmp space 
  my $file_name    = $pid . "_glyco_predict.png";
  my $tmp_img_path = "images/tmp";
  my $img_file     = "$PHYSICAL_BASE_DIR/$tmp_img_path/$file_name";

 	open( OUT, ">$img_file" ) || die "$!: $img_file";
	binmode(OUT);
	print OUT $panel->png;
	close OUT;

  my $tr = $args{tr_info} || '';
#  my $tr_link =  "<TR><TD>$link</TD></TR>";
  # Generate and return HTML for graphic
  my $graphic =<<"  EOG";
  <TABLE width='600'>
    <TR $tr> 
      <TD>
 	      <img src='$HTML_BASE_DIR/$tmp_img_path/$file_name' ISMAP USEMAP='#$pid' alt='Sorry No Img' BORDER=0>
  $map
      </TD>
    </TR>
    <TR $tr>
      <TD COLSPAN=2 ALIGN=RIGHT>
        <TABLE BORDER=0 class=outline>
        $legend
        </TABLE> 
      </TD>
    </TR>
  </TABLE>
  $style
  EOG

  return $graphic;
}

sub getPeptideCount {
  my %args = @_;
  my $SUB_NAME = $sbeams->get_subname();

  #### Decode the argument list
  my $resultset_ref = $args{'resultset_ref'}
   || die "ERROR[$SUB_NAME]: resultset_ref not passed";
  my $biosequence = $args{'biosequence'}
   || die "ERROR[$SUB_NAME]: biosequence not passed";
  my $line_length = $args{'line_length'} || 70;
  my $word_length = $args{'word_length'} || 10;
  my $enzyme = $args{'enzyme'} || '';
  my $protein_structure = $args{'protein_structure'};
  my $total_observations = $args{'total_observations'};

  #### Don't display unless HTML
  return unless ($sbeams->output_mode() eq 'html');

  #### Get the hash of indices of the columns
  my %col = %{$resultset_ref->{column_hash_ref}};

  #### Loop over all the peptides
  my $data_ref = $resultset_ref->{data_ref};
  my @peptides = ();
  foreach my $row (@{$data_ref}) {
    push(@peptides,$row->[$col{peptide_sequence}]);
   $total_observations += $row->[$col{n_observations}];
  }

  return( $total_observations, \@peptides );
}

###############################################################################
# displayAnnotatedSequence
###############################################################################
sub displayAnnotatedSequence {
  my %args = @_;
  my $SUB_NAME = 'displayAnnotatedSequence';


  #### Decode the argument list
  my $resultset_ref = $args{'resultset_ref'}
   || die "ERROR[$SUB_NAME]: resultset_ref not passed";
  my $biosequence = $args{'biosequence'}
   || die "ERROR[$SUB_NAME]: biosequence not passed";
  my $line_length = $args{'line_length'} || 70;
  my $word_length = $args{'word_length'} || 10;
  my $enzyme = $args{'enzyme'} || '';
  my $protein_structure = $args{'protein_structure'};
  my $total_observations = $args{'total_observations'};


  #### Don't display unless HTML
  return unless ($sbeams->output_mode() eq 'html');


  #### Get the hash of indices of the columns
  my %col = %{$resultset_ref->{column_hash_ref}};

  #### Loop over all the peptides
  my $data_ref = $resultset_ref->{data_ref};
  my @peptides = @{$args{peptides}};

  # Widget to allow show/hide of sequence display section
  my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'getprotein_sequence',
                                                visible => 1,
                                                tooltip => 'Show/Hide Section',
                                                imglink => 1,
                                                sticky => 1 );


  my $section_header = $sbeamsMOD->encodeSectionHeader(
    text=>'Sequence',
    link =>$link,
  );
  print qq~ <TABLE width="600"> $section_header <TR $tr><TD> ~;


  my $sequence = $biosequence->{biosequence_seq};
  my %start_positions;
  my %end_positions;

  foreach my $label_peptide (@peptides) {
    if ($label_peptide) {
      my $pos = -1;
      while (($pos = index($sequence,$label_peptide,$pos)) > -1) {
	$start_positions{$pos}++;
	$end_positions{$pos+length($label_peptide)}++;
	$pos++;
      }
    }
  }


  #### If transmembrane regions topology has been supplied, find the TMRs
  my %tmr_start_positions;
  my %tmr_end_positions;
  my %tmr_color;
  my $notes_buffer = '';
  if ($protein_structure->{transmembrane_topology}) {
    my $start_side = substr($protein_structure->{transmembrane_topology},0,1);
    my $tmp = substr($protein_structure->{transmembrane_topology},1,9999);
    my @regions = split(/[io]/,$tmp);
    foreach my $region (@regions) {
      my ($start,$end) = split(/-/,$region);
      $tmr_start_positions{$start-1} = $start_side;
      $tmr_color{$start-1} = 'orange';
      if ($start_side eq 'i') {
        $start_side = 'o';
      } elsif ($start_side eq 'o') {
        $start_side = 'i';
      } else {
        $start_side = '?';
      }
      $tmr_end_positions{$end} = $start_side;
      $tmr_color{$end} = 'orange';
    }
    $notes_buffer .= "(Used TMR topology string: $protein_structure->{transmembrane_topology})<BR>\n";
    #print "<A HREF=\"http://www.cbs.dtu.dk/cgi-bin/nph-webface?configfile=/usr/opt/www/pub/CBS/services/TMHMM-2.0/TMHMM2.cf&seqfile=outform=-noshort&SEQ=%3EANON%0D$sequence\">[See full TMHMM result]</A><BR>\n";
  }

  #### If there's a signal peptide, mark it as a blue
  if ($protein_structure->{has_signal_peptide} eq 'Y') {
    $tmr_start_positions{0} = '';
    $tmr_color{0} = 'blue';
    $tmr_end_positions{$protein_structure->{signal_peptide_length}} = '';
    $tmr_end_positions{$protein_structure->{signal_peptide_length}} = '/'
      if ($protein_structure->{signal_peptide_is_cleaved} eq 'Y');
    $tmr_color{$protein_structure->{signal_peptide_length}} = 'orange';
    $notes_buffer = "(signal peptide: Y, length: $protein_structure->{signal_peptide_length}, cleaved: $protein_structure->{signal_peptide_is_cleaved}, probability: $protein_structure->{has_signal_peptide_probability})\n".$notes_buffer;
  }


  print "<PRE>\n";


  my $seq_length = length($sequence);
  my $i = 0;
  my $color_level = 0;
  my $observed_residues = 0;

  my @annotation_lines;


  while ($i < $seq_length) {

    if ($end_positions{$i}) {
      if ($color_level == $end_positions{$i}) {
	print "</B></font>";
      }
      $color_level -= $end_positions{$i} unless ($color_level == 0);
    }


    if ($start_positions{$i}) {
      if ($color_level == 0) {
	print "<font color=\"red\"><B>";
      }
      $color_level += $start_positions{$i};
    }

    if ($color_level) {
      $observed_residues++;
    }

    print substr($sequence,$i,1);
    $i++;
    if ($i %$line_length == 0) {
      print "\n";
    } elsif ($enzyme && $enzyme eq 'trypsin') {
      if (substr($sequence,$i-1,2) =~ /[RK][A-O,Q-Z]/) {
	print " ";
      }
    } elsif ($i % $word_length == 0) {
      print " ";
    }


  }



  if ($color_level) {
    print "</B></font>";
  }

  print "<BR><BR>";
  print "Protein Coverage = ",int($observed_residues/$seq_length*1000)/10,
    "%";

  print "</TD></TR></TABLE>\n";
  #print "<BR><BR>Notes:<BR>\n$notes_buffer" if ($notes_buffer);


} # end displayAnnotatedSequence


###############################################################################
# getSamples
###############################################################################
sub getSamples {
  my %args = @_;
  my $SUB_NAME = 'getSamples';

  my $sql = qq~
    SELECT sample_id,sample_title
      FROM $TBAT_SAMPLE
     WHERE record_status != 'D'
     ORDER BY sample_id
  ~;

  my @samples = $sbeams->selectSeveralColumns($sql);

  return \@samples;

} # end getSamples


sub getSampleList {
  my %args = @_;
  my $SUB_NAME = 'getSampleList';

  #### Decode the argument list
  my $resultset_ref = $args{'resultset_ref'}
   || die "ERROR[$SUB_NAME]: resultset_ref not passed";

  #### Get the hash of indices of the columns
  my %col = %{$resultset_ref->{column_hash_ref}};

  #### Loop over all the peptides
  my $data_ref = $resultset_ref->{data_ref};
  my %observed_samples;
  foreach my $row (@{$data_ref}) {
    my $observed_sample_list = $row->[$col{sample_ids}];
    my @all = split(/[,;]/,$observed_sample_list);
    foreach my $element ( @all ) {
      $observed_samples{$element}++;
    }
  }
  my @keys = keys( %observed_samples );
  return \@keys;
}


###############################################################################
# getProteinStructure
###############################################################################
sub getProteinStructure {
  my %args = @_;
  my $SUB_NAME = 'getProteinStructure';


  #### Decode the argument list
  my $biosequence_id = $args{'biosequence_id'}
   || die "ERROR[$SUB_NAME]: biosequence_id not passed";

  #### Define query to get information
  my $sql = qq~
    SELECT n_transmembrane_regions,transmembrane_class,transmembrane_topology,
           has_signal_peptide,has_signal_peptide_probability,
           signal_peptide_length,signal_peptide_is_cleaved
      FROM $TBAT_BIOSEQUENCE_PROPERTY_SET
     WHERE biosequence_id = $biosequence_id
  ~;

  my @rows = $sbeams->selectHashArray($sql);

  if (scalar(@rows) != 1) {
    my %tmp = ();
    return(\%tmp);
  }

  return($rows[0]);

}



###############################################################################
# prepareJavaWebStartFiles
#
# Prepares the required noa and sif files for Cytoscape from this dataset
###############################################################################
sub prepareJavaWebStartFiles {
  my %args = @_;

  #### Process the arguments list
  my $resultset_ref = $args{'resultset_ref'};
  my $rs_params_ref = $args{'rs_params_ref'};
  my $query_parameters_ref = $args{'query_parameters_ref'};
  my $url_cols_ref = $args{'url_cols_ref'};
  my $hidden_cols_ref = $args{'hidden_cols_ref'};
  my $column_titles_ref = $args{'column_titles_ref'};
  my $java_web_start = $args{'java_web_start'};
  my %rs_params = %{$rs_params_ref};
  my %parameters = %{$query_parameters_ref};

  my $atlas_build_id = $parameters{atlas_build_id};

  #### Set up some data data structures to hold Java Web Start data
  my %java_web_start_file_header = ( 'network.sif' => undef,
				     'commonName.noa' => 'commonName',
				     'organism.noa' => 'species',
				     'webLookup.noa' => 'webLookup',
				     'bioentityType.noa' => 'bioentityType',
				   );
  while ( my ($filename,$header_name) = each %java_web_start_file_header ) {
    my @tmp = ( $header_name );
    $java_web_start->{files}->{$filename} = \@tmp;
  }

  my %protein_hash = ();
  my @new_protein_list = ( $query_parameters_ref->{protein_name} );
  my %peptide_hash = ();
  my @new_peptide_list = keys(%peptide_hash);
  my %interaction_hash;

  #### Keep looping until the entire network is fleshed out
  while (1) {

    #### Return peptide information for these proteins
    my $peptide_resultset = getPeptideInformationForProteins(
      protein_list_ref => \@new_protein_list,
      atlas_build_id => $query_parameters_ref->{atlas_build_id},
    );

    #### Also include all other columns
    my $all_columns = $peptide_resultset->{column_list_ref};
    my $cols = $peptide_resultset->{column_hash_ref};
    my $i=0;
    foreach my $column ( @{$all_columns} ) {
      my $title = $peptide_resultset->{column_titles_ref}->[$i++];
      my @tmp = ( $title || $column );
      unless ($java_web_start->{files}->{"$column.noa"}) {
	$java_web_start->{files}->{"$column.noa"} = \@tmp;
      }
    }

#print "Content-type: text/html\n\n<PRE>\n";

    my $nrows = scalar(@{$peptide_resultset->{data_ref}});
    my $col = $peptide_resultset->{column_hash_ref};
    foreach my $row ( @{$peptide_resultset->{data_ref}} ) {

      #### Determine the best canonical name. We must have one
      my $canonical_name = $row->[$col->{peptide_accession}];
      my $is_new_peptide = 0;
      unless ($peptide_hash{$canonical_name}) {
        $peptide_hash{$canonical_name}++;
        push(@new_peptide_list,$canonical_name);
	$is_new_peptide = 1;
      }

      #### Add connections to proteins
      my $edge = "$row->[$col->{biosequence_name}] contains $canonical_name";
      unless ($interaction_hash{$edge}) {
	push(@{$java_web_start->{files}->{'network.sif'}},$edge);
	$interaction_hash{$edge}++;
      }

      next unless ($is_new_peptide);

      #### Add standard attributes
      push(@{$java_web_start->{files}->{'commonName.noa'}},"$canonical_name = $canonical_name");
      push(@{$java_web_start->{files}->{'organism.noa'}},"$canonical_name = unknown");
      push(@{$java_web_start->{files}->{'webLookup.noa'}},"$canonical_name = $SERVER_BASE_DIR/$CGI_BASE_DIR/PeptideAtlas/GetPeptide?&atlas_build_id=$atlas_build_id&searchWithinThis=Peptide+Name&searchForThis=$canonical_name&action=QUERY");

      #### Add regular peptide attributes
      $i=0;
      foreach my $column ( @{$all_columns} ) {
        my $title = $peptide_resultset->{column_titles_ref}->[$i++];
        my $value = $row->[$col->{$column}];
        push(@{$java_web_start->{files}->{"$column.noa"}},
          "$canonical_name = $value") if ($value);
      }


      #### Calculate a special proteotypic attribute
      my $peptide_type = 'peptide';
      if ($row->[$cols->{n_protein_mappings}] == 1 &&
	  $row->[$cols->{n_observations}] > 2 &&
	  $row->[$cols->{empirical_proteotypic_score}] > 0.3) {
	$peptide_type = 'proteotypic peptide';
      }
      push(@{$java_web_start->{files}->{'bioentityType.noa'}},"$canonical_name = $peptide_type");

    }

    last if (scalar(@new_peptide_list) == 0);
    @new_protein_list = ();

    #######################################################
    #### Now get the protein information for these peptides

    #### Return protein information for these peptides
    my $protein_resultset = getProteinInformationForPeptides(
      peptide_list_ref => \@new_peptide_list,
      atlas_build_id => $query_parameters_ref->{atlas_build_id},
    );

    #### Also include all other columns
    my $all_columns = $protein_resultset->{column_list_ref};
    my $i=0;
    foreach my $column ( @{$all_columns} ) {
      my $title = $protein_resultset->{column_titles_ref}->[$i++];
      my @tmp = ( $title || $column );
      unless ($java_web_start->{files}->{"$column.noa"}) {
	$java_web_start->{files}->{"$column.noa"} = \@tmp;
      }
    }

    my $nrows = scalar(@{$protein_resultset->{data_ref}});
    my $col = $protein_resultset->{column_hash_ref};
    foreach my $row ( @{$protein_resultset->{data_ref}} ) {

      #### Determine the best canonical name. We must have one
      my $canonical_name = $row->[$col->{biosequence_name}];
      my $is_new_protein = 0;
      unless ($protein_hash{$canonical_name}) {
        $protein_hash{$canonical_name}++;
        push(@new_protein_list,$canonical_name);
	$is_new_protein = 1;
      }

      #### Add edges to peptides
      my $edge = "$row->[$col->{biosequence_name}] contains $row->[$col->{peptide_accession}]";
      unless ($interaction_hash{$edge}) {
	push(@{$java_web_start->{files}->{'network.sif'}},$edge);
	$interaction_hash{$edge}++;
      }

      next unless ($is_new_protein);

      #### Add standard attributes
      push(@{$java_web_start->{files}->{'commonName.noa'}},"$canonical_name = $canonical_name");
      push(@{$java_web_start->{files}->{'organism.noa'}},"$canonical_name = unknown");
      push(@{$java_web_start->{files}->{'webLookup.noa'}},"$canonical_name = $SERVER_BASE_DIR/$CGI_BASE_DIR/PeptideAtlas/GetProtein?atlas_build_id=$atlas_build_id&protein_name=$canonical_name&action=GO");
      push(@{$java_web_start->{files}->{'bioentityType.noa'}},"$canonical_name = protein");

      #### Add regular proteins attributes
      $i=0;
      foreach my $column ( @{$all_columns} ) {
        my $title = $protein_resultset->{column_titles_ref}->[$i++];
        my $value = $row->[$col->{$column}];
        push(@{$java_web_start->{files}->{"$column.noa"}},
          "$canonical_name = $value") if ($value);
      }

    }

    last if (scalar(@new_protein_list) == 0);
    @new_peptide_list = ();


  } # end while 1

} # end prepareJavaWebStartFiles



###############################################################################
# getPeptideInformationForProteins
#
# Returns a resultset of peptide information for an input list of proteins
###############################################################################
sub getPeptideInformationForProteins {
  my %args = @_;

  #### Process the arguments list
  my $protein_list_ref = $args{'protein_list_ref'};
  my $atlas_build_id = $args{'atlas_build_id'};


  #### Create a comma separated list of proteins
  my $protein_list_str = join("','",@{$protein_list_ref}) || '';
  $protein_list_str = "'$protein_list_str'";


  #### Define the desired columns in the query
  #### [friendly name used in url_cols,SQL,displayed column title]
  my @column_array = (
    ["peptide_accession","P.peptide_accession","Peptide Accession"],
    ["peptide_sequence","P.peptide_sequence","Peptide Sequence"],
    ["best_probability","STR(PI.best_probability,7,3)","Best Prob"],
    ["n_observations","PI.n_observations","N Obs"],
    ["empirical_proteotypic_score","STR(PI.empirical_proteotypic_score,7,2)","Empirical Proteotypic Score"],
    ["SSRCalc_relative_hydrophobicity","STR(P.SSRCalc_relative_hydrophobicity,7,2)","SSRCalc Relative Hydrophob"],
    ["n_protein_mappings","PI.n_protein_mappings","N Protein Mappings"],
    ["n_genome_locations","PI.n_genome_locations","N Genome Locations"],
    ["biosequence_name","BS.biosequence_name","Protein Name"],
  );

  #### Build the columns part of the SQL statement
  my %colnameidx = ();
  my @column_titles = ();
  ## Sends @column_array_ref to build_SQL_columns_list, which
  ## (1) appends the 2nd element in array to $columns_clause
  ## (2) fills %colnameidx_ref as a hash with key = 1st element
  ## and value = 3rd element, and (3) fills @column_titles_ref
  ## array with the 3rd element
  my $columns_clause = $sbeams->build_SQL_columns_list(
    column_array_ref=>\@column_array,
    colnameidx_ref=>\%colnameidx,
    column_titles_ref=>\@column_titles
  );
  my @column_list;
  foreach my $column ( @column_array ) {
    push(@column_list,$column->[0]);
  }

  #### Define a query to return peptides for this protein
  my $sql = qq~
     SELECT $columns_clause
     FROM $TBAT_PEPTIDE_INSTANCE PI
    INNER JOIN $TBAT_PEPTIDE P
          ON ( PI.peptide_id = P.peptide_id )
     LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
          ON ( PI.peptide_instance_id = PM.peptide_instance_id )
    INNER JOIN $TBAT_ATLAS_BUILD AB
          ON ( PI.atlas_build_id = AB.atlas_build_id )
     LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
          ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
     LEFT JOIN $TB_ORGANISM O
          ON ( BSS.organism_id = O.organism_id )
     LEFT JOIN $TBAT_BIOSEQUENCE BS
          ON ( PM.matched_biosequence_id = BS.biosequence_id )
     LEFT JOIN $TBAT_DBXREF DBX ON ( BS.dbxref_id = DBX.dbxref_id )
    WHERE 1 = 1
          AND AB.atlas_build_id IN ( $atlas_build_id )
	  AND BS.biosequence_name IN ( $protein_list_str )
    ORDER BY BS.biosequence_name,P.peptide_accession
  ~;

  my @rows = $sbeams->selectSeveralColumns($sql);

  my $resultset = {
    column_hash_ref => \%colnameidx,
    column_list_ref => ,\@column_list,
    column_titles_ref=>\@column_titles,
    data_ref => \@rows,
  };


  return $resultset;


  print "<PRE>Peptides:\n$sql\n";

  foreach my $row (@rows) {
    print "  $row->[0]\t$row->[8]\n";
  }

  print "</PRE>\n";

  return $resultset;

}




###############################################################################
# getProteinInformationForPeptides
#
# Returns a resultset of protein information for an input list of peptides
###############################################################################
sub getProteinInformationForPeptides {
  my %args = @_;

  #### Process the arguments list
  my $peptide_list_ref = $args{'peptide_list_ref'};
  my $atlas_build_id = $args{'atlas_build_id'};


  #### Create a comma separated list of proteins
  my $peptide_list_str = join("','",@{$peptide_list_ref}) || '';
  $peptide_list_str = "'$peptide_list_str'";


  #### Define the desired columns in the query
  #### [friendly name used in url_cols,SQL,displayed column title]
  my @column_array = (
    ["peptide_accession","P.peptide_accession","Peptide Accession"],
    ["biosequence_name","BS.biosequence_name","Protein Name"],
  );

  #### Build the columns part of the SQL statement
  my %colnameidx = ();
  my @column_titles = ();
  ## Sends @column_array_ref to build_SQL_columns_list, which
  ## (1) appends the 2nd element in array to $columns_clause
  ## (2) fills %colnameidx_ref as a hash with key = 1st element
  ## and value = 3rd element, and (3) fills @column_titles_ref
  ## array with the 3rd element
  my $columns_clause = $sbeams->build_SQL_columns_list(
    column_array_ref=>\@column_array,
    colnameidx_ref=>\%colnameidx,
    column_titles_ref=>\@column_titles
  );
  my @column_list;
  foreach my $column ( @column_array ) {
    push(@column_list,$column->[0]);
  }

  #### Define a query to return peptides for this protein
  my $sql = qq~
     SELECT $columns_clause
     FROM $TBAT_PEPTIDE_INSTANCE PI
    INNER JOIN $TBAT_PEPTIDE P
          ON ( PI.peptide_id = P.peptide_id )
     LEFT JOIN $TBAT_PEPTIDE_MAPPING PM
          ON ( PI.peptide_instance_id = PM.peptide_instance_id )
    INNER JOIN $TBAT_ATLAS_BUILD AB
          ON ( PI.atlas_build_id = AB.atlas_build_id )
     LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS
          ON ( AB.biosequence_set_id = BSS.biosequence_set_id )
     LEFT JOIN $TB_ORGANISM O
          ON ( BSS.organism_id = O.organism_id )
     LEFT JOIN $TBAT_BIOSEQUENCE BS
          ON ( PM.matched_biosequence_id = BS.biosequence_id )
     LEFT JOIN $TBAT_DBXREF DBX ON ( BS.dbxref_id = DBX.dbxref_id )
    WHERE 1 = 1
          AND AB.atlas_build_id IN ( $atlas_build_id )
	  AND P.peptide_accession IN ( $peptide_list_str )
    ORDER BY BS.biosequence_name,P.peptide_accession
  ~;

  my @rows = $sbeams->selectSeveralColumns($sql);

  my $resultset = {
    column_hash_ref => \%colnameidx,
    column_list_ref => ,\@column_list,
    column_titles_ref=>\@column_titles,
    data_ref => \@rows,
  };


  return $resultset;


  print "<PRE>\nProteins:\n$sql\n";

  foreach my $row (@rows) {
    print "  $row->[0]\t$row->[1]\n";
  }

  print "</PRE>\n";

  return $resultset;

}




