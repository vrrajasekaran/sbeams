#!/usr/local/bin/perl
#

###############################################################################
# Program     : GetTransitions
#
# Description : page retrieve peptides and MS/MS fragment ions from PABST
#               and PATR tables 
###############################################################################

$|++;

## Setup objects and globals 
use strict;
use Getopt::Long;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ( $q $current_contact_id $current_username
$PROG_NAME $USAGE %OPTIONS $QUIET $VERBOSE $DEBUG $DATABASE
$TABLE_NAME $PROGRAM_FILE_NAME $CATEGORY $DB_TABLE_NAME
@MENU_OPTIONS);

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::TabMenu;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;
use SBEAMS::PeptideAtlas::BestPeptideSelector;

use constant ROW_LIMIT => 50000;

# Set up Atlas objects
my $sbeams = new SBEAMS::Connection;
my $atlas = new SBEAMS::PeptideAtlas;
$atlas->setSBEAMS($sbeams);
$sbeams->setSBEAMS_SUBDIR( 'PeptideAtlas' );
my $best_peptide = new SBEAMS::PeptideAtlas::BestPeptideSelector;
$best_peptide->setAtlas( $atlas );
$best_peptide->setSBEAMS( $sbeams );
$PROG_NAME = 'GetTransitions';
my $pabst_build_id;

my $is_html = 0;
my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";

main();
$sbeams->profile_sql( list => 1 );
exit(0);
my %rs_params;

# Main Program
sub main 
{
  $log->debug( "in main" . time() );
  # Authenticate and exit if a username is not returned
  my $current_username = $sbeams->Authenticate( allow_anonymous_access => 1 );
  exit unless $current_username;

  $is_html = ( $sbeams->output_mode() eq 'html' ) ? 1 : 0;

  #### Read in the default input parameters
  my %parameters;

  $parameters{uploaded_file_not_saved} = 1;

  my $n_params_found = $sbeams->parse_input_parameters(
      q=>$q,parameters_ref=>\%parameters);


  %rs_params = $sbeams->parseResultSetParams(q=>$q);

  # Process generic "state" parameters before we start
  $sbeams->processStandardParameters(parameters_ref=>\%parameters);

  # This will look for mod-specific params and do the right thing
  $atlas->processModuleParameters(parameters_ref=>\%parameters);

  # Fetch pabst_build_id based on params. 
  # 1 - passed pabst_build_id param
  # 2 - passed organism
  # 3 - cached pabst_build_id cookie
  # 4 - global default
  $pabst_build_id = $best_peptide->get_pabst_build( %parameters );

  # This might have gotten overridden due to permissions.
  my $bad_build_specified = 0;
  if ( $parameters{pabst_build_id} && $parameters{pabst_build_id} != $pabst_build_id ) {
    $bad_build_specified++;
  }

  # set up some defaults, only in command-line mode, to time queries/operations
  if ( !$parameters{action} && !$is_html ) {
    $log->debug( "in the auto-setting mode, command-line only!"  . time());
    $parameters{n_highest_intensity_fragment_ions} = 4;
    $parameters{n_peptides_per_protein} = 5;
    $parameters{protein_name_constraint} = 'YAL003W%';
    $parameters{QUERY_NAME} = 'AT_GetPABSTList';
    $parameters{action} = 'QUERY';
    $parameters{pabst_build_id} = 12;
  }

  # Decide what action to take based on information so far

  print_form ( %parameters );  
  if ( ! $parameters{pabst_build_id} ) {
    print $sbeams->makeErrorText( "<BR>No build specified" );
  } elsif ( $bad_build_specified ) {
    print $sbeams->makeErrorText( "<BR>Specified build is not accessible to this user" );
  } elsif ( $parameters{action} eq 'QUERY' ) {
    $log->debug( "  Going to fetch transitions"  . time());
    fetch_transitions( %parameters );  
    $log->debug( "  Done fetching transitions"  . time());
  }
  $atlas->display_page_footer( close_tables => 0 );

} # end main


###############################################################################
# Handle Request
###############################################################################
sub print_form {

  my %args = @_;

  # Historical, don't ask.
  my %parameters = %args;

  my $project_id = $atlas->getProjectID(
    atlas_build_id => $parameters{atlas_build_id}
  );

  $atlas->display_page_header(project_id => $project_id);

  #### Show current user context information
  print "<BR>\n" if ($sbeams->output_mode() eq 'html');

  #$sbeams->printUserContext();

  #### Get the HTML to display the tabs
  my $tabMenu = $atlas->getTabMenu(
      parameters_ref => \%parameters,
      program_name => $PROG_NAME,
  );

  unless ( $atlas->is_srm_mode() ) {
    print $tabMenu->asHTML() if ($sbeams->output_mode() eq 'html');
  }

  #### Define some generic variables
  my ($i,$element,$key,$value,$line,$result,$sql);

  #### Define some variables for a query and resultset
  my %resultset = ();
  my $resultset_ref = \%resultset;
  my (%url_cols,%hidden_cols,%max_widths,$show_sql);

  #### Read in the standard form values
  my $apply_action    = $parameters{'action'} || $parameters{'apply_action'};
  my $TABLE_NAME = $parameters{'QUERY_NAME'};
  # Historical, don't ask.

    #### Set some specific settings for this program
    my $CATEGORY="Query Transitions";

    $TABLE_NAME="AT_GetPABSTList" unless ($TABLE_NAME);

    ($PROGRAM_FILE_NAME) =
        $atlas->returnTableInfo($TABLE_NAME,"PROGRAM_FILE_NAME");

    my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";

    #### Get the columns and input types for this table/query
    my @columns = $atlas->returnTableInfo($TABLE_NAME,"ordered_columns");

    my %input_types = 
        $atlas->returnTableInfo($TABLE_NAME,"input_types");


    #### Read the input parameters for each column
    my $n_params_found = $sbeams->parse_input_parameters(
        q=>$q,parameters_ref=>\%parameters,
        columns_ref=>\@columns,input_types_ref=>\%input_types);
     #$sbeams->printDebuggingInfo($q);


    #### If the apply action was to recall a previous resultset, do it
    my %rs_params = $sbeams->parseResultSetParams(q=>$q);

    #### Set some reasonable defaults if no parameters supplied
    unless ($n_params_found) 
    {
      $parameters{input_form_format} = "minimum_detail";
    }
    $parameters{n_peptides_per_protein} ||= 5;
    $parameters{n_highest_intensity_fragment_ions} ||= 4;
    if ( $parameters{peptides_only} ) {
      $parameters{n_highest_intensity_fragment_ions} = 1;
    }
    $parameters{pabst_build_id} = $pabst_build_id;

#    pabst_build_id=7
#    protein_name_constraint=Foo
#    upload_file=
#    peptide_sequence_constraint=
#    peptide_length=
#    empirical_proteotypic_constraint=
#    n_protein_mappings_constraint=
#    n_genome_locations_constraint=
#    n_highest_intensity_fragment_ions=3

    ##Input form:  action is set by PROGRAM_FILE_NAME, so sub it w/ display page:
    $sbeams->collectSTDOUT();

    my ( $tr, $link ) = $sbeams->make_table_toggle( name => 'pabst_penalty_form',
                                                 visible => 0,
                                                 tooltip => 'Show/Hide penalty form',
                                                  sticky => 0,
                                                 imglink => 0,
                                                textlink => 1,
                                               plaintext => 0,
                                                hidetext => 'Hide form',
                                                showtext => 'Show form' );


#    my ( $thtml, $tlink ) = $sbeams->make_toggle_section( name => 'pabst_penalty_form',
#                                                 visible => 1,
#                                                 tooltip => 'Show/Hide penalty form',
#                                                  sticky => 1,
#                                                 imglink => 0,
#                                                 content => '&nbsp;',
#                                                textlink => 1,
#                                                hidetext => 'Hide form',
#                                                showtext => 'Show form',
#                                               );
    my @link = split "\n", $link;
    my $script_css = join( "\n", @link[0..$#link-1] );

    print $script_css;

    $sbeams->display_input_form(
        TABLE_NAME=>$TABLE_NAME,
        CATEGORY=>$CATEGORY,
        apply_action=>$apply_action,
        parameters_ref=>\%parameters,
        input_types_ref=>\%input_types,
        mask_user_context=> '1',
        mask_query_constraints => 1,
    );
    my $form = $sbeams->fetchSTDOUT();
    my $id = 'ID="protein_name_constraint"';
    $form =~ s/(NAME=\"protein_name_constraint\")/$1 $id/;

    my $rt_select = get_rt_select( $parameters{rt_type} );

    # FINDME
    my ( $sub_form ) = $best_peptide->get_change_form( form_only => 1, hide_buttons => 1, shade_defs => 1, set_params => \%parameters );
    $sub_form =~ s/tbl_visible/tbl_hidden/gm;
   
    my $peptide_chk = "<INPUT TYPE=checkbox NAME=peptides_only></INPUT>";
    my $peptides_only_help = "<TD BGCOLOR=E0E0E0><IMG SRC='$HTML_BASE_DIR/images/greyqmark.gif' TITLE='Return peptide list only (no Q3 values)'</TD>";
    $form .= qq~ <TR><TD VALIGN=TOP NOBR><B>Get Peptides Only:</B></TD>$peptides_only_help<TD>$peptide_chk</TD></TR> ~;

#    $form =~ s/(\<INPUT TYPE="hidden" NAME="QUERY_NAME" VALUE="AT_GetPABSTList"\>)/$1<BR>$sub_form/gm;
#    $form =~ s/\<\/TABLE\>/<TR><TD COLSPAN=3> $sub_form<\/TD><\/TR><\/TABLE>/i;
#    $form .= "<TR><TD COLSPAN=3>$sub_form</TD></TR>\n";
    my $change_help = "<TD BGCOLOR=E0E0E0><IMG SRC='$HTML_BASE_DIR/images/greyqmark.gif' TITLE='Adjust PABST peptide parameters to fine-tune peptide list (advanced)'</TD>";
    $form .= qq~ <TR><TD VALIGN=TOP NOBR><B>Adjust weights:</B></TD>$change_help<TD>$link$sub_form</TD></TR> ~;

    my $select_list = get_cmod_select( $parameters{cmod_mass} );
    my $cmod_help = "<TD BGCOLOR=E0E0E0><IMG SRC='$HTML_BASE_DIR/images/greyqmark.gif' TITLE='Also fetch heavy-labeled versions of selected peptides'</TD>";
    $form .= qq~ <TR><TD VALIGN=TOP NOBR><B>Heavy label:</B></TD>$cmod_help<TD>$select_list</TD></TR> ~;

    # Min/Max mz values
    my $min_help = "<TD BGCOLOR=E0E0E0><IMG SRC='$HTML_BASE_DIR/images/greyqmark.gif' TITLE='Set minimum m/z threshold for transitions, applies to both precursor (Q1) and fragment ion (Q3) m/z'</TD>";
    my $max_help = "<TD BGCOLOR=E0E0E0><IMG SRC='$HTML_BASE_DIR/images/greyqmark.gif' TITLE='Set maximum m/z threshold for transitions, applies to both precursor (Q1) and fragment ion (Q3) m/z'</TD>";
    $form .= qq~ <TR><TD VALIGN=TOP NOBR><B>Minimum m/z:</B></TD>$min_help<TD><INPUT TYPE=TEXT NAME=min_mz SIZE=10 VALUE=$parameters{min_mz}></INPUT></TD></TR> ~;
    $form .= qq~ <TR><TD VALIGN=TOP NOBR><B>Maximum m/z:</B></TD>$max_help<TD><INPUT TYPE=TEXT NAME=max_mz SIZE=10 VALUE=$parameters{max_mz}></INPUT></TD></TR> ~;
#    $form .= qq~ <TR><TD VALIGN=TOP NOBR><B>Allowable Modifications:</B></TD><TD BGCOLOR=E0E0E0></TD><TD>$select_lists->[1]</TD></TR> ~;

    my $rt_help =  "<TD BGCOLOR=E0E0E0><IMG SRC='$HTML_BASE_DIR/images/greyqmark.gif' TITLE='Select type of RT value to show in results'</TD>";

    unless ( $sbeams->isGuestUser() ) {
      $form .= qq~ <TR><TD VALIGN=TOP NOBR><B>Elution Time Type</B></TD>$rt_help<TD>$rt_select</INPUT></TD></TR> ~;
    }

    print qq~
    $form
    ~;
#    <TR><TD COLSPAN=3>$sub_form</TD></TR>

    #### Display the form action buttons
    $sbeams->display_form_buttons(TABLE_NAME=>$TABLE_NAME);

} # end print_form

sub get_rt_select {
  my $rt_type = shift || 'SSRCalc';
  my $rt_select = "<SELECT NAME=rt_type>\n";

  my $sql = qq~
  SELECT DISTINCT elution_time_type FROM $TBAT_ELUTION_TIME_TYPE 
  WHERE record_status != 'D' 
  ~;

  my $sth = $sbeams->get_statement_handle( $sql );

#  for my $type ( 'SSRCalc', 'RT_catalog Chipcube', 'RT_catalog QTrap5500' ) {
  while ( my @row = $sth->fetchrow_array() ) {
    my $type = $row[0];
    my $selected = ( $rt_type eq $type ) ? 'selected' : '';
    $rt_select .= "<OPTION VALUE='$type' $selected>$type</OPTION>\n";
  }
  $rt_select .= "</SELECT>\n";
  return $rt_select;
}

sub get_cmod_select {
  my $curr_val = shift || '';

  my %sel = ( K8 => '', R10 => '', K6 => '', R6 => '' );
  my %seen;
  for my $curr ( split( ',', $curr_val ) ) {
    $curr =~ /(\w)\d+/;
    next if $seen{$1}++;
    $sel{$curr} = 'SELECTED';
  }

  my $cmod_sel = qq~
    <SELECT SIZE=4 MULTIPLE NAME=cmod_mass>
      <OPTION VALUE='' ></OPTION>
      <OPTION VALUE=K8 $sel{K8}>Lysine + 8</OPTION>
      <OPTION VALUE=R10 $sel{R10}>Arginine + 10</OPTION>
      <OPTION VALUE=K6 $sel{K6}>Lysine + 6</OPTION>
      <OPTION VALUE=R6 $sel{R6}>Arginine + 6</OPTION>
    </SELECT>
  ~;
  return $cmod_sel;
}


sub get_multi_selects {
  my $sql = qq~
  SELECT option_key,option_value FROM $TBAT_QUERY_OPTION 
  WHERE option_type = 'GetTransitions_Transition_Source' 
  AND record_status != 'D' 
  ORDER BY sort_order,option_value;
  ~;
  my $sth = $sbeams->get_statement_handle( $sql );
  my $src_select = "<SELECT MULTIPLE SIZE=4 NAME=transition_source>\n";
  while ( my @row = $sth->fetchrow_array() ) {
    $src_select .= qq~<OPTION VALUE="$row[0]" SELECTED>$row[1]</OPTION>\n~;
  }
  $src_select .= "</SELECT>\n";

  $sql = qq~
  SELECT option_key,option_value FROM $TBAT_QUERY_OPTION 
  WHERE option_type = 'GetTransitions_Modifications' 
  AND record_status != 'D' 
  ORDER BY sort_order,option_value;
  ~;
  $sth = $sbeams->get_statement_handle( $sql );
  my $mod_select = "<SELECT MULTIPLE SIZE=3 NAME=transition_mods>\n";
  $mod_select .= "<OPTION VALUE='none' SELECTED>none</OPTION>\n";
  while ( my @row = $sth->fetchrow_array() ) {
    $mod_select .= "<OPTION VALUE=$row[0]>$row[1]</OPTION>\n";
  }
  $mod_select .= "</SELECT>\n";
  return [$src_select, $mod_select];
}

sub fetch_transitions {
  my %args = @_;

  # Historical, don't ask.
  my %parameters = %args;

  # Hackage
  my $project_id = $atlas->getProjectID(
    atlas_build_id => $parameters{atlas_build_id}
  );

  my $content = '';

  #$sbeams->printUserContext();

  #### Define some generic variables
  my ($i,$element,$key,$value,$line,$result,$sql);


  $log->debug( "    Build constraints"  . time());
  #### Define some variables for a query and resultset
  my %resultset = ();
  my $resultset_ref = \%resultset;
  my (%url_cols,%hidden_cols,%max_widths,$show_sql);

  #### Read in the standard form values
  my $apply_action    = $parameters{'action'} || $parameters{'apply_action'};
  my $TABLE_NAME = $parameters{'QUERY_NAME'};

  #### If the apply action was to recall a previous resultset, do it


  #########################################################################
  #### Process all the constraints

  # Try to limit size of returned resultset.
  my %ok_param = ( overall => 0 );
	{ # Check params block

	  # Safe if protein_name is set and has no fully wildcarded terms
	  if ( $parameters{protein_name_constraint} ) {
	    if ( $parameters{protein_name_constraint} !~ /;%;|;%$|^%;|^%$/ ) {
				$ok_param{protein_name_constraint}++;
				$ok_param{overall}++;
			}
		}
	  if ( $parameters{peptide_sequence_constraint} ) {
	    if ( $parameters{peptide_sequence_constraint} !~ /^%$/ ) {
				$ok_param{peptide_sequence_constraint}++;
				$ok_param{overall}++;
			}
		}
	}

  #### Build atlas_build_id constraint
  my $atlas_build_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"PI.atlas_build_id",
      constraint_type=>"int_list",
      constraint_name=>"Atlas Build",
      constraint_value=>$parameters{atlas_build_id} );
  return if ($atlas_build_clause eq '-1');
  ##  replace AND with WHERE
  $atlas_build_clause =~ s/(.*)AND(.*)/$1WHERE$2/;

  my $pabst_build_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"PP.pabst_build_id",
      constraint_type=>"int_list",
      constraint_name=>"PABST Build",
      constraint_value=>$parameters{pabst_build_id} );
  return if ($pabst_build_clause eq '-1');

  #### Build consensus_library_id constraint
  my $consensus_library_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"NL.consensus_library_id",
      constraint_type=>"int_list",
      constraint_name=>"Consensus Library",
      constraint_value=>$parameters{consensus_library_id} );
  return if ($consensus_library_clause eq '-1');

  #### Build PEPTIDE_SEQUENCE constraint
  my $peptide_sequence_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"PP.peptide_sequence",
      constraint_type=>"plain_text",
      constraint_name=>"Peptide Sequence",
      constraint_value=>$parameters{peptide_sequence_constraint} );
  return if ($peptide_sequence_clause eq '-1');

  #### Build BEST_PROBABILITY constraint
  my $best_probability_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"PI.best_probability",
      constraint_type=>"flexible_float",
      constraint_name=>"Best Probability",
      constraint_value=>$parameters{best_probability_constraint} );
  return if ($best_probability_clause eq '-1');

  #### Build N_OBSERVATIONS constraint
  my $n_observations_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"PI.n_observations",
      constraint_type=>"flexible_int",
      constraint_name=>"Number of Observations",
      constraint_value=>$parameters{n_observations_constraint} );
  return if ($n_observations_clause eq '-1');

  #### Build N_SAMPLES constraint
  my $n_samples_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"PI.n_samples",
      constraint_type=>"flexible_int",
      constraint_name=>"Number of Samples",
      constraint_value=>$parameters{n_samples_constraint} );
  return if ($n_samples_clause eq '-1');


    #### Build EMPIRICAL_PROTEOTYPIC_SCORE constraint
    my $empirical_proteotypic_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.empirical_proteotypic_score",
        constraint_type=>"flexible_float",
        constraint_name=>"Empirical Proteotypic Score",
        constraint_value=>$parameters{empirical_proteotypic_constraint} );
  return if ($empirical_proteotypic_clause eq '-1');


    #### Build n_protein_mappings constraint
    my $n_protein_mappings_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.n_protein_mappings",
        constraint_type=>"flexible_int",
        constraint_name=>"n_protein_mappings",
        constraint_value=>$parameters{n_protein_mappings_constraint} );
  return if ($n_protein_mappings_clause eq '-1');

    #### Build n_genome_locations constraint
    my $n_genome_locations_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.n_genome_locations",
        constraint_type=>"flexible_int",
        constraint_name=>"n_genome_locations",
        constraint_value=>$parameters{n_genome_locations_constraint} );
  return if ($n_genome_locations_clause eq '-1');

    #### Build peptide_length constraint
    my $peptide_length_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"peptide_length",
        constraint_type=>"flexible_int",
        constraint_name=>"peptide_length",
        constraint_value=>$parameters{peptide_length} );
  return if ($peptide_length_clause eq '-1');
  $peptide_length_clause =~ s/peptide_length/LEN\(peptide_sequence\)/;

    #### Build transition_source constraint
    my $transition_source_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"transition_source",
        constraint_type=>"text_list",
        constraint_name=>"transition_source",
        constraint_value=>$parameters{transition_source} );
  return if ($transition_source_clause eq '-1');


  # provisional, try to handle newline delimited lists.
  $parameters{protein_name_constraint} =~ s/\r\n/;/g;
  $parameters{protein_name_constraint} =~ s/\n/;/g;
  $parameters{protein_name_constraint} =~ s/\s+/;/g;


  #### Build PROTEIN_NAME constraint
  my $biosequence_name_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"BS.biosequence_name",
        constraint_type=>"plain_text",
        constraint_name=>"Protein Name",
        constraint_value=>$parameters{protein_name_constraint} );
   return if ($biosequence_name_clause eq '-1');

  my %protein_hash;

  # protein name field supercedes (obviates) file upload
  if ( $parameters{upload_file} && !$biosequence_name_clause ) {

    ## upload the file to a file handler
    my $fh = $q->upload('upload_file');

    if (!$fh && $q->cgi_error && $is_html) {
      print $q->header(-status=>$q->cgi_error);
			exit;
    }

    my $max_cnt = 1000;
    # size constraint of 1 MB, restrict $count < $max_cnt
    if ( (-T $fh) && (-s $fh < 1000000) ) {
      my $count = 0;
      my $read_file=0;
      ## protein list
      my $prt;
      while ($prt=<$fh>) {
        chomp($prt);
        $prt =~ s/\s+$//;
        if ($prt) {
          $protein_hash{$prt}++;
          $count = $count + 1;
        }
        last if ($count >= $max_cnt );
      }
      # secondary param check block
  		# Make sure this isn't a null constraint if we are counting on it
	    if ( $count ) {
	      $ok_param{protein_file_constraint}++;
	      $ok_param{overall}++;
		  }
    }

    ## join with a commas:
    my $protein_list = "'" . join( "','", keys( %protein_hash)) . "'";

#    foreach my $pr (keys %protein_hash) {
#      $protein_list = "'$protein_hash{$pr}',$protein_list"; 
#    }
#    ## trim off last comma:
#    $protein_list =~ s/(.*)(,)$/$1/;

    $biosequence_name_clause = "     AND BS.biosequence_name IN ( $protein_list )" if $protein_list;
  }

  unless ( $ok_param{overall} ) {
    # Print page message
    # redirect back to form
		my $url = $q->self_url();
		print <<"    END";
		<H4><BR>
		Due to the size of the source dataset, you must provide either a protein list
    <BR> (via protein_name form field or uploaded file) or
		a peptide sequence constraint. <BR> A full wildcard search does not constitute a valid constraint. 
		<BR>
    </H4>
    END
		$log->warn( "Bad constraints, URL is $url" );

		exit;
	}


  ## n_fragment_ions defaults to 3
  my $n_fragment_ions = 3;
  if ($parameters{'n_highest_intensity_fragment_ions'} =~ /^(\d+)$/) {
    $n_fragment_ions = $1;
  }
  if ( $parameters{peptides_only} ) {
    $n_fragment_ions = 1;
  }

  ## n_peptides_per_protein defaults to 3 
  my $n_peps_per_prot = 3;
  if ($parameters{'n_peptides_per_protein'} =~ /^([\d]+)$/) {
    $n_peps_per_prot = $1;
  }


  my @column_array;

  my $peptide_sql;
  my %prot_peps;
  my %pep_frags;
  my %ce;
#  my @display_rows = ( [qw( Protein Sequence Chg q1_mz q3_mz Intensity Ion CE SSRCalc RT n_obs Annot Source ) ] );

  my %row2chg;

  my $is_changed = 0;
  my $default_params = $best_peptide->get_default_pabst_scoring();

  for my $pparam ( keys ( %{$default_params} ) ) {
    if ( defined $parameters{$pparam} ) {
      if ( $parameters{$pparam} ne $default_params->{$pparam} ) {
        $log->info( "$pparam is different, $parameters{$pparam} ne $default_params->{$pparam} " );
        $is_changed++;
      }
    }
  }

  if ( $is_changed ) {
    $best_peptide->set_pabst_penalty_values( %parameters );
  }

  $log->debug( "    done building constraints"  . time());
  #########################################################################
  #### If QUERY or VIEWRESULTSET was selected, display the data
  if ($apply_action =~ /QUERY/i ) {
    my $ed = "<td>&nbsp;</td>";

#    my $note = $sbeams->makeInfoText( "Note: masses are mono-isotopic" );
#    $content .= "<BR>$note\n"  if $is_html;

  my @headings = ( 'Protein', 'Pre AA', 'Sequence', 'Fol AA', 'Adj SS', 'Source', 'q1_mz', 'q1_chg', 'q3_mz', 'q3_chg', 'Label', 'Rank', 'RI', 'SSRT', 'n_obs' );

  my $ssr_field = 'SSRCalc_relative_hydrophobicity';
  my $ssr_clause = '';
  my $ssr_join = '';
  if ( $parameters{rt_type} || $parameters{rt_type} ne 'SSRCalc' ) {
    $headings[13] = 'RT_Cat';
    $ssr_field = 'elution_time';
    $ssr_join = qq~
     LEFT JOIN $TBAT_ELUTION_TIME ET ON ET.modified_peptide_sequence = PP.peptide_sequence
     LEFT JOIN $TBAT_ELUTION_TIME_TYPE ETT ON ET.elution_time_type_id = ETT.elution_time_type_id
    ~;

    $ssr_clause = " AND (elution_time_type = '$parameters{rt_type}' OR elution_time_type IS NULL)\n";
      
  }

    my $lib_sql = qq~
    SELECT DISTINCT preceding_residue, PP.peptide_sequence, following_residue,
    synthesis_adjusted_score, transition_source, precursor_ion_mass, 
    precursor_ion_charge, fragment_ion_mass, fragment_ion_charge,
    fragment_ion_label, ion_rank, relative_intensity, 
    $ssr_field, biosequence_name,
    merged_score, n_observations, source_build
    FROM $TBAT_PABST_PEPTIDE PP 
    JOIN $TBAT_PABST_PEPTIDE_MAPPING PM 
    ON PM.pabst_peptide_id = PP.pabst_peptide_id
    JOIN $TBAT_PABST_TRANSITION PT 
    ON PT.pabst_peptide_id = PP.pabst_peptide_id 
    JOIN $TBAT_BIOSEQUENCE BS
    ON BS.biosequence_id = PM.biosequence_id 
    $ssr_join
    WHERE pabst_build_id = $parameters{pabst_build_id}
      $pabst_build_clause
      $atlas_build_clause
      $peptide_sequence_clause
      $best_probability_clause
      $transition_source_clause
--      $empirical_proteotypic_clause
--      $n_protein_mappings_clause
--      $n_genome_locations_clause
      $peptide_length_clause
      $biosequence_name_clause
      $ssr_clause
    ORDER BY biosequence_name, 
    synthesis_adjusted_score DESC, PP.peptide_sequence,
    ion_rank ASC, relative_intensity DESC,  
    precursor_ion_charge ASC
    ~;

  my @headings = ( 'Protein', 'Pre AA', 'Sequence', 'Fol AA', 'Adj SS', 'Source', 'q1_mz', 'q1_chg', 'q3_mz', 'q3_chg', 'Label', 'Rank', 'RI', 'SSRT', 'n_obs' );

  if ( $parameters{rt_type} && $parameters{rt_type} ne 'SSRCalc' ) {
    $headings[13] = 'RT_Cat';
  }

  #  peptides_only
  if ( $parameters{peptides_only} ) {
    splice( @headings, 5, 8 );
  }

  my $headings = $atlas->get_column_defs( labels => \@headings, plain_hash => 1 );

  my $headings_ref = ( $sbeams->output_mode() =~ /html/i ) ? 
           $best_peptide->make_sort_headings( headings => $headings, default => 'adj_SS' ) :
           \@headings;
           
  my @peptides = ( $headings_ref );

  my $naa = $sbeams->makeInactiveText( 'n/a' );

#  my %src_name = ( P => 'Predicted', Q => 'QQQ-observed', T => 'Predicted', I => 'IT-observed', 'R' => 'PATR-validated' );
#  my %src_name = ( P => 'Predicted', Q => 'QQQ-observed', T => 'QTOF-observed', I => 'IT-observed', 'R' => 'PATR-validated' );
  my $instr2code = $best_peptide->getStaticInstrumentMap();
  my %src_name;
  for my $src ( keys( %{$instr2code} ) ) {
    my $code = $instr2code->{$src};
    if ( $src =~ /PATR/ ) {
      $src_name{$code} = $src . '-validated';
    } elsif ( $src =~ /Predicted/ ) {
      $src_name{$code} = $src;
    } else {
      $src_name{$code} = $src . '-observed';
    }
  }



  $log->debug( "Exec SQL: " . time() );
  my $sth = $sbeams->get_statement_handle( $lib_sql );
  $log->debug( "Done : " . time() );

  my %prots;

  my @namelist = ( join( '::', qw(protein  sequence q1_mz q3_mz RT rank q1_chg q3_chg peak_intensity ion_label collision SSR) ) );

  # placeholder, we don't have a source for retention time.
  my $rt = '';

  my %peps;
  my %patr_peps;

  my $organism = $best_peptide->getBuildOrganism( %parameters );

  # If the user has modified any of the weights we have to do this from scratch...
  if ( $is_changed ) {
     $log->debug( "PABST arameters have changed.  Collect db values: " . time() );

    # Collect cached peptides/values from db handle
    my @short_list;
    my %peptide_fragments;
    my $cnt;
    my $row_cnt = 0;
    while( my @row = $sth->fetchrow_array() ) {
      $row_cnt++;
      if ( $row_cnt >= ROW_LIMIT ) {
        print $sbeams->makeInfoText( "Maximum query size (" . ROW_LIMIT . ") exceeded, results are truncated" );
        last;
      }

      # Add each unique prot peptide
      my $peptide_key = join( '', @row[13,1] );
      if ( !$peptide_fragments{$peptide_key} ) {
        $peptide_fragments{$peptide_key} ||= []; 
        push @short_list, [@row];
      }
      push @{$peptide_fragments{$peptide_key}}, [@row];
    }
     $log->debug( "Run PABST scoring " . time() );
    # Run pabst scoring - will clobber input array
    $best_peptide->pabst_evaluate_peptides( peptides => \@short_list,
                                 previous_idx => 0, 
                                      seq_idx => 1, 
                                   follow_idx => 2, 
                                hydrophob_idx => 12,
                                    score_idx => 14,
                                                       );
 
    # Sort - might be time hog
    $log->debug( "Sorting " . time() );
    # Sort first by protein, next by adjusted score!
    @short_list = sort { $a->[13] cmp $b->[13] ||                    
                           $b->[19] <=> $a->[19] } @short_list;
    $log->debug( "Done! " . time() );

    # debug
#    for my $row ( @initial_list ){ #      $log->debug( "coming out, ($row->[1]) row has " . scalar( @{$row} ) . " items " ); }

    # Should now be sorted, just have to apply n_pep/prot and n_frag/pep logic,
    # and format output.
    $log->debug( "filling in transitions! " . time() );
    for my $peptide ( @short_list ) { 

      my @row = @{$peptide};
      my $prot = $row[13];

      $prots{$prot} ||= {};
      $prots{$prot}->{$row[1]}++;
      if ( scalar( keys( %{$prots{$prot}} ) ) > $n_peps_per_prot ) {
#        $log->debug( "2 many peps for $prot -  $row[1], $row[16],  $row[18]" );
        next; 
      }
#      $log->debug( "Got past peps for $prot - $row[1], $row[16],  $row[18]" );
      my $pep_key = $prot . $row[1];
#      $log->debug( "Pep key is $pep_key" );

      # Use frag for 4-11;
      # Hide redundant frags!
      my %frag_seen;
      for my $frag ( @{$peptide_fragments{$pep_key}} ) {

# 0 preceding_residue
# 1 peptide_sequence
# 2 following_residue
# 3 synthesis_adjusted_score
# 4 transition_source
# 5 precursor_ion_mass
# 6 precursor_ion_charge
# 7 fragment_ion_mass
# 8 fragment_ion_charge
# 9 fragment_ion_label
# 10 ion_rank
# 11 relative_intensity
# 12 SSRCalc_relative_hydrophobicity
# 13 biosequence_name
# 14 merged_score
# 15 n_observations
        # Problem cases 
        # 1) duplicate ions
        my $frag_key = join( ':', @{$frag}[1,6,8,9] );
        if ( $frag_seen{$frag_key}++ ) {
#          $log->debug( "rejected $frag_key for duplicity" );
          next;
        }

        # 2) fragment ion too big
        if ( abs( $frag->[5] * $frag->[6] - $frag->[7] * $frag->[8] ) < 5 ) {
#          $log->debug( "rejected $row[1] frag for too bigosity" );
          next;
        }

#        if ( $parameters{min_mz} && $parameters{min_mz} =~ /\d+/ ) {
#        if ( $parameters{min_mz} ) {
#          next if $parameters{min_mz} > $frag->[5] ||  $parameters{min_mz} > $frag->[7];
#        }
      if ( $parameters{min_mz} ) {
        next if $parameters{min_mz} > $frag->[5] ||  $parameters{min_mz} > $frag->[7];
      }
      if ( $parameters{max_mz} ) {
        next if $parameters{max_mz} < $frag->[5] ||  $parameters{max_mz} < $frag->[7];
      }

        $peps{$pep_key}++;
        last if $peps{$pep_key} > $n_fragment_ions;

        $row[10] = $peps{$pep_key};
  
        $row[6] = $frag->[6];
        $row[8] = $frag->[8];
        $row[9] = lcfirst($frag->[9]);
        $row[10] = $frag->[10];

        $row[5] = sprintf( "%0.2f", $frag->[5] );
        $row[4] = $src_name{$frag->[4]};
        $row[7] = sprintf( "%0.2f", $frag->[7] );
        $row[3] = sprintf( "%0.2f", $row[18] );
        $row[12] = sprintf( "%0.1f", $row[12] ) if $peps{$pep_key} == 1;

        my $ce = calculateCE( mz => $frag->[5], chg => $frag->[6] );

        if ( $frag->[11] ) {
          $row[11] = int( $frag->[11] );
        } else {
          $row[11] = ''; 
        }

        # Cache for xfer to ATAQs
        # protein  sequence q1_mz q3_mz RT rank q1_chg q3_chg peak_intensity ion_label collision SSR
        push @namelist, join( '::', $prot, @row[1,5,7],'',@row[10,6,8,11,9],$ce, $row[12] );

        if ( $row[15] && $is_html ) {
          $row[15] = "<A HREF='GetPeptide?atlas_build_id=$row[16];searchWithinThis=Peptide+Sequence&searchForThis=$row[1];action=QUERY'>$row[15]</A>";
        }

        if ( $is_html ) {
          $row[11] ||= $naa; 
        }
    
        push @peptides, [ $prot, @row[0..12,15] ];

      }

    } # End loop sorted list



  # If no params were changed, use static values
  } else {
     $log->debug( "Iterating over results " . time() );

    my %frag_seen;
    my $row_cnt = 0;
    while( my @row = $sth->fetchrow_array() ) {
      my $prot = $row[13];

      $prots{$prot} ||= {};
      $prots{$prot}->{$row[1]}++;

      # Do we have enough peptides already?
      if ( scalar( keys( %{$prots{$prot}} ) ) > $n_peps_per_prot ) {
        next; 
      }

      my $pep_key = $prot . $row[1];
      $peps{$pep_key} ||= 0; 

      # Do we have enough fragments already?
      next if $peps{$pep_key} >= $n_fragment_ions;

# 0 preceding_residue
# 1 peptide_sequence
# 2 following_residue
# 3 synthesis_adjusted_score
# 4 transition_source
# 5 precursor_ion_mass
# 6 precursor_ion_charge
# 7 fragment_ion_mass
# 8 fragment_ion_charge
# 9 fragment_ion_label
# 10 ion_rank
# 11 relative_intensity
# 12 SSRCalc_relative_hydrophobicity
# 13 biosequence_name
# 14 merged_score
# 15 n_observations
      # Problem cases 
      # 1) duplicate ions

      my $frag_key = join( ':', @row[1,6,8,9] );
      if ( $frag_seen{$frag_key}++ ) {
#        $log->debug( "rejected $frag_key for duplicity" );
        next;
      }

      # 2) fragment ion too big
      if ( abs( $row[5] * $row[6] - $row[7] * $row[8] ) < 5 ) {
#        $log->debug( "rejected $row[1] frag $row[9] for too bigosity" );
        next;
      }

#      if ( $parameters{min_mz} && $parameters{min_mz} =~ /\d+/ ) {
      if ( $parameters{min_mz} ) {
        next if $parameters{min_mz} > $row[5] ||  $parameters{min_mz} > $row[7];
      }
      if ( $parameters{max_mz} ) {
        next if $parameters{max_mz} < $row[5] ||  $parameters{max_mz} < $row[7];
      }

      $peps{$pep_key}++;

      $row[10] = $peps{$pep_key};
      $row[9] = lcfirst($row[9]);
  
      $row[5] = sprintf( "%0.2f", $row[5] );
      $row[4] = $src_name{$row[4]};
      $row[7] = sprintf( "%0.2f", $row[7] );
      $row[3] = sprintf( "%0.2f", $row[3] );
      $row[12] = ( $row[12] ) ? sprintf( "%0.1f", $row[12] ) : '';
      if ( $row[11] ) {
        $row[11] = int( $row[11] );
      } elsif ( $is_html ) {
        $row[11] = $naa; 
      } else {
        $row[11] = ''; 
      }
  
      my $ce = calculateCE( mz => $row[5], chg => $row[6] );


      $patr_peps{$row[1]}++;

      # Cache for xfer to ATAQs
      # protein  sequence q1_mz q3_mz RT rank q1_chg q3_chg peak_intensity ion_label collision SSR
      push @namelist, join( '::', $prot, @row[1,5,7],'',@row[10,6,8,11,9],$ce, $row[12] );

      if ( $row[15] && $is_html ) {
        $row[15] = "<A HREF='Summarize_Peptide?searchWithinThis=Peptide+Sequence&searchForThis=$row[1];action=QUERY'>$row[15]</A>";
      }

      if ( $is_html ) {
        $row[11] ||= $naa; 
      }
    
# 0 prot
# 2 peptide_sequence
# 6 precursor_ion_mass
# 7 precursor_ion_charge
# 8 fragment_ion_mass
# 9 fragment_ion_charge
# 10 fragment_ion_label
      push @peptides, [ $prot, @row[0..12,15] ];

      # Manually build Lys/Arg SILAC code
      if ( $parameters{cmod_mass} && !$parameters{peptides_only} ) {

        my %seen;
        for my $mod ( split( ',', $parameters{cmod_mass} ) ) {

          my ( $aa, $mass ) = $mod =~ /^(\w)(\d+)$/;
  
          if ( $aa && $mass ) {
            $log->debug( "$mod is actionable" );

            # Only consider the first instance of any AA
            next if $seen{$aa}++;
  
            my $annot = '';
            if ( $aa =~ /R/i ) {
              my $mod_aa = $mass + 174;
              $annot = "R[$mod_aa]";
            } else {
              my $mod_aa = $mass + 146;
              $annot = "K[$mod_aa]";
            }

            my @mod_row = ( $prot, @row[0..12,15] );
            # Omit double labels for now
            next if $mod_row[2] =~ /[RK].*K$/;
            next unless $mod_row[10] =~ /^y/i;


            if ( $mod_row[2] =~ /$aa$/ ) {
              $log->debug( "seq is $mod_row[2] and annot is $annot before" );
                $mod_row[2] =~ s/$aa$/$annot/;
              $log->debug( "seq is $mod_row[2] and annot is $annot after" );
                $mod_row[6] = sprintf( "%0.2f", $mod_row[6] + $mass/$mod_row[7] );
                $mod_row[8] = sprintf( "%0.2f", $mod_row[8] + $mass/$mod_row[9] );
#                $mod_row[8] += $mass/$mod_row[9];
                $mod_row[14] = '';
                push @peptides, \@mod_row;
            }
          } else {
            $log->debug( "$parameters{cmod_mass} is nothing!" );
          }
        }
      }
#      <OPTION VALUE=K8 >Lysine + 8</OPTION>
#      <OPTION VALUE=R10 >Arginine + 10</OPTION>
# 1 sequence
# 2 q1_mz
# 3 q3_mz
# 6 q1_chg
# 7 q3_chg

      $row_cnt++;
      if ( $row_cnt >= ROW_LIMIT ) {
        print $sbeams->makeInfoText( "Maximum query size (" . ROW_LIMIT . ") exceeded, results are truncated" );
        last;
      }
    } # End loop over resultset

  }

  $log->debug( "Done! " . time() );
  $log->debug( "processed " . scalar( @namelist )  . " transitions " );

  $log->debug( "fetching from PATR ! " . time() );

# 0 preceding_residue
# 1 peptide_sequence
# 2 following_residue
# 3 synthesis_adjusted_score
# 4 transition_source
# 5 precursor_ion_mass
# 6 precursor_ion_charge
# 7 fragment_ion_mass
# 8 fragment_ion_charge
# 9 fragment_ion_label
# 10 ion_rank
# 11 relative_intensity
# 12 SSRCalc_relative_hydrophobicity
# 13 biosequence_name
# 14 merged_score
# 15 n_observations

  my @peps = keys( %patr_peps );
  my $patr = get_PATR_transitions( peptides => \@peps );

#  SELECT DISTINCT P.peptide_sequence, modified_peptide_sequence, peptide_charge,
#  q1_mz ,q3_mz, q3_ion_label, collision_energy,
#  SSRCalc_relative_hydrophobicity, retention_time, 'na', ''
#  0 => protein
#  1 => pre
#  2 => seq
#  3 => post

  for ( my $i = 0; $i <= $#peptides; $i++ ) {
    my $pep = $peptides[$i];
    if ( $patr->{$pep->[2]} ) {
      $peptides[$i] = $patr->{$pep->[2]};
    }
    if ( $parameters{peptides_only} ) {
      splice( @{$pep}, 5, 8 ) if $i;
    }
  }
  $log->debug( "Done ! " . time() );


# prot Protein => 'Protein Name/Accession',
# 0 Pre => 'Previous amino acid',
# 1 Sequence => 'Amino acid sequence of peptide',
# 2 Fol => 'Followin amino acid',
# 3 'Score' => 'Adjusted proteotypic score',
# 4 Src => 'Transition source, one of PATR, QQQ (triple quad), IT (ion trap), IS (In silico/theoretical)',
# 5 Q1_mz => 'Precursor ion m/z',
# 6 Q1_chg => 'Precursor ion charge',
# 7 Q3_mz => 'Fragment ion m/z',
# 8 Q3_chg => 'Fragment ion charge',
# 9 Label => 'Fragment ion label (series/number)',
# 10 Rank => 'PABST transition rank',
# 11 RI => 'Fragment peak relative intensity (scaled to 10000 Units)',
# 12 SSR => 'SSRCalc',
# 13 Protein name => 
# 13 Merged score =>  

  my $align = [qw(center center left center center right right right center right left right right)];

#  unshift @headings, 'PSieve';
#	$log->debug( "later: " . join( "\:", @headings ) ); 
  my $col_info = $atlas->get_column_defs( labels => \@headings );
#      my $headings = $atlas->get_column_defs( labels => \@headings, plain_hash => 1 );
  my $help_text = $atlas->make_table_help( description => 'Q1/Q3 transition pairs for SRM experiments',
                                                   entries => $col_info,
                                                   ); 

  my $change_on = 2;
  if ( $args{cmod_mass} && !$args{peptides_only}  ) {
    $change_on = 10;
  }

  my ( $html, $rs_name ) = $atlas->encodeSectionTable( header => 1, 
                                                        width => '600',
                                                      tr_info => $args{tr},
                                                       align  => $align,
                                                  rs_headings => \@headings,
                                                         rows => \@peptides,
                                                 rows_to_show => 20,
                                                     max_rows => 500,
                                                    help_text => $help_text,
                                                  chg_bkg_idx => $change_on, 
                                                 set_download => 'Download peptides', 
                                                  file_prefix => 'best_peptides_', 
                                                     bg_color => '#EAEAEA',
                                                     sortable => 1,
                                                     table_id => 'pabst',
                                                  close_table => 1,
                                                     );

  # "Publish" data as indirect resource for firegoose.  
  my $namelist = join( "\n", @namelist );
  my $tempfile = $sbeams->writeSBEAMSTempFile( content => $namelist );
  my @name = split "/", $tempfile;
  my $base = $q->url( -base => 1 );
  my $tmpfile_url = "$base/$HTML_BASE_DIR/tmp/$name[$#name]";

  my $gXML =  $sbeams->getGaggleXML( data => $tmpfile_url,
                                organism => $organism, 
                                  object => 'namelist', 
                                   start => 1, 
                                    name => 'SRM_transitions', 
                                    type => 'indirect' );



      
				my $rs = $atlas->get_cached_resultset( rs_name => $rs_name );
      if ( $is_html ) {
        $content .= "<BR><BR><TABLE>$html</TABLE> $gXML";

      } else {

        $sbeams->displayResultSet( resultset_ref => $rs,
                             query_parameters_ref=>\%parameters,
                             rs_params_ref=> \%rs_params,
                             url_cols_ref=> [],
                             hidden_cols_ref=> {},
                             max_widths=> {},
                             column_titles_ref=> $rs->{column_list_ref},
                             base_url=> '',
														 output_mode => $sbeams->output_mode()
                                  );


      }


    #### If QUERY was not selected, then tell the user to enter some parameters
  } else {
    if ($sbeams->invocation_mode() eq 'http' && $is_html ) {
      $content .= "<H4>Select parameters above and press QUERY</H4>\n";
    } else {
      $content .= "You must supply some parameters to contrain the query\n";
    }
  }

  print $content;

} # end fetch_transitions

sub get_PATR_transitions {
  return {};
  my %args = @_;

  # Superfluous
#  return unless $args{peptides};
#  my $peptide_clause = " WHERE P.peptide_sequence IN ( ";
#  my $sep = '';
#  for my $pep ( @{$args{peptides}} ) {
#    next if $pep =~ /amino acid/i;
#    $peptide_clause .= $sep . "'" . $pep . "'";
#    $sep = ',';
#  }
#  $peptide_clause .= ")\n";

  my $sql = qq~
  SELECT DISTINCT P.peptide_sequence, modified_peptide_sequence, peptide_charge,
  q1_mz ,q3_mz, q3_ion_label, collision_energy,
  SSRCalc_relative_hydrophobicity, retention_time, 'na', ''
  FROM $TBAT_SRM_TRANSITION SMT 
  JOIN $TBAT_PEPTIDE P ON P.peptide_sequence = SMT.stripped_peptide_sequence
  ORDER BY modified_peptide_sequence, peptide_charge, transition_suitablity_level,
  q1_mz, q3_mz
 
  ~;
#  $log->debug( $sql );

  my $sth = $sbeams->get_statement_handle($sql);

  my %pep_rows;
  while ( my @row = $sth->fetchrow_array() ) {
    $pep_rows{$row[0]} = \@row;
  }
  return \%pep_rows;
}

sub calculateCE {
  my %args = @_;
  for my $attr ( qw( charge mz ) ) {
    return '' unless $attr;
  }
  my $ce = '';
  if ( $args{charge} == 2 ) {
    $ce = ( 0.044 * $args{mz} ) + 5.5;
  } elsif ( $args{charge} == 3 ) {
    $ce = ( 0.051 * $args{mz} ) + 0.55
  }
  return sprintf( "%0.1f", $ce);
}


