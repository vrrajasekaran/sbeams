#!/usr/local/bin/perl

###############################################################################
# $Id: $
#
# SBEAMS is Copyright (C) 2000-2007 Institute for Systems Biology
# This program is governed by the terms of the GNU General Public License (GPL)
# version 2 as published by the Free Software Foundation.  It is provided
# WITHOUT ANY WARRANTY.  See the full description of GPL terms in the
# LICENSE file distributed with this software.
###############################################################################


###############################################################################
# Get the script set up with everything it will need
###############################################################################
use strict;
#use vars qw ($sbeams);
use lib qw (../../lib/perl);
#use CGI::Carp qw(fatalsToBrowser croak);

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::DataTable;
use SBEAMS::Connection::GoogleVisualization;
use SBEAMS::Connection::TabMenu;


use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;


###############################################################################
# Global Variables
###############################################################################
my $sbeams = new SBEAMS::Connection;
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);
my $atlas = new SBEAMS::PeptideAtlas;
$atlas->setSBEAMS($sbeams);

# Read input parameters
my $params = process_params();

my $show_image = 0;


{ # Main 

	my $t0 = time;
    # Authenticate or exit
    my $username = $sbeams->Authenticate( permitted_work_groups_ref => 
                                                      ['PeptideAtlas_user',
                                                      'PeptideAtlas_admin', 
                                                      'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
                                                      # connect_read_only=>1,
                                                      allow_anonymous_access=>1,
                                              ) || exit;


    ## get current settings
    my $project_id = $sbeams->getCurrent_project_id();

    my $build_help = get_table_help( table => 'build' );
    my $batch_help = get_table_help( table => 'batch' );
    my $mayu_help = get_table_help( table => 'mayu' );

    my $page = $sbeams->getGifSpacer( 700 ) . "<BR>\n";
  #### Get the HTML to display the tabs
    my $tabMenu = $atlas->getTabMenu(
      parameters_ref => $params,
      program_name => 'buildDetails',
    );
#		my $back = $sbeams->getBackForm();
    $page .=<<"    END";
		$tabMenu

    <P>
    <!--This shows some information about the currently selected build.
    <!--You can view the details of other builds by selecting an 
    item in the list below.  Although this will change build whose statistics 
    are to be displayed, it will not change your currently selected build.-->
    </P>
    $build_help
    END

    # We are not forcing the user into the new build - is that correct?
    my $build_id = $params->{atlas_build_id} || $atlas->getCurrentAtlasBuildID(parameters_ref => $params);
    my $valid_build = 1;
    if ( !grep /^$build_id$/, $atlas->getAccessibleBuilds() ) {
#      die( "Access to specified build is not allowed" );
       $atlas->display_page_header();
       $build_id = $atlas->getCurrentAtlasBuildID(parameters_ref => $params);
		   $atlas->display_page_footer();
       exit;
    }


    # Add general section 
#  print STDERR 'build overV ' . time() . "\n";
    $page .= get_build_overview ( $build_id );
#  print STDERR 'sample info ' . time() . "\n";

    my $proteome_cover = $atlas->get_proteome_coverage( $build_id );
    $page .= "<BR>\n";
    $page .= $proteome_cover;
    $page .= "<BR>\n";

    my ( $sample_table, $sample_arrayref ) = get_sample_info( $build_id );
    my ( $chart_div, $header ) = get_draw_chart_function( $sample_arrayref );

    $page .= "<BR>$batch_help\n";
    $page .= $sample_table;
    $page .= "<BR>\n";

    # Print what we already have, speed up apparent page loading time.
    $atlas->display_page_header( header_info => $header, project_id => $project_id, onload => 'sortables_init()', sortable => 1 );
		print $page;

    my $build_path = get_build_path( build_id => $build_id );
    my $mayu_data_path = "$build_path/analysis/Mayu_out.csv";
    if ( -e $mayu_data_path ) {
      $page = "<BR>$mayu_help\n";
      $page .= get_mayu_info( $mayu_data_path );
      print $page;
    }

#  print STDERR 'showtime ' . time() . "\n";
    # Add peptide stats section
    # Add graphic

		if ( $show_image ) {
      my $plots = $page = get_build_plots ( $build_id, $chart_div ); 
	  	print $plots;
		}
    
    if ( 1 ) {
      my $map_display = getSampleMapDisplay ( %{$params}, build_id => $build_id );
    	print $map_display;
    }
		$atlas->display_page_footer();
    
	my $tx = time;
  my $td = $tx - $t0;
  $log->debug("No SQL, time is $td for the whole page\n");

} # end main

sub get_table_help {
  my %args = @_;
  my $name = $args{table};
  return '' unless $name;
  $args{mode} ||= 'section';
  my @entries;
  my $hidetext;
  my $showtext;
  my $heading;
  my $description;

  if ( $name eq 'build' ) {  
    @entries = ( { key => 'Build Name', value => 'The simple name for this build, usually contains organism, prophet cutoff, and other information. ' },
                 { key => 'Build Description', value => 'More detailed information about build. ' },
                 { key => 'Reference Database', value => 'Database to which peptides were mapped, generally different than search database.  This mapping is done by running BLAST, and allows the peptides to be mapped the the organism\'s genomic sequence. ' },
                 { key => 'Build Date', value => 'Date upon which build was finished. ' },
                 { key => '# Samples', value => 'The number of individual samples which comprise this build.  Each sample contains one or more LCMS/MS runs, and generally corresponds to a single scientific experiment.' } ,
                 { key => 'Distinct Peptides', value => 'This shows the number of distinct peptide sequences that were seen in this build.  Observations of the peptide in different charge states or with different modifications are coalesced.' } ,
                 { key => 'Total Observations ', value => 'The total number of spectra that yeilded identifications above the build threshold.  Observations of the same base peptide sequences multiple times or in various charge states/modifications, whould each contribute to the total' },
                 { key => 'Probability threshold', value => 'iProphet probability threshold applied to each experiment in this build' },
                 { key => 'Canonical Proteins', value => 'Minimally redunant set of proteins required to explain (virtually) all non-decoy peptides observed in build (<a target=_termdefs href="http://www.peptideatlas.org/docs/protein_ident_terms.php">more info</a>)' },
                 { key => 'PSM FDR threshold', value => 'PSM (peptide-spectrum match) level FDR threshold applied to each experiment in this build' },
        );
                 
    $showtext = 'show row descriptions';
    $hidetext = 'hide row descriptions';
    $heading = 'Build Overview';
    $description= 'These values pertain to the atlas build as a whole';


  } elsif ( $name eq 'batch' ) {
    @entries = ( { key => 'ID', value => 'Database ID for this sample (search batch) ' },
                 { key => 'Sample_Name', value => 'Simple name for this sample/experiment. ' },
                 { key => '#_Spectra_Searched', value => 'The total number of spectra searched in the sample. ' },
                 { key => "#_Spectra_ID'd", value => 'The number of spectra identifed with a probability greater than the atlas threshold ' },
                 { key => '#_Distinct', value => 'The number of distinct peptide sequences, seen more than once (multiobs), in this build that are seen in this sample. ' },
                 { key => '#_Unique', value => "The number of distinct, multiobs peptides that are seen only in this sample (unique contribution).  This discriminates against smaller samples, and is less useful in atlas' with a large number of samples. " },
                 { key => '#_Progressive', value => 'Order-dependent unique multiobs peptides contributed by a given sample.  The contribution for each sample is based on the samples that have gone before it, so later samples tend to have a lower progressive contribution. ' },
                 { key => '#_Cumulative', value => 'Order-dependent cumulative number of unique multiobs peptides contributed to build by this and previous samples. ' },
                 { key => '#_Proteins', value => 'The number of canonical (highly distinguishable, non-redundant) protein sequences identified from the peptides in this sample.' },
                 { key => '#_Cum_Prots', value => 'Order-dependent cumulative number of canonical proteins contributed to build by this and previous samples.<br>Counts non-human contaminants, so final tally may be greater than Canonical Proteins count in Build Overview. ' },
#                 { key => 'Sens', value => 'The sensitivity of the Peptide Prophet model at a probablility of 0.9, the percent of true positives that would be included at that threshold was used as a cutoff. ' },
                 { key => 'FDR_(%)', value => 'The error rate of peptides above the threshold Peptide Prophet model at a probablility of 0.9, the percent of false positives that would be included at the build threshold. ' },
                 { key => 'Sample_Date', value => ''},
        );
    $heading = 'Sample Overview'; 
    $description = 'These values pertain to individual samples within the atlas';

  } elsif ( $name eq 'mayu' ) {
   @entries = ( { key => 'nr_runs', value => 'Number of MS runs contributing to this build '},
  
		{ key => 'nr_files', value => 'Always 1 '},
  
		{ key => 'mFDR', value => 'Data in current row applies to all data meting this PSM (spectrum) FDR threshold. '},
		{ key => 'target_PSM', value => 'Number of non-decoy PSMs at this mFDR (counts peptides mappable to protein reference set only)'},
  
		{ key => 'decoy_PSM', value => 'Number of decoy PSMs at this mFDR '},
  
		{ key => 'FP_PSM', value => 'Number of false positive PSMs predicted by Mayu for this mFDR. Usually near, but not exactly the same as, the number of decoys. '},
  
		{ key => 'TP_PSM', value => 'target_PSM - FP_PSM '},
  
		{ key => 'target_pepID', value => 'Number of non-decoy unique peptides at this mFDR (counts peptides mappable to protein reference set only) '},
  
		{ key => 'decoy_pepID', value => 'Number of decoy unique peptides at this mFDR '},
  
		{ key => 'FP_pepID', value => 'Number of false positive unique peptides predicted by Mayu for this mFDR. Usually near, but not exactly the same as, the number of decoys. '},
  
		{ key => 'FP_pepID_stdev', value => ' '},
  
		{ key => 'TP_pepID', value => 'target_pepID - FP_pepID '},
  
		{ key => 'pepFDR', value => 'Peptide FDR (unique peptides)'},
  
		{ key => 'target_protID', value => 'Number of non-decoy protein identifications at this mFDR. Applied to the covering set of proteins -- a set that is close to the smallest necessary to explain all the pepIDs. Includes all canonicals and some possibly_distinguished. '},
  
		{ key => 'decoy_protID', value => 'Number of decoy protein identifications at this mFDR. '},
  
		{ key => 'FP_protID', value => 'Number of false postiive protein identifications predicted by Mayu for this mFDR.  Usually near, but not exactly the same as, the number of decoys. '},
  
		{ key => 'FP_protID_stdev', value => ' '},
  
		{ key => 'TP_protID', value => 'target_protID - FP_protID '},
  
		{ key => 'protFDR', value => 'Protein FDR. The largest value in this column is the protein FDR for the entire build. '},
		{ key => 'lFDR1, lFDR5, lFDR10,2 lFDR5', value => 'Local protein FDR, computed over the previous step (i.e. between the previous row in the table and the current row), the previous 5 steps, the previous 10 steps, and the previous 25 steps.<br>Often there are fewer than 25 rows in the table, in which case column lFDR25 is uninformative. '},
  
		{ key => 'target_protIDs, decoy_protIDs, etc.', value => 'Same as above, except for singleton proteins (those identified by only one PSM) only. '},
		{ key => 'target_protIDns, decoy_protIDns, etc.', value => 'Same as above, except for multiply-observed proteins only. '},
  
        );
    $heading = 'Mayu'; 
    $description = 'Reiter L, Claassen M, et al., Protein identification false discovery rates for very large proteomics data sets generated by tandem mass spectrometry, Mol Cell Proteomics. 2009 Nov;8(11):2405-17 ';
  }


  return unless @entries;
  return \@entries if $args{mode} eq 'entries_only';

  my $help = $atlas->get_table_help_section( name => $name,
                                             description => $description,
                                             heading => $heading,
                                             entries => \@entries,
                                             showtext => $showtext,
                                             hidetext => $hidetext  );
  return $help;

} # end get_table_help

sub get_mayu_info {
  my $mayu_data_path = shift;
  my $table = "<TABLE WIDTH=600>\n";

  my ( $tr, $link ) = $sbeams->make_table_toggle( name    => 'mayu_info',
                                                  visible => 1,
                                                  tooltip => 'Show/Hide Section',
                                                  imglink => 1,
                                                  sticky  => 1 );

  $table .= $atlas->encodeSectionHeader(
      text => 'Mayu Decoy-Based FDR Analysis',
      link => $link,
      width => 920,
  );
  open (MAYU, $mayu_data_path);
  my $line = <MAYU>;
  my @headings = split(",",$line);
  my @sortable;
  for my $col ( @headings ) {
    push @sortable, $col, $col;
  }

  my $headings_ref = $atlas->make_sort_headings( headings => \@sortable, default => 'mFDR' );
  my @records = ();
  for $line (<MAYU>) {
    chomp ($line);
    my @fields = split(",",$line);
    push @records, \@fields;
  }
  $table .= $atlas->encodeSectionTable( rows => [ $headings_ref, @records ], 
					header => 1, 
					align => [ qw(center center left
right center center right right center center left center left center center
center left center left center center center center left center center center
center left) ], 
					tr_info => $tr,
					bg_color => '#EAEAEA',
          table_id => 'mayu_data',
					sortable => 1 );
  $table .= "\n</TABLE>\n";
  return ($table);
}

# less informative sample contribution plot
sub get_build_plots {
  my $build_id = shift;
  my $chart_div = shift;
  my $table = "<TABLE WIDTH=900>\n";

  my ( $tr, $link ) = $sbeams->make_table_toggle( name    => 'build_plot',
                                                  visible => 1,
                                                  tooltip => 'Show/Hide Section',
                                                  imglink => 1,
                                                  sticky  => 1 );

  $table .= $atlas->encodeSectionHeader(
      text => 'Sample Contribution Plot',
      span => 4,
      link => $link
  );

  # Eric Deutsch's idl-created GIF experiment contribution plots
  my $cp_img_path = "$PHYSICAL_BASE_DIR/images/tmp";
  my $img_path = "$HTML_BASE_DIR/images/tmp";
  my $build_path = get_build_path( build_id => $build_id );
  my ( $gif_filename, $multobs_string, $caption );

  # See whether we have a plot describing all peptides
  # or a plot describing only multiply observed peptides (pre-Sep09).
  if ( -e "$build_path/analysis/ncumpep_vs_nspec.gif" ) {
    $gif_filename = "ncumpep_vs_nspec.gif";
    $multobs_string = "";
  } elsif ( -e "$build_path/analysis/ncumpep_vs_nspec-multobs.gif" ) {
    $gif_filename = "ncumpep_vs_nspec-multobs.gif";
    $multobs_string = "multiply observed ";
  }
  $caption = "<b>Plot below shows cumulative number of distinct ${multobs_string}identified peptides contributed by each experiment.</b> Height of blue bar is number of peptides identified in experiment; height of red bar is cumulative number of peptides, width of the bar (x-axis) shows the number of spectra identified (PSMs) above the threshold, for each experiment.";
  if ( defined $gif_filename ) {
    $table = insert_image_and_caption_into_html_table (
      tr_info => $tr,
      caption => $caption,
      img_path => $img_path,
      cp_img_path => $cp_img_path,
      build_id => $build_id,
      build_path => $build_path,
      gif_filename => $gif_filename,
      table => $table,
    );
  }

  # See whether we have a plot describing all proteins
  if ( -e "$build_path/analysis/ncumprot_vs_nspec.gif" ) {
    $gif_filename = "ncumprot_vs_nspec.gif";
    $caption = "<b>Plot below shows cumulative number of canonical proteins contributed by each experiment.</b> Height of blue bar is number of proteins identified in experiment; height of red bar is cumulative number of proteins, width of the bar (x-axis) shows the number of spectra identified (PSMs) above the threshold, for each experiment.";
    $table = insert_image_and_caption_into_html_table (
      tr_info => $tr,
      caption => $caption,
      img_path => $img_path,
      cp_img_path => $cp_img_path,
      build_id => $build_id,
      build_path => $build_path,
      gif_filename => $gif_filename,
      table => $table,
    );
  }

  sub insert_image_and_caption_into_html_table {
    my %args = @_;
    my $tr_info = $args{tr_info};
    my $caption = $args{caption};
    my $img_path = $args{img_path};
    my $cp_img_path = $args{cp_img_path};
    my $build_id = $args{build_id};
    my $build_path = $args{build_path};
    my $gif_filename = $args{gif_filename};
    my $table = $args{table};

    # Craft a table row for the caption, and one for the image.
    my $build_image_rows =<<"    END";
    <TR $tr><TD>&nbsp;</TD></TR>
    <TR $tr><TD class=plot_caption>$caption</TD></TR>
    <TR $tr><TD><IMG WIDTH=800 SRC=$img_path/${build_id}_$gif_filename></IMG></TD></TR> 
    END
    # Try copying image to $cp_img_path. If successful, add rows to table
    system "cp  $build_path/analysis/$gif_filename $cp_img_path/${build_id}_$gif_filename";
    if ( -e "$cp_img_path/${build_id}_$gif_filename" ) {
      $table .= $build_image_rows;
    } 
    return $table;
  }

  return $table if ( -e "$cp_img_path/${build_id}_$gif_filename" );

#  dynamically drawn experiment contribution plot
#		<DIV ALIGN=center><H3>Experiment Contribution Plot</H3></DIV>
#  <TR $tr><TD><IMG SRC=buildPlot?atlas_build_id=$build_id></IMG></TD></TR>
#    $chart_div
  $table .=<<"  END";
  <TR $tr><TD>&nbsp;</TD></TR>
  <TR $tr><TD class=plot_caption><b>Plot below shows the number of distinct <i>multiply observed</i> (n_obs > 1) peptides contributed by each sample,</b> and the cumulative number of distinct multiply-observed peptides for the build as of that sample.</TD></TR>
  <TR $tr><TD>&nbsp;</TD></TR>
  <TR $tr><TD>$chart_div</TD></TR>
  <TR $tr><TD>&nbsp;</TD></TR>
  END
   

  $table .= "\n</TABLE>\n";
	
  return $table;
}

###############################################################################
# displaySampleMap
###############################################################################
sub getSampleMapDisplay {
#  my $self = shift;
#  my $sbeams = $self->getSBEAMS();
  my %args = @_;
  
	return unless $args{build_id};
  my ( $tr, $link ) = $sbeams->make_table_toggle( name    => 'BD_sample_map',
                                                  visible => 1,
                                                  tooltip => 'Show/Hide Section',
                                                  imglink => 1,
                                                  sticky  => 1 );

  my $header .= $atlas->encodeSectionHeader( text => 'Sample Protein Map:',
                                             'link' => $link );
  
  my $html = '';
  
	my $top = ( $args{show_all_prots} ) ? 20000 : 200;
  my $prot_sql = qq~
	SELECT TOP $top matched_biosequence_id, CAST(biosequence_seq AS VARCHAR(2000)) seq, biosequence_name
  FROM  $TBAT_PEPTIDE_INSTANCE PI 
  JOIN $TBAT_PEPTIDE_MAPPING PM ON PM.peptide_instance_id = PI.peptide_instance_id
  JOIN $TBAT_BIOSEQUENCE B ON PM.matched_biosequence_id = B.biosequence_id
	WHERE PI.atlas_build_id = $args{build_id}
	GROUP BY matched_biosequence_id,  CAST(biosequence_seq AS VARCHAR(2000)), biosequence_name
	ORDER BY SUM(PI.n_observations) DESC 
	~;
	my $t1 = time;
  my @prots = $sbeams->selectSeveralColumns($prot_sql);
	my $t2 = time;
	my $td = $t2 - $t1;
  $log->debug( "Top 200 proteins SQL: $td" );
	my @ordered_prots;
	my %seen_sequences;
  my @bioseq_ids;
	my $cntr;
	for my $row ( @prots ) {
		# no dups
		next if $seen_sequences{$row->[1]};
		$seen_sequences{$row->[1]}++;
		$cntr++;
		push @ordered_prots, $row->[2];
		push @bioseq_ids, $row->[0];
		last if scalar( @ordered_prots ) >= 25 && !$args{show_all_prots};
		$cntr++;
	}
  my $bioseq_ids = join( ',', @bioseq_ids );
  return '' unless $bioseq_ids;
  
  my $sql = qq~
	SELECT biosequence_name, SUM(PISB.n_observations) total_cnts,
	SB.atlas_search_batch_id, sample_tag -- , peptide_accession
  FROM $TBAT_ATLAS_SEARCH_BATCH SB
  JOIN $TBAT_SAMPLE S ON s.sample_id = SB.sample_id
  JOIN $TBAT_PEPTIDE_INSTANCE_SEARCH_BATCH PISB ON PISB.atlas_search_batch_id = SB.atlas_search_batch_id
  JOIN $TBAT_PEPTIDE_INSTANCE PI ON PI.peptide_instance_id = PISB.peptide_instance_id
--  JOIN $TBAT_PEPTIDE P ON P.peptide_id = PI.peptide_id
  JOIN $TBAT_PEPTIDE_MAPPING PM ON PM.peptide_instance_id = PI.peptide_instance_id
  JOIN $TBAT_BIOSEQUENCE B ON B.biosequence_id = PM.matched_biosequence_id
  JOIN $TBAT_ATLAS_BUILD AB ON ( AB.biosequence_set_id = B.biosequence_set_id AND AB.atlas_build_id = PI.atlas_build_id ) 
  WHERE AB.atlas_Build_id = $args{build_id}
	AND biosequence_id IN ( $bioseq_ids )
	GROUP BY biosequence_name, SB.atlas_search_batch_id, sample_tag
--	ORDER BY biosequence_name, SB.atlas_search_batch_id, sample_tag
  ~;
  
	my $t1 = time;
  my @samples = $sbeams->selectSeveralColumns($sql);
	my $t2 = time;
	my $td = $t2 - $t1;
  $log->debug( "Sum observations SQL: $td" );
  
  my %samples;
  my %proteins;
  for my $row ( @samples ) {
    my $key = $row->[3] . '::::' . $row->[2];
		$samples{$key}++;
    $proteins{$row->[0]} ||= {};
    $proteins{$row->[0]}->{$key} += $row->[1];
  }

	my @prot_order;

  my $array_def = qq~
  <script type="text/javascript">
  google.setOnLoadCallback(drawHeatMap);
  function drawHeatMap() {
  var data = new google.visualization.DataTable();
  data.addColumn('string', 'Sample Name');
  ~;

  my $ie_max = 50;
  my $ie = ( $ENV{HTTP_USER_AGENT} =~ /MSIE/i ) ? 1 : 0;

  my @peps;
  my $cnt = 0;
	my @sample_names = ( 'Protein_Accession' );
  for my $sa ( sort( keys( %samples ) ) ) {
    my ( $name, $id ) = split "::::", $sa;
		push @sample_names, $name;
    $array_def .= "    data.addColumn('number', '$name');\n";
    last if $ie && $cnt++ >= $ie_max;
  }
  $array_def .= "DEFINE_ROWS_HERE\n";
  
  my $content = join( "\t", @sample_names ) . "\n";
  my $row = 0;
  my $col = 0;
  my $max = 0;
	my %output;
	if ( $args{show_all_prots} ) {
    for my $protein ( @ordered_prots ) {
     $col = 0;
     $array_def .= "    data.setValue( $row, $col, '$protein' );\n";
     $col++;
     my $colcnt = 0;
		 my @row = ($protein);
     for my $sample ( sort( keys( %samples ) ) ) {
        my ( $name, $id ) = split "::::", $sample;
#        last if $ie && $colcnt++ > $ie_max;
				my $cnt = 0;
  		  if ( $proteins{$protein}->{$sample} ) {
  #        my $cnt = $proteins{$protein}->{$sample};
          $cnt = log( 1+ $proteins{$protein}->{$sample} )/log(10);
          $max = ( $cnt > $max ) ? $cnt : $max;
#          $array_def .= "    data.setValue( $row, $col, $cnt );\n";
  			}
				push @row, $cnt;
        $col++;
      }
			$content .= join( "\t", @row ) . "\n";
      $row++;
    }
		my $filename = $sbeams->writeSBEAMSTempFile( content => $content );
    $log->error( "TSVFILE is $filename!" );
	} else {
    for my $protein ( @ordered_prots ) {
      $col = 0;
      $array_def .= "    data.setValue( $row, $col, '$protein' );\n";
      $col++;
     my $colcnt = 0;
     for my $sample ( sort( keys( %samples ) ) ) {
        my ( $name, $id ) = split "::::", $sample;
        last if $ie && $colcnt++ > $ie_max;
  		  if ( $proteins{$protein}->{$sample} ) {
  #        my $cnt = $proteins{$protein}->{$sample};
          my $cnt = log( 1+ $proteins{$protein}->{$sample} )/log(10);
          $max = ( $cnt > $max ) ? $cnt : $max;
          $array_def .= "    data.setValue( $row, $col, $cnt );\n";
  			}
        $col++;
      }
      $row++;
    }
	}
  $array_def =~ s/DEFINE_ROWS_HERE/data.addRows($row);/;
  my $num_colors = ( $max > 64 ) ? 64 : $max;
  my $num_colors = 256;
  $array_def .= qq~
  heatmap = new org.systemsbiology.visualization.BioHeatMap(document.getElementById('heatmapContainer'));
  heatmap.draw(data, {numberOfColors:$num_colors,passThroughBlack:false,startColor:{r:255,g:255,b:255,a:1},endColor:{r:100,g:100,b:100,a:1},emptyDataColor:{r:256,g:256,b:256,a:1}});
  }
  </script>
  ~;
  
  my $content = qq~
	<BR><BR>
  <TABLE WIDTH=800>
	$header


  <script type="text/javascript" src="$HTML_BASE_DIR/usr/javascript/jsapi"></script>
  <script type="text/javascript" src="$HTML_BASE_DIR/usr/javascript/ga.js"></script>
  <script type="text/javascript">
  google.load("visualization", "1", {});
  google.load("prototype", "1.6");
  </script>
  <script type="text/javascript" src="$HTML_BASE_DIR/usr/javascript/main/js/load.js"></script>
  <script type="text/javascript">
  systemsbiology.load("visualization", "1.0", {packages:["bioheatmap"]});
  </script>
  
  $array_def
  
  <TR $tr><TD> <DIV ID="heatmapContainer"></DIV>  </TD></TR>
  
  </TABLE>
  ~;
  
  return $content;
  
} # end getSampleMapDisplay
  
  


# General build info, date, name, organism, specialty, default
sub get_build_overview {

  my $build_id = shift;
  
  # Get a list of accessible project_ids
  my @project_ids = $sbeams->getAccessibleProjects();
  my $project_ids = join( ",", @project_ids ) || '0';

  my $build_info = $sbeams->selectrow_hashref( <<"  BUILD" );
  SELECT atlas_build_name, probability_threshold, atlas_build_description, 
  build_date, set_name, protpro_PSM_FDR_per_expt
  FROM $TBAT_ATLAS_BUILD AB JOIN $TBAT_BIOSEQUENCE_SET BS 
  ON AB.biosequence_set_id = BS.biosequence_set_id
  WHERE atlas_build_id = $build_id 
  AND AB.record_status <> 'D'
  BUILD

#  for my $k ( keys( %$build_info ) ) { print STDERR "$k => $build_info->{$k}\n"; }

  my $pep_count = $sbeams->selectrow_hashref( <<"  PEP" );
  SELECT COUNT(*) cnt,  SUM(n_observations) obs
  FROM $TBAT_PEPTIDE_INSTANCE 
  WHERE atlas_build_id = $build_id 
  PEP

  my $multi_pep_count = $sbeams->selectrow_hashref( <<"  MPEP" );
  SELECT COUNT(*) cnt, SUM(n_observations) obs
  FROM $TBAT_PEPTIDE_INSTANCE  
  WHERE atlas_build_id = $build_id 
  AND n_observations > 1 
  MPEP

  my $smpl_count = $sbeams->selectrow_hashref( <<"  SMPL" );
  SELECT COUNT(*) cnt FROM $TBAT_ATLAS_BUILD_SAMPLE 
  WHERE atlas_build_id = $build_id
  SMPL

  my $prot_count = $sbeams->selectrow_hashref( <<"  PROT" );
  SELECT COUNT(BS.biosequence_name) cnt
  FROM $TBAT_PROTEIN_IDENTIFICATION PID
  JOIN $TBAT_PROTEIN_PRESENCE_LEVEL PPL
  ON PPL.protein_presence_level_id = PID.presence_level_id
  JOIN $TBAT_BIOSEQUENCE BS
  ON BS.biosequence_id = PID.biosequence_id
  WHERE PID.atlas_build_id = $build_id
  AND PPL.level_name = 'canonical'
  AND BS.biosequence_name NOT LIKE 'DECOY%'
  AND BS.biosequence_name NOT LIKE '%UNMAPPED%'
  AND BS.biosequence_desc NOT LIKE '%common contaminant%'
  PROT


  my $table = "<TABLE WIDTH=800>\n";

  my ( $tr, $link ) = $sbeams->make_table_toggle( name    => 'build_overview',
                                                  visible => 1,
                                                  tooltip => 'Show/Hide Section',
                                                  imglink => 1,
                                                  sticky  => 1 );

  $table .= $atlas->encodeSectionHeader(
      text => 'Build Overview',
      span => 4,
      link => $link
  );

  my $spc = $sbeams->getGifSpacer(500);
  $build_info->{build_date} =~ s/^([0-9-]+).*$/$1/;
#  $/mpl_count->{cnt} = sprintf( "% 10i", $smpl_count->{cnt} );
#  $smpl_count->{cnt} =~ s/ /&nbsp;/g;
#  $multi_pep_count->{cnt} = sprintf( "% 10i", $multi_pep_count->{cnt} );
#  $multi_pep_count->{cnt} =~ s/ /&nbsp;/g;
#  $multi_pep_count->{obs} = sprintf( "% 10i", $multi_pep_count->{obs} );
# $multi_pep_count->{obs} =~ s/ /&nbsp;/g;
  
  
#  my $deltacnt = $multi_pep_count->{cnt} - $pep_count->{cnt};
#  my $deltaobs = $multi_pep_count->{obs} - $pep_count->{obs};
#  $table .= $atlas->encodeSectionItem( key   => 'Deltas ', tr_info => $tr,
#                                          value => "$deltacnt ( $deltaobs )" ) . "\n";

  if ($build_info->{protpro_PSM_FDR_per_expt} <= 0) {
    $build_info->{protpro_PSM_FDR_per_expt} =  $sbeams->makeInactiveText( 'n/a' );
  } else {
    $build_info->{protpro_PSM_FDR_per_expt} = sprintf( "%0.7f", $build_info->{protpro_PSM_FDR_per_expt} );
    $build_info->{protpro_PSM_FDR_per_expt} =~ s/ /&nbsp;/g;
  }
  if ($build_info->{probability_threshold} <= 0) {
    $build_info->{probability_threshold} = $sbeams->makeInactiveText( 'n/a' );
  } else {
    $build_info->{probability_threshold} = sprintf( "%0.4f", $build_info->{probability_threshold} );
    $build_info->{probability_threshold} =~ s/ /&nbsp;/g;
  }

  $table .= $atlas->encodeSectionItem( key   => 'Build Name', tr_info => $tr,
                            value => $build_info->{atlas_build_name} . $spc, vspan => 3 ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Build Description', tr_info => $tr,
                            value => $build_info->{atlas_build_description}, vspan => 3 ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Reference Database', tr_info => $tr,
                            value => $build_info->{set_name}, vspan => 3 ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Build Date', tr_info => $tr,
                            value => $build_info->{build_date} ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => '# Samples', tr_info => $tr,
                            value => $smpl_count->{cnt}, align => 'right' ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'PSM FDR threshold', tr_info => $tr,
                            value => $build_info->{protpro_PSM_FDR_per_expt}, align => 'right' ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Probability threshold', tr_info => $tr,
                            value => $build_info->{probability_threshold}, align => 'right' ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Canonical Proteins', tr_info => $tr, value => $prot_count->{cnt}, align => 'right' ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Distinct Peptides', tr_info => $tr,
                                          #value => "$multi_pep_count->{cnt} ( $pep_count->{cnt}* )" ) . "\n";
                                          value => "$pep_count->{cnt}", align => 'right' ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Total Observations', tr_info => $tr,
                                          #value => "$multi_pep_count->{obs} ( $pep_count->{obs}* )" ) . "\n";
                                          value => "$pep_count->{obs}", align => 'right' ) . "\n";
#  $table .= $atlas->encodeSectionDblItem( key   => ['Build Date', '# Samples'], tr_info => $tr,
#                            value => [$build_info->{build_date}, $smpl_count->{cnt}] ) . "\n";
#  $table .= $atlas->encodeSectionDblItem( key   => ['Total Observations', 'Distinct Peptides'], 
#                                          tr_info => $tr,
#                                          value => [$pep_count->{obs}, $pep_count->{cnt}] ) . "\n";
#  $table .= $atlas->encodeSectionDblItem( key   => ['Total Observations n_obs > 1', 'Distinct Peptides n_obs > 1'], 
#                                          tr_info => $tr,
#                                          value => [$multi_pep_count->{obs}, $multi_pep_count->{cnt}] ) . "\n";

  $table .= "</TABLE>\n";
  return $table;

}

# Peptide build stats
sub get_sample_info {

  my $build_id = shift;

  # Get a list of accessible project_ids
  my @project_ids = $sbeams->getAccessibleProjects();
  my $project_ids = join( ",", @project_ids ) || '0';


  my $table = "<TABLE WIDTH=600>\n";

  my ( $tr, $link ) = $sbeams->make_table_toggle( name    => 'sample_contribution',
                                                  visible => 1,
                                                  tooltip => 'Show/Hide Section',
                                                  imglink => 1,
                                                  sticky  => 1 );

  my $sql =<<"  END";
  SELECT ASB.atlas_search_batch_id, sample_tag, SBS.n_searched_spectra,
         n_good_spectra, n_distinct_multiobs_peptides,
         n_uniq_contributed_peptides, n_progressive_peptides,
         cumulative_n_peptides, n_canonical_proteins, cumulative_n_proteins,
         model_90_error_rate,CONVERT(VARCHAR(10), PE.date_created, 126) AS [YYYY-MM-DD]
  FROM $TBAT_SEARCH_BATCH_STATISTICS SBS 
  JOIN $TBAT_ATLAS_BUILD_SEARCH_BATCH ABSB ON ABSB.atlas_build_search_batch_id = SBS.atlas_build_search_batch_id
  JOIN $TBAT_ATLAS_SEARCH_BATCH ASB ON ( ASB.atlas_search_batch_id = ABSB.atlas_search_batch_id )
  JOIN $TBAT_SAMPLE S ON (S.sample_id = ASB.sample_id)
  JOIN PROTEOMICS.DBO.SEARCH_BATCH PSB
  ON PSB.SEARCH_BATCH_ID = ASB.PROTEOMICS_SEARCH_BATCH_ID
  JOIN PROTEOMICS.DBO.PROTEOMICS_EXPERIMENT PE
  ON PE.EXPERIMENT_ID = PSB.EXPERIMENT_ID
  WHERE ABSB.atlas_build_id = $build_id
  ORDER BY rownum, cumulative_n_peptides, ABSB.atlas_build_search_batch_id ASC
  END
	my $t1 = time;
  my @sample_info = $sbeams->selectSeveralColumns ( $sql );
	my $t2 = time;
	my $td = $t2 - $t1;
  $log->debug( "build table SQL: $td" );

  # Massage/format some of the columns in the sample info just retrieved
  my @samples;
  for my $batch ( @sample_info ) {
    $show_image++;
    # if these aren't defined, set to zero
    for my $idx ( 5, 6, 7, 8, 9 ) { $batch->[$idx] ||= 0; }
    # if FDR not defined, set to ND. Else, make into string.
    for my $idx ( 10 ) {
      $batch->[$idx] = $sbeams->makeInactiveText('ND') if !defined $batch->[$idx];
      $batch->[$idx] = sprintf( "%0.1f", (100 * $batch->[$idx]))  if $batch->[$idx] !~ /FONT/;  # only one digit after decimal
    }
    push @samples, $batch;

  }

  my $dag = '<sup>&dagger;</sup>';
  
  my $heading_info = get_table_help( table => 'batch', mode => 'entries_only' );
  my @headings;
  for my $row ( @$heading_info ) {
    push @headings, $row->{key}, $row->{value};
  }

#  for my $h ( @headings ) {
#    $log->info( $h );
#  }

  my $headings_ref = $atlas->make_sort_headings( headings => \@headings, default => '#_Cumulative' );

  $table .= $atlas->encodeSectionHeader(
      text => 'Sample Contribution',
      link => $link,
      width => 920
  );


  $table .= $atlas->encodeSectionTable( rows => [ $headings_ref, @samples ], 
                                        header => 1, 
                                        nowrap => [1..scalar(@headings)], 
                                        table_id => 'sample_contribution',
                                        align => [ qw(center left right right right right right right right right right center) ], 
                                        tr_info => $tr,
                                        bg_color => '#EAEAEA',
                                        rows_to_show => 25,
                                        sortable => 1 );
  $table .= '</TABLE>';
  return ( $table, \@samples );

}


sub process_params {
  my $params = {};
  $sbeams->parse_input_parameters( q => $q, parameters_ref => $params );
  $sbeams->processStandardParameters( parameters_ref => $params );
  return( $params );
}

sub get_build_path {
  my %args = @_;
  return unless $args{build_id};
  my $path = $atlas->getAtlasBuildDirectory( atlas_build_id => $args{build_id} );
  $path =~ s/DATA_FILES//;
  return $path;
}

sub get_draw_chart_function {
	my $sample_arrayref = shift || return '';

	my @samples;
	for my $s ( @{$sample_arrayref} ) {
		push @samples, [ $s->[1], $s->[4], $s->[7] ];
	}
	my $GV = SBEAMS::Connection::GoogleVisualization->new();
  my ( $chart ) = $GV->setDrawBarChart(  samples => \@samples,
                                    	data_types => [ 'string', 'number', 'number' ],
                                      	headings => [ 'Sample', 'Distinct peptides (n_obs > 1)', 'Cumulative peptides (n_obs > 1)' ],
                                      show_table => 0,
                                 truncate_labels => 24
 	);
	my $header = $GV->getHeaderInfo();
  return ( $chart, $header );
}

