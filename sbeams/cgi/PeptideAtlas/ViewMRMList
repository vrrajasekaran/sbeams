#!/usr/local/bin/perl

###############################################################################
# Program     : ViewMRMList
#
# Description : retrieves a list of peptides and MS/MS fragment ions given
#               and displays the spectra for each...
###############################################################################


###############################################################################
# Set up all needed modules and objects
###############################################################################
use strict;
use Getopt::Long;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($sbeams $sbeamsMOD $q $current_contact_id $current_username
$PROG_NAME $USAGE %OPTIONS $QUIET $VERBOSE $DEBUG $DATABASE
$TABLE_NAME $PROGRAM_FILE_NAME $CATEGORY $DB_TABLE_NAME
@MENU_OPTIONS $modification_helper);

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::TabMenu;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;
use SBEAMS::PeptideAtlas::ModificationHelper;

$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);

use PGPLOT;
use PDL;
use PDL::Graphics::PGPLOT;

$PROG_NAME="ViewMRMList";

###############################################################################
# Set program name and usage banner for command like use
###############################################################################
$PROG_NAME = $FindBin::Script;
$USAGE = <<EOU;
Usage: $PROG_NAME [OPTIONS] key=value key=value ...
Options:
    --verbose n    Set verbosity level.    default is 0
    --quiet        Set flag to print nothing at all except errors
    --debug n      Set debug flag

 e.g.:  $PROG_NAME [OPTIONS] [keyword=value],...

EOU

#### Process options
unless (GetOptions(\%OPTIONS,"verbose:s","quiet","debug:s")) 
{
    print "$USAGE";
    exit;
}

$VERBOSE = $OPTIONS{"verbose"} || 0;
$QUIET = $OPTIONS{"quiet"} || 0;
$DEBUG = $OPTIONS{"debug"} || 0;
if ($DEBUG) 
{
    print "Options settings:\n";
    print "    VERBOSE = $VERBOSE\n";
    print "    QUIET = $QUIET\n";
    print "    DEBUG = $DEBUG\n";
}


main();
exit(0);


###############################################################################
# Main Program:
#
# Call $sbeams->Authenticate() and exit if it fails or continue if it works.
###############################################################################
sub main 
{
    #### Do the SBEAMS authentication and exit if a username is not returned
    exit unless ($current_username = $sbeams->Authenticate(
        allow_anonymous_access=>1,
    ));

    #### Read in the default input parameters
    my %parameters;

    $parameters{uploaded_file_not_saved} = 1;

    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);

    $sbeams->processStandardParameters(parameters_ref=>\%parameters);
    
    # Hackage
    $parameters{NIST_library_id} ||= $parameters{consensus_library_id};

    #$sbeams->printDebuggingInfo($q);

    #### Decide what action to take based on information so far
    if ($parameters{action} eq "???") 
    {
        # Some action
    } else 
    {
        my $project_id = $sbeamsMOD->getProjectID(
            atlas_build_id => $parameters{atlas_build_id}
        );

        $sbeamsMOD->display_page_header(project_id => $project_id);

        handle_request(ref_parameters=>\%parameters);

        $sbeamsMOD->display_page_footer();
    }

    #### Finish the upper part of the page and go begin the full-width
    #### data portion of the page
    $sbeams->display_page_footer(close_tables=>'YES',
        separator_bar=>'YES',display_footer=>'NO');

} # end main


###############################################################################
# Handle Request
###############################################################################
sub handle_request 
{
    my %args = @_;

    #### Process the arguments list
    my $ref_parameters = $args{'ref_parameters'} || die "ref_parameters not passed";

    my %parameters = %{$ref_parameters};

    #### Show current user context information
    print "<BR>\n" if ($sbeams->output_mode() eq 'html');
    

    #$sbeams->printUserContext();

    #### Get the HTML to display the tabs
    my $tabMenu = $sbeamsMOD->getTabMenu(
        parameters_ref => \%parameters,
        program_name => $PROG_NAME,
    );

    print $tabMenu->asHTML() if ($sbeams->output_mode() eq 'html');

    #### Define some generic variables
    my ($i,$element,$key,$value,$line,$result,$sql);


    #### Define some variables for a query and resultset
    my %resultset = ();
    my $resultset_ref = \%resultset;
    my (%url_cols,%hidden_cols,%max_widths,$show_sql);

    #### Read in the standard form values
    my $apply_action    = $parameters{'action'} || $parameters{'apply_action'};
    my $TABLE_NAME = $parameters{'QUERY_NAME'};

    #### If the apply action was to recall a previous resultset, do it
    my %rs_params = $sbeams->parseResultSetParams(q=>$q);


    #########################################################################
    #### Process all the constraints

    #### If no NIST library was selected, stop here
    unless ( $parameters{NIST_library_id} ) 
    {
        $sbeams->reportException(
            state => 'ERROR',
            type => 'INSUFFICIENT CONSTRAINTS',
            message => 'You must select at least one NIST library',
        );
        return;
    }

    #### Build atlas_build_id constraint
    my $atlas_build_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.atlas_build_id",
        constraint_type=>"int_list",
        constraint_name=>"Atlas Build",
        constraint_value=>$parameters{atlas_build_id} );
    return if ($atlas_build_clause eq '-1');

    #### Build NIST_library_id constraint
    my $NIST_library_where_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"NL.NIST_library_id",
        constraint_type=>"int_list",
        constraint_name=>"NIST Library",
        constraint_value=>$parameters{NIST_library_id} );
    return if ($NIST_library_where_clause eq '-1');
    ##  replace AND with WHERE
    $NIST_library_where_clause =~ s/(.*)AND(.*)/$1WHERE$2/;

    #### Build PEPTIDE_SEQUENCE constraint
    my $peptide_sequence_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"P.peptide_sequence",
        constraint_type=>"plain_text",
        constraint_name=>"Peptide Sequence",
        constraint_value=>$parameters{peptide_sequence_constraint} );
    return if ($peptide_sequence_clause eq '-1');

    #### Build BEST_PROBABILITY constraint
    my $best_probability_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.best_probability",
        constraint_type=>"flexible_float",
        constraint_name=>"Best Probability",
        constraint_value=>$parameters{best_probability_constraint} );
    return if ($best_probability_clause eq '-1');

    #### Build N_OBSERVATIONS constraint
    my $n_observations_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.n_observations",
        constraint_type=>"flexible_int",
        constraint_name=>"Number of Observations",
        constraint_value=>$parameters{n_observations_constraint} );
    return if ($n_observations_clause eq '-1');

    #### Build N_SAMPLES constraint
    my $n_samples_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.n_samples",
        constraint_type=>"flexible_int",
        constraint_name=>"Number of Samples",
        constraint_value=>$parameters{n_samples_constraint} );
    return if ($n_samples_clause eq '-1');


    #### Build EMPIRICAL_PROTEOTYPIC_SCORE constraint
    my $empirical_proteotypic_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.empirical_proteotypic_score",
        constraint_type=>"flexible_float",
        constraint_name=>"Empirical Proteotypic Score",
        constraint_value=>$parameters{empirical_proteotypic_constraint} );
    return if ($empirical_proteotypic_clause eq '-1');


    #### Build n_protein_mappings constraint
    my $n_protein_mappings_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.n_protein_mappings",
        constraint_type=>"flexible_int",
        constraint_name=>"n_protein_mappings",
        constraint_value=>$parameters{n_protein_mappings_constraint} );
    return if ($n_protein_mappings_clause eq '-1');

    #### Build n_genome_locations constraint
    my $n_genome_locations_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"PI.n_genome_locations",
        constraint_type=>"flexible_int",
        constraint_name=>"n_genome_locations",
        constraint_value=>$parameters{n_genome_locations_constraint} );
    return if ($n_genome_locations_clause eq '-1');

    #### Build peptide_length constraint
    my $peptide_length_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"P.peptide_length",
        constraint_type=>"flexible_int",
        constraint_name=>"peptide_length",
        constraint_value=>$parameters{peptide_length} );
    return if ($peptide_length_clause eq '-1');


    #### Build PROTEIN_NAME constraint
      my $biosequence_name_clause = $sbeams->parseConstraint2SQL(
          constraint_column=>"BS.biosequence_name",
          constraint_type=>"plain_text",
          constraint_name=>"Protein Name",
          constraint_value=>$parameters{protein_name_constraint} );
      return if ($biosequence_name_clause eq '-1');


    ## handle file upload and clause for sql for $parameters{upload_file}
    my ($biosequence_names_clause_nist, $biosequence_names_clause_pa,
    $biosequence_names_mapping_join, $biosequence_name_clause_pa);

    my $n_highest_intensity_fragment_ions;

    my %protein_hash;

    if ( $parameters{upload_file} )
    {
         ## upload the file to a file handler
         my $fh = $q->upload('upload_file');

         if (!$fh && $q->cgi_error)
         {
             print $q->header(-status=>$q->cgi_error);
         }
         if ( (-T $fh) && (-s $fh < 1000000)) ##size constraint of 10 MB, restrict $count < 30000
         {
             my $count = 0;
             my $read_file=0;
             ## protein list
             my $prt;
             while ($prt=<$fh>)
             {
                 chomp($prt);
                 $prt =~ s/\s+$//;
                 if ($prt)
                 {
                     $protein_hash{$prt} = $prt;
                     $count = $count + 1;
                 }
                 last if ($count > 30000);
            }
        }
        ## join with a commas:
        my $protein_list = "";

        foreach my $pr (keys %protein_hash)
        {
             $protein_list = "'$protein_hash{$pr}',$protein_list"; 
        }

        ## trim off last comma:
        $protein_list =~ s/(.*)(,)$/$1/;

        $biosequence_names_clause_pa = 
            "     AND BS.biosequence_name IN ( $protein_list )";

        $biosequence_names_clause_nist = 
            "     AND NLS.protein_name IN ( $protein_list )";

        $biosequence_names_mapping_join =
            "   LEFT JOIN $TBAT_PEPTIDE_MAPPING PM "
           ."   ON ( PI.peptide_instance_id = PM.peptide_instance_id ) "
           ."   LEFT JOIN $TBAT_BIOSEQUENCE BS "
           ."   ON (BS.biosequence_id = PM.matched_biosequence_id) "
           ."   LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS "
           ."   ON (BS.biosequence_set_id = BSS.biosequence_set_id)";
    } elsif ($biosequence_name_clause)
    {
        $biosequence_names_mapping_join =
            "   LEFT JOIN $TBAT_PEPTIDE_MAPPING PM "
           ."   ON ( PI.peptide_instance_id = PM.peptide_instance_id ) "
           ."   LEFT JOIN $TBAT_BIOSEQUENCE BS "
           ."   ON (BS.biosequence_id = PM.matched_biosequence_id) "
           ."   LEFT JOIN $TBAT_BIOSEQUENCE_SET BSS "
           ."   ON (BS.biosequence_set_id = BSS.biosequence_set_id)";
    }

    ## if n_highest_intensity_fragment_ions not set, use default of 10
    if ($parameters{'n_highest_intensity_fragment_ions'})
    {
        if ($parameters{'n_highest_intensity_fragment_ions'} =~ /^([\d]+)$/)
        {
            $n_highest_intensity_fragment_ions = $1;
        } else
        {
            $n_highest_intensity_fragment_ions = 10;
        }
    } else
    {
        $n_highest_intensity_fragment_ions = 10;
    }

    my @column_array;


    #########################################################################
    #### If QUERY or VIEWRESULTSET was selected, display the data
    if ($apply_action =~ /QUERY/i ) 
    {
        my $ed = "<td>&nbsp;</td>";

        print qq~
            Note: masses are mono-isotopic;  results are from query to
            PeptideAtlas followed by peptide sequence query to NIST consensus spectra.
            <br/><br/>
        ~;

        $modification_helper = new ModificationHelper();


        ## look up PA peptides and nab the NIST spectra with similar peptide sequences

        if ($atlas_build_clause ||
        $NIST_library_where_clause || $biosequence_name_clause_pa ||
        $peptide_sequence_clause || $best_probability_clause ||
        $n_observations_clause || $n_samples_clause ||
        $empirical_proteotypic_clause || $n_protein_mappings_clause ||
        $n_genome_locations_clause || $peptide_length_clause ||
        $biosequence_names_clause_pa )
        {
            unless ($parameters{atlas_build_id} && 
            ($parameters{atlas_build_id} =~ /^[\d]+$/))
            {
                $sbeams->reportException(
                    state => 'ERROR',
                    type => 'INSUFFICIENT CONSTRAINTS',
                    message => 'You must select at least one atlas_build',
                );
                return;
            }

            $sql = qq~
            SELECT distinct NLS.NIST_library_spectrum_id, NLS.sequence,
            NLS.modified_sequence,
            NLS.protein_name, NLS.mz_exact, NLS.charge, NLS.protein_name_alt,
            PI.best_probability, PI.n_observations, PI.n_samples,
            PI.n_protein_mappings, PI.n_genome_locations, SSRCalc_relative_hydrophobicity
            FROM $TBAT_NIST_LIBRARY_SPECTRUM NLS
            LEFT JOIN $TBAT_NIST_LIBRARY NL
            ON (NLS.NIST_library_id = NL.NIST_library_id)
            LEFT JOIN $TBAT_PEPTIDE P
            ON (P.peptide_sequence = NLS.sequence)
            LEFT JOIN $TBAT_PEPTIDE_INSTANCE PI
            ON (PI.peptide_id = P.peptide_id)
            JOIN $TBAT_NIST_SPECTRUM_TYPE NST
            ON (NST.NIST_spectrum_type_id = 
              NLS.NIST_spectrum_type_id)
            $biosequence_names_mapping_join
            $NIST_library_where_clause
            $atlas_build_clause
            $biosequence_name_clause_pa
            $peptide_sequence_clause
            $best_probability_clause
            $n_observations_clause
            $n_samples_clause
            $empirical_proteotypic_clause
            $n_protein_mappings_clause
            $n_genome_locations_clause
            $peptide_length_clause
            $biosequence_names_clause_pa
            $biosequence_name_clause
            AND NST.NIST_spectrum_type_name='Consensus'
            ORDER BY protein_name, NLS.sequence
            ~;

            $log->debug( "Going to exec SQL" );
            my @rows = $sbeams->selectSeveralColumns($sql);
            $log->debug( "SQL done, returned " . scalar(@rows) );

            my @display_rows = ( [qw( Protein Sequence Chg q1_mz q3_mz Intensity Ion SSRCalc n_obs Spectrum ) ] );
            my $idx = 0;
            foreach my $row (@rows)
            {
                $idx++;
                $log->debug( "processed $idx rows" ) unless $idx % 100;
                my ($nlsid, $seq, $mod_seq, $prot, $precur_mz, $pep_chg, 
                $alt_name, $prob, $n_obs, $n_samples, $n_prot_map,
                $n_gen_map, $ssrcalc ) = @{$row};

                my $sql2 = qq~
                SELECT top $n_highest_intensity_fragment_ions NLSP.mz,
                NLSP.relative_intensity, NLSP.ion_label, NLSP.charge
                FROM $TBAT_NIST_LIBRARY_SPECTRUM_PEAK NLSP
                WHERE NIST_library_spectrum_id = '$nlsid'
                ORDER BY NLSP.relative_intensity DESC
                ~;

                my @rows2 = $sbeams->selectSeveralColumns($sql2);
                my $spec = "<a href='$CGI_BASE_DIR/$SBEAMS_SUBDIR/ShowOneSpectrum?NIST_library_spectrum_id=$nlsid' target='_blank'><b>SHOW SPECTRUM</b></a>";
                my $spec = "<A HREF='ShowOneSpectrum?NIST_library_spectrum_id=$nlsid' TARGET=blank><IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='Show spectrum'></A>";

                my $maxrows = 4;
                my $idx = 0;
                for my $nist ( @rows2 ) {
                  $ssrcalc = sprintf( "%0.2f", $ssrcalc );
                  $nist->[0] = sprintf( "%0.3f", $nist->[0] );
                  $precur_mz = sprintf( "%0.3f", $precur_mz );
                  push @display_rows, [ $prot, $mod_seq, $pep_chg, $precur_mz, $nist->[0], $nist->[1], $nist->[2], $ssrcalc, $n_obs, $spec ] if $nist->[2];
                  last if $idx >= $maxrows;
                  $idx++;
                }
            }

            my $html = $sbeamsMOD->encodeSectionTable(  header => 1, 
                                                 width => '600',
                                                align  => [qw(left left center right right right center right center center)],
                                                  rows => \@display_rows,
                                          rows_to_show => 50,
                                           chg_bkg_idx => 1,
                                                nowrap => [1..10],
                                              max_rows => 500,
                                          set_download => 1
                                                );
            print "<TABLE>$html</TABLE>";

        }


    #### If QUERY was not selected, then tell the user to enter some parameters
    } else 
    {
        if ($sbeams->invocation_mode() eq 'http') 
        {
            print "<H4>Select parameters above and press QUERY</H4>\n";
        } else 
        {
            print "You need to supply some parameters to contrain the query\n";
        }
    }

    ###################################################################
    # getB1FragMassArray - get array of frag masses for b+
    #
    # @param masses_ref - ref to array of masses that alredy include modifications
    # @return @b1
    ###################################################################
    sub getB1FragMassArray
    {
        my %args = @_;
      
        my $masses_ref = $args{masses_ref};

        my @masses = @{$masses_ref};

        my @b1; 

        ## calc b+ ions:
        my $b1_sum = 1.0078;

        for (my $i=0; $i <= $#masses; $i++)
        {
            $b1_sum = $b1_sum + $masses[$i];

            if ($i == $#masses)
            {
                push(@b1, "&nbsp;");
            } else
            {
                push(@b1, sprintf("%.4f",$b1_sum));
            }
        }

        return @b1;
    }

    ###################################################################
    # getY1FragMassArray - get array of frag masses for y+
    #
    # @param masses_ref - ref to array of masses that alredy include modifications
    # @return @y1
    ###################################################################
    sub getY1FragMassArray
    {
        my %args = @_;
      
        my $masses_ref = $args{masses_ref};

        my @masses = @{$masses_ref};

        my @y1 = @masses; ## initialize y1 to be same size array 

        ## calc y+ ions:
        my $y1_sum = 19.0184;

        for (my $i = $#masses; $i >= 0; $i--)
        {
            $y1_sum = $y1_sum + $masses[$i];

            my $ind = $#masses - $i;

            if ($ind == $#masses)
            {
                $y1[$ind] = "&nbsp;";
            } else
            {
                $y1[$ind] = sprintf("%.4f",$y1_sum);
            }
        }

        return @y1;
    }

    ###################################################################
    # getY2FragMassArray - get array of frag masses for y+
    #
    # @param y1_ref - ref to array of y1 masses
    # @return @y2
    ###################################################################
    sub getY2FragMassArray
    {
        my %args = @_;
      
        my $y1_ref = $args{y1_ref};

        my @y1 = @{$y1_ref};

        my @y2 = @y1; ## initialize y2 to be same size array 

        for (my $i=0; $i <= $#y1; $i++)
        {
            unless ($y1[$i] eq "&nbsp;") 
            {
                my $t = ($y1[$i] + 1.0078)/2.;

                $y2[$i] = sprintf("%.4f",$t);
            }
        }

        return @y2;
    }

    ###################################################################
    # initArray - initialize array to size li
    # @param li - size of array
    # @return ia - array initialized to hold &nbsp; for each element
    ###################################################################
    sub initArray
    {
        my %args = @_;
        
        my $li = $args{li};

        my @ia;

        for (my $i=0; $i <= $li; $i++)
        {
            push(@ia, "&nbsp;"); 
        }

        return @ia;
    }

} # end handle_request

