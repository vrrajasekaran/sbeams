#!/usr/local/bin/perl

###############################################################################
# Program     : quant_info
# $Id: $
#
# Description : This script displays details about a single quant SRM Atlas peptide
#
# SBEAMS is Copyright (C) 2000-2013 Institute for Systems Biology
# This program is governed by the terms of the GNU General Public License (GPL)
# version 2 as published by the Free Software Foundation.  It is provided
# WITHOUT ANY WARRANTY.  See the full description of GPL terms in the
# LICENSE file distributed with this software.
#
###############################################################################


use strict;
use vars qw ($q $sbeams $atlas $PROG_NAME
             $current_contact_id $current_username);
use lib qw (../../lib/perl);
use CGI::Carp qw(fatalsToBrowser croak);
use Statistics::LineFit;

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::DataTable;
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::TabMenu;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;

$sbeams = new SBEAMS::Connection;
$atlas = new SBEAMS::PeptideAtlas;
$atlas->setSBEAMS($sbeams);


###############################################################################
# Global Variables
###############################################################################
$PROG_NAME = 'quant_info';
main();


###############################################################################
# Main Program:
#
# Call $sbeams->Authentication and stop immediately if authentication
# fails else continue.
###############################################################################
sub main
{
    #### Do the SBEAMS authentication and exit if a username is not returned
    exit unless ($current_username = $sbeams->Authenticate(
        permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
        'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
        #connect_read_only=>1,
#allow_anonymous_access=>1,
    ));


    #### Read in the default input parameters
    my %parameters;
    my $n_params_found = $sbeams->parse_input_parameters(
        q=>$q,
        parameters_ref=>\%parameters
        );


    ## get project_id to send to HTMLPrinter display
    my $project_id = $atlas->getProjectID(
        atlas_build_name => $parameters{atlas_build_name},
        atlas_build_id => $parameters{atlas_build_id}
        );


    #### Process generic "state" parameters before we start
    $sbeams->processStandardParameters(parameters_ref=>\%parameters);
#    $sbeams->printCGIParams($q);


    #### Decide what action to take based on information so far
    if ($parameters{action} eq "???") {

        # Some action
 
    } else {

      # zhi says maybe make a new version of this subroutine to put in new style sheet
        $atlas->display_page_header(project_id => $project_id);

        print $sbeams->getGifSpacer(800);

        handle_request(ref_parameters=>\%parameters);

        $atlas->display_page_footer();

    }




} # end main


###############################################################################
# Show the page
###############################################################################
sub handle_request {

    my %args = @_;

    #### Process the arguments list
    my $ref_parameters = $args{'ref_parameters'}
        || die "ref_parameters not passed";

    my %parameters = %{$ref_parameters};


  #### Get the current atlas_build_id based on parameters or session
  my $atlas_build_id = $atlas->getCurrentAtlasBuildID(
    parameters_ref => \%parameters,
  );
  if (defined($atlas_build_id) && $atlas_build_id < 0) {
    #### Don't return. Let the user pick from a valid one.
    #return;
  }


  #### Get the HTML to display the tabs
  my $tabMenu = $atlas->getTabMenu(
    parameters_ref => \%parameters,
    program_name => $PROG_NAME,
  );
  if ($sbeams->output_mode() eq 'html') {
    print "<BR>\n";
    print $tabMenu->asHTML() if ($sbeams->output_mode() eq 'html');
    print "<BR>\n";
  }


    #### Read in the standard form values
    my $apply_action  = $parameters{'action'} || $parameters{'apply_action'};
    my $TABLE_NAME = $parameters{'QUERY_NAME'};


    #### Set some specific settings for this program
    my $PROGRAM_FILE_NAME = $PROG_NAME;
    my $base_url = "$CGI_BASE_DIR/$SBEAMS_SUBDIR/$PROGRAM_FILE_NAME";
    my $help_url = "$CGI_BASE_DIR/help_popup.cgi";
    my $ppt = $parameters{'ppt'} || 0;
    my $table_width = $parameters{'width'} || 800;

    my $aslog = ( $parameters{plottype} && $parameters{plottype} eq 'linear' ) ? 'false' : 'true';
    my $expt_id = $parameters{expt_id} || 1;

    #### Get a list of accessible project_ids
    my @accessible_project_ids = $sbeams->getAccessibleProjects();
    my $accessible_project_ids = join( ",", @accessible_project_ids ) || '0';

    my $sql = qq~
    SELECT peptide_sequence, precursor_mz, titr_min, titr_max, r_sq, lod, loq, linear_min, linear_max, fold, quantitative
    FROM peptideatlas.dbo.mtb_quant_info
    WHERE peptide_sequence = '$parameters{peptide_sequence}'
    ~;
	  my @row = $sbeams->selectSeveralColumns($sql);
		my @quant = @{$row[0]};

    my @entries = ( { key => 'Peptide Sequence', value => 'Amino acid sequence of target peptide' },
                    { key => 'Precursor m/z', value => 'Mass to charge ratio of intact precursor' },
                    { key => 'Titration range', value => 'Range of concentration of calibration curve (femtomoles)' },
                    { key => 'R-squared value', value => 'R-squared measure of correlation from calibration curve' },
                    { key => 'LOD', value => 'Limit of detection (LOD) in femtomoles' },
                    { key => 'LOQ', value => 'Limit of quantitation (LOQ) in femtomoles' },
                    { key => 'Linear range', value => 'Range of concentration of linear portion of calibration curve (femtomoles)' },
                    { key => 'Fold', value => 'Fold concentration of linear range' },
                    { key => 'Is quantitative', value => 'Is assay considered to be quantiative' },
    );

    my $showtext = 'show row descriptions';
    my $hidetext = 'hide row descriptions';
    my $heading = 'Quantation Information (no matrix)';
    my $description= 'Quantiation information determined for this peptide in buffer background (no matrix)';

    my $help = $atlas->get_table_help_section( name => 'Quantitation',
                                        description => $description,
                                            heading => $heading,
                                            entries => \@entries,
                                           showtext => $showtext,
                                           hidetext => $hidetext  );



    my $table = "<TABLE WIDTH=800>\n";

    my ( $tr, $link ) = $sbeams->make_table_toggle( name    => 'overview',
                                                  visible => 1,
                                                  tooltip => 'Show/Hide Section',
                                                  imglink => 1,
                                                  sticky  => 1 );

    $table .= $atlas->encodeSectionHeader(
      text => 'Quantitation information',
      span => 4,
      link => $link
    );
    my $spc = $sbeams->getGifSpacer(400);

    my @entries = ( { key => 'Peptide Sequence', value => 'Amino acid sequence of target peptide' },
                    { key => 'Precursor m/z', value => 'Mass to charge ratio of intact precursor' },
                    { key => 'Titration range', value => 'Range of concentration of calibration curve (femtomoles)' },
                    { key => 'R-squared value', value => 'R-squared measure of correlation from calibration curve' },
                    { key => 'LOD', value => 'Limit of detection (LOD) in femtomoles' },
                    { key => 'LOQ', value => 'Limit of quantitation (LOQ) in femtomoles' },
                    { key => 'Linear range', value => 'Range of concentration of linear portion of calibration curve (femtomoles)' },
                    { key => 'Fold change', value => 'Fold concentration of linear range' },
                    { key => 'Is quantitative', value => 'Is assay considered to be quantiative' }  );


  $table .= $atlas->encodeSectionItem( key => 'Peptide Sequence', tr_info => $tr, value => $quant[0] ) . "\n";
  $table .= $atlas->encodeSectionItem( key => 'Precursor m/z', tr_info => $tr, value => sprintf( "%0.3f", $quant[1] ) ) . "\n";

  # Minimal format
  my $mf = ( $quant[2] < 1 ) ? 2 : 1;
  $table .= $atlas->encodeSectionItem( key => 'Titration range', tr_info => $tr, value => sprintf( "%0.${mf}f", $quant[2] ) . '-' . sprintf( "%0.1f", $quant[3] ) ) . "\n";

  $table .= $atlas->encodeSectionItem( key => 'R-squared value', tr_info => $tr, value => sprintf( "%0.4f", $quant[4] ) ) . "\n";

  $mf = ( $quant[5] < 1 ) ? 2 : 1;
  $table .= $atlas->encodeSectionItem( key => 'LOD', tr_info => $tr, value => sprintf( "%0.${mf}f", $quant[5] ) ) . "\n";
  
  $mf = ( $quant[6] < 1 ) ? 2 : 1;
  $table .= $atlas->encodeSectionItem( key => 'LOQ', tr_info => $tr, value => sprintf( "%0.${mf}f", $quant[6] ) ) . "\n";

  $mf = ( $quant[7] < 1 ) ? 2 : 1;
  $table .= $atlas->encodeSectionItem( key => 'Linear range', tr_info => $tr, value => sprintf( "%0.${mf}f", $quant[7] )  . '-' . sprintf( "%0.1f", $quant[8]  ) ) . "\n";


  $table .= $atlas->encodeSectionItem( key => 'Fold change', tr_info => $tr, value => sprintf( "%0.1f", $quant[9] ) ) . "\n";

	my $is_quant = ( $quant[10] eq 'N' ) ? "No $spc" : "Yes $spc";
  $table .= $atlas->encodeSectionItem( key => 'Is quantitative', tr_info => $tr, value => $is_quant ) . "\n";

  $table .= "</TABLE>\n";

  print $help;
  print $table;


  # If we have quant data, show a plot.
	my $pre_mz = sprintf( "%0.4f", $quant[1] );
	my $mz_low = int( $quant[1] );
	my $mz_hi = $mz_low + 1;

  my $qsql = qq~
  SELECT DISTINCT precursor_mz, product_mz, area, dilution ,concentration, replicate_number
  FROM  peptideatlas.dbo.quant_data 
  WHERE peptide_sequence = '$parameters{peptide_sequence}' 
  AND precursor_mz > $pre_mz - 1
  AND precursor_mz < $pre_mz + 1
  ORDER by precursor_mz, product_mz, dilution, concentration
	~;

  my $sth = $sbeams->get_statement_handle( $qsql );

	my %data;
	my %ldata;
  my $cnt = 1;
  my @data;

  my %dil = ( 5 => 1,
              4 => 4,
              3 => 16,
              2 => 64,
              1 => 256,
              0 => 1024 );

  my $microliters_injected = 2;

  my %avg;
              
  while ( my @row = $sth->fetchrow_array() ) {

    

		my $mz = sprintf( "%0.4f", $row[1] );
		my $area = sprintf( "%0.1f", $row[2] );
		my $conc = sprintf( "%0.2f", $microliters_injected * ($row[4]/$dil{$row[3]}) );
    my $rep = $row[5];

    my $pre_mz = sprintf( "%0.4f", $row[0] );
    $avg{$conc} ||= { total => 0 };
    $avg{$conc}->{total} += $area;

    $avg{$conc}->{$mz} += $area;

#    push @data, [ $mz, $area, $row[3], $dil{$row[3]}, $conc, $row[5] ];
    $data{$mz} ||= {};
    $data{$mz}->{$conc} ||= {};
    $data{$mz}->{$conc}->{$rep} = $area;
    $cnt++;
	}
  use Data::Dumper;
#  die Dumper( %data );
	return unless %data; 

  my ( $div_strings, $chart_functions, $chart_callbacks ) = get_avg_plot( \%avg );

	for my $frag ( sort{ $a <=> $b } keys( %data ) ) {
    my $js_data = '';
    my $conc_str .= "begin: ";
    for my $conc ( sort{ $b <=> $a } keys( %{$data{$frag}} ) ) {
      $conc_str .= "$conc... ";
#      print "conc is $conc<BR>\n";
      my @reps = sort { $a <=> $b } ( keys( %{$data{$frag}->{$conc}} ) );

      if ( !$js_data ) {
        $js_data .= "['Conc'";
        for my $rep ( @reps ) {
          $js_data .= ", 'rep_$rep'";
        }
        $js_data .= ",'Avg']";
      }

      my @areas;
      my $tot = 0;
      my $cnt = 0;
    	for my $rep ( @reps ) {
        my $val = $data{$frag}->{$conc}->{$rep};
        $val = 1 if $val < 1;
        $tot += $val;
	  	  push @areas, $val;
        $cnt++;
      }
      my $avg = int( abs($tot/$cnt) );
      $avg ||= 1;
      push @areas, $avg;
	  	$js_data .= ",\n[$conc," . join( ',', @areas ) . ']';
    }
#    die Dumper( $js_data );

  		my $div_name = $sbeams->getRandomString( num_chars => 20 );

#	 	my $line_info = "<BR> r-squared = $rSquared,  y=$slope*x + $intercept";
      my $line_info = '';
  		$div_strings .= qq~<BR><DIV style="border: 1px solid gray; width: 500px" > <div id="$div_name" style="width: 500px; height: 360px" > </div><CENTER>$line_info</CENTER></DIV>~;
#		$div_strings .= qq~<BR><DIV style="width: 500px; height: 360px; border: 1px solid gray"   <div id="$div_name" style="width: 500px; height: 360px; border: 1px solid gray" > </div>~;

      $chart_callbacks .= "google.setOnLoadCallback(draw_${div_name}_Chart);\n";
		$chart_functions .= qq~
      function draw_${div_name}_Chart() {
        var data = google.visualization.arrayToDataTable([
				$js_data
        ]);

        var options = {
          title: "$quant[0] product ion $frag",
					pointSize:  3,
					hAxis: {title: 'Femtomoles on Column', logScale: $aslog   },
					vAxis: {title: 'Intensity (area under chromatogram)', logScale: $aslog },
					series: [{ pointSize: 4 },{ pointSize: 4 },{ pointSize: 4 },{ pointSize: 4 },{ pointSize: 4 },  { pointSize: 2, lineWidth: 1, visibleInLegend: true}]
        };

        var chart = new google.visualization.ScatterChart(document.getElementById('$div_name'));
        chart.draw(data, options);
      }
		~;
	}

  print qq~
    $div_strings
    <script type="text/javascript" src="https://www.google.com/jsapi"></script>
    <script type="text/javascript">
      google.load("visualization", "1", {packages:["corechart"]});
			$chart_callbacks
			$chart_functions
    </script>
   <BR><BR>
	~;


} # end showMainPage

sub get_avg_plot {
  my $avg = shift;
  
  my $aslog = 'true';
  my @quant;
  my $frag;

  my @concs;
  my $js_data;
  my @data_pts;
  my $titles = "['Conc',";
  my $h_seen = 0;
  for my $conc ( sort { $a <=> $b } keys( %{$avg} ) ) {
    my $sep = '';
    my $data_pt = "[$conc,";
    for my $pt ( sort { $a <=> $b } keys( %{$avg->{$conc}} ) ) {
      $avg->{$conc}->{$pt} ||= 5;
      my $val = int( $avg->{$conc}->{$pt} / 5 );
      $titles .= $sep . "'$pt'" unless $h_seen;
      $data_pt .= $sep . "$val";
      $sep ||= ',';
    }
    $titles .= "],\n" unless $h_seen;
    $data_pt .= "]";
    push @data_pts, $data_pt;
    $h_seen++;
  }
#  die Dumper( $titles );
  $js_data = $titles . join( ",\n", @data_pts ) . "\n";
#  die Dumper( $js_data );


  my $div_name = $sbeams->getRandomString( num_chars => 20 );

  my $line_info = '';
  my $div_strings .= qq~<BR><DIV style="border: 1px solid gray; width: 500px" > <div id="$div_name" style="width: 500px; height: 360px" > </div><CENTER>$line_info</CENTER></DIV>~;

  my $chart_callbacks .= "google.setOnLoadCallback(draw_${div_name}_Chart);\n";
  my $chart_functions .= qq~
  function draw_${div_name}_Chart() {
    var data = google.visualization.arrayToDataTable([
      $js_data
    ]);

    var options = {
      title: "$quant[0] product ion $frag",
      pointSize:  3,
      hAxis: {title: 'Femtomoles on Column', logScale: $aslog   },
      vAxis: {title: 'Intensity (area under chromatogram)', logScale: $aslog },
      series: [{ pointSize: 4, lineWidth: 1 },{ pointSize: 4, lineWidth: 1 },{ pointSize: 4, lineWidth: 1 },{ pointSize: 4, lineWidth: 1 },{ pointSize: 4, lineWidth: 1 },  { pointSize: 4, lineWidth: 1, visibleInLegend: true}]
    };

    var chart = new google.visualization.ScatterChart(document.getElementById('$div_name'));
    chart.draw(data, options);
  }
~;
  return( $div_strings, $chart_callbacks, $chart_functions );
}
