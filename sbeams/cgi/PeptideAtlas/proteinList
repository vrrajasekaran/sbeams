#!/usr/local/bin/perl

###############################################################################
# $Id: $
#
# SBEAMS is Copyright (C) 2000-2007 Institute for Systems Biology
# This program is governed by the terms of the GNU General Public License (GPL)
# version 2 as published by the Free Software Foundation.  It is provided
# WITHOUT ANY WARRANTY.  See the full description of GPL terms in the
# LICENSE file distributed with this software.
###############################################################################


###############################################################################
# Get the script set up with everything it will need
###############################################################################
use strict;
#use vars qw ($sbeams);
use lib qw (../../lib/perl);
#use CGI::Carp qw(fatalsToBrowser croak);
  use Data::Dumper;

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::DataTable;
use SBEAMS::Connection::GoogleVisualization;
use SBEAMS::Connection::TabMenu;


use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;


###############################################################################
# Global Variables
###############################################################################
my $sbeams = new SBEAMS::Connection;
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);
my $atlas = new SBEAMS::PeptideAtlas;
$atlas->setSBEAMS($sbeams);

# Read input parameters
my $params = process_params();

my $show_image = 0;


{ # Main 

    # Authenticate or exit
    my $username = $sbeams->Authenticate( allow_anonymous_access => 0) || exit;


    ## get current settings
    my $project_id = $sbeams->getCurrent_project_id();

    my $list_help = get_table_help( table => 'list' );
    my $protein_help = get_table_help( table => 'protein' );

    my $page = $sbeams->getGifSpacer( 700 ) . "<BR>\n";

    # Get the HTML to display the tabs
    my $tabMenu = $atlas->getTabMenu(
      parameters_ref => $params,
      program_name => 'domainProteinList',
    );

    $page .=<<"    END";
		$tabMenu
    <P>
    <BR><BR>
    </P>
    $list_help
    END


    my $build_id = $params->{atlas_build_id} || $atlas->getCurrentAtlasBuildID(parameters_ref => $params);
    my $valid_build = 1;
    if ( !grep /^$build_id$/, $atlas->getAccessibleBuilds() ) {
       $atlas->display_page_header();
       $build_id = $atlas->getCurrentAtlasBuildID(parameters_ref => $params);
		   $atlas->display_page_footer();
       exit;
    }


    # Add general section 
    $page .= get_filter_js();
    $page .= get_list_overview();

    $page .= "<BR><BR><BR>";

    $page .= get_list_table();

    # Print what we already have, speed up apparent page loading time.
    $atlas->display_page_header( onload => "set_toggle_box( 'protein_list_table' );sortables_init()", sortable => 1 );
		print $page;

		$atlas->display_page_footer();

} # end main

sub get_table_help {
  my %args = @_;
  my $name = $args{table};
  return '' unless $name;
  $args{mode} ||= 'section';
  my @entries;
  my $hidetext;
  my $showtext;
  my $heading;
  my $description;

  if ( $name eq 'build' ) {  
    @entries = ( { key => 'Build Name', value => 'The simple name for this build, usually contains organism, prophet cutoff, and other information. ' },
                 { key => 'Build Description', value => 'More detailed information about build. ' },
                 { key => 'Reference Database', value => 'Database to which peptides were mapped, generally different than search database.  This mapping is done by running BLAST, and allows the peptides to be mapped the the organism\'s genomic sequence. ' },
                 { key => 'Build Date', value => 'Date upon which build was finished. ' },
                 { key => '# Samples', value => 'The number of individual samples which comprise this build.  Each sample contains one or more LCMS/MS runs, and generally corresponds to a single scientific experiment.' } ,
                 { key => 'Distinct Peptides', value => 'This shows the number of distinct peptide sequences that were seen in this build.  Observations of the peptide in different charge states or with different modifications are coalesced.' } ,
                 { key => 'Total Observations ', value => 'The total number of spectra that yeilded identifications above the build threshold.  Observations of the same base peptide sequences multiple times or in various charge states/modifications, whould each contribute to the total' }
        );
                 
    $showtext = 'show row descriptions';
    $hidetext = 'hide row descriptions';
    $heading = 'Build Overview';
    $description= 'These values pertain to the atlas build as a whole';


  } elsif ( $name eq 'batch' ) {
    @entries = ( { key => 'ID', value => 'Database ID for this sample (search batch) ' },
                 { key => 'Sample_Name', value => 'Simple name for this sample/experiment. ' },
                 { key => '#_Spectra_Searched', value => 'The total number of spectra searched in the sample. ' },
                 { key => "#_Spectra_ID'd", value => 'The number of spectra identifed with a probability greater than the atlas threshold ' },
                 { key => '#_Distinct', value => 'The number of distinct peptide sequences, seen more than once (multiobs), in this build that are seen in this sample. ' },
                 { key => '#_Unique', value => "The number of distinct, multiobs peptides that are seen only in this sample (unique contribution).  This discriminates against smaller samples, and is less useful in atlas' with a large number of samples. " },
                 { key => '#_Progressive', value => 'Order-dependent unique multiobs peptides contributed by a given sample.  The contribution for each sample is based on the samples that have gone before it, so later samples tend to have a lower progressive contribution. ' },
                 { key => '#_Cumulative', value => 'Order-dependent cumulative number of unique multiobs peptides contributed to build by this and previous samples. ' },
                 { key => '#_Proteins', value => 'The number of canonical (highly distinguishable, non-redundant) protein sequences identified from the peptides in this sample.' },
                 { key => '#_Cum_Prots', value => 'Order-dependent cumulative number of canonical proteins contributed to build by this and previous samples.<br>Counts non-human contaminants, so final tally may be greater than Canonical Proteins count in Build Overview. ' },
#                 { key => 'Sens', value => 'The sensitivity of the Peptide Prophet model at a probablility of 0.9, the percent of true positives that would be included at that threshold was used as a cutoff. ' },
                 { key => 'FDR_(%)', value => 'The error rate of peptides above the threshold Peptide Prophet model at a probablility of 0.9, the percent of false positives that would be included at the build threshold. ' },
                 { key => 'Sample_Date', value => ''},
        );
    $heading = 'Sample Overview'; 
    $description = 'These values pertain to individual samples within the atlas';

  } elsif ( $name eq 'mayu' ) {
   @entries = ( { key => 'nr_runs', value => 'Number of MS runs contributing to this build '},
  
		{ key => 'nr_files', value => 'Always 1 '},
  
		{ key => 'mFDR', value => 'Data in current row applies to all data meting this PSM (spectrum) FDR threshold. '},
		{ key => 'target_PSM', value => 'Number of non-decoy PSMs at this mFDR (counts peptides mappable to protein reference set only)'},
  
		{ key => 'decoy_PSM', value => 'Number of decoy PSMs at this mFDR '},
  
		{ key => 'FP_PSM', value => 'Number of false positive PSMs predicted by Mayu for this mFDR. Usually near, but not exactly the same as, the number of decoys. '},
  
		{ key => 'TP_PSM', value => 'target_PSM - FP_PSM '},
  
		{ key => 'target_pepID', value => 'Number of non-decoy unique peptides at this mFDR (counts peptides mappable to protein reference set only) '},
  
		{ key => 'decoy_pepID', value => 'Number of decoy unique peptides at this mFDR '},
  
		{ key => 'FP_pepID', value => 'Number of false positive unique peptides predicted by Mayu for this mFDR. Usually near, but not exactly the same as, the number of decoys. '},
  
		{ key => 'FP_pepID_stdev', value => ' '},
  
		{ key => 'TP_pepID', value => 'target_pepID - FP_pepID '},
  
		{ key => 'pepFDR', value => 'Peptide FDR (unique peptides)'},
  
		{ key => 'target_protID', value => 'Number of non-decoy protein identifications at this mFDR. Applied to the covering set of proteins -- a set that is close to the smallest necessary to explain all the pepIDs. Includes all canonicals and some possibly_distinguished. '},
  
		{ key => 'decoy_protID', value => 'Number of decoy protein identifications at this mFDR. '},
  
		{ key => 'FP_protID', value => 'Number of false postiive protein identifications predicted by Mayu for this mFDR.  Usually near, but not exactly the same as, the number of decoys. '},
  
		{ key => 'FP_protID_stdev', value => ' '},
  
		{ key => 'TP_protID', value => 'target_protID - FP_protID '},
  
		{ key => 'protFDR', value => 'Protein FDR. The largest value in this column is the protein FDR for the entire build. '},
		{ key => 'lFDR1, lFDR5, lFDR10,2 lFDR5', value => 'Local protein FDR, computed over the previous step (i.e. between the previous row in the table and the current row), the previous 5 steps, the previous 10 steps, and the previous 25 steps.<br>Often there are fewer than 25 rows in the table, in which case column lFDR25 is uninformative. '},
  
		{ key => 'target_protIDs, decoy_protIDs, etc.', value => 'Same as above, except for singleton proteins (those identified by only one PSM) only. '},
		{ key => 'target_protIDns, decoy_protIDns, etc.', value => 'Same as above, except for multiply-observed proteins only. '},
  
        );
    $heading = 'Mayu'; 
    $description = 'Reiter L, Claassen M, et al., Protein identification false discovery rates for very large proteomics data sets generated by tandem mass spectrometry, Mol Cell Proteomics. 2009 Nov;8(11):2405-17 ';
  }


  return unless @entries;
  return \@entries if $args{mode} eq 'entries_only';

  my $help = $atlas->get_table_help_section( name => $name,
                                             description => $description,
                                             heading => $heading,
                                             entries => \@entries,
                                             showtext => $showtext,
                                             hidetext => $hidetext  );
  return $help;

} # end get_table_help


# General list information
sub get_list_overview {

  my $build_id = shift;
  
  # Get a list of accessible project_ids
  my @project_ids = $sbeams->getAccessibleProjects();
  my $project_ids = join( ",", @project_ids ) || '0';

  my $info = $sbeams->selectrow_hashref( <<"  BUILD" );
  SELECT title, description, n_proteins, original_file
  FROM $TBAT_DOMAIN_PROTEIN_LIST 
  WHERE protein_list_id = $params->{protein_list_id}
  AND record_status <> 'D'
  AND project_id IN ( $project_ids );
  BUILD

  my $table = "<TABLE WIDTH=800>\n";

  my ( $tr, $link ) = $sbeams->make_table_toggle( name    => 'build_overview',
                                                  visible => 1,
                                                  tooltip => 'Show/Hide Section',
                                                  imglink => 1,
                                                  sticky  => 1 );

  $table .= $atlas->encodeSectionHeader(
      text => 'Domain Protein List Overview',
      span => 4,
      link => $link
  );
  for my $key ( keys( %{$info} ) ) {
    $info->{lc($key)} = $info->{$key};
  }

  my $spc = $sbeams->getGifSpacer(500);

  $table .= $atlas->encodeSectionItem( key   => 'List Name', tr_info => $tr,
                            value => $info->{title} . $spc, vspan => 3 ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Description', tr_info => $tr,
                            value => $info->{description}, vspan => 3 ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Number of Proteins', tr_info => $tr,
                            value => $info->{n_proteins}, vspan => 3 ) . "\n";
  $table .= $atlas->encodeSectionItem( key   => 'Source File', tr_info => $tr,
                            value => $info->{original_file}, vspan => 3 ) . "\n";

  $table .= "</TABLE>\n";
  return $table;

}

# Peptide build stats
sub get_list_table {

  my $build_id = shift;

  # Get a list of accessible project_ids
  my @project_ids = $sbeams->getAccessibleProjects();
  my $project_ids = join( ",", @project_ids ) || '0';


  my $table = "<table width=600  id='protein_list_section'>\n";

  my $sql =<<"  END";
  SELECT list_protein_id, uniprot_accession, protein_symbol, original_name, protein_full_name, gene_symbol, comment, priority
  FROM $TBAT_DOMAIN_LIST_PROTEIN
  WHERE protein_list_id = $params->{protein_list_id}
  ORDER BY uniprot_accession ASC
  END

  my @samples;
  my $sth = $sbeams->get_statement_handle( $sql );
  while( my @row = $sth->fetchrow_array() ) {
    $row[0] = "<input type='checkbox' name=protein_ids id=protein_ids value=$row[0] onclick=cnt_checked('protein_list_table')></input>";
    $row[3] ||= $row[1];
    $row[7] = $sbeams->makeInfoText( "n/a" );
    $row[4] = $sbeams->truncateStringWithMouseover( string => $row[4], len => 60, nowrap => 1 );
    $row[6] = $sbeams->truncateStringWithMouseover( string => $row[6], len => 60 );
    push @samples, \@row;
  }
  

  my $dag = '<sup>&dagger;</sup>';
  
  my @headings = ( Add => 'list_protein_id', 
                   UniProt => 'uniprot_accession',
                   ProteinSymbol => 'protein_symbol',
                   OriginalName => 'original_name',
                   ProteinFullName => 'protein_full_name',
                   GeneSymbol => 'gene_symbol',
                   Comment => 'comment',
                   Priority => 'priority'
                   );

#  for my $h ( @headings ) {
#    $log->info( $h );
#  }

  my $headings_ref = $atlas->make_sort_headings( headings => \@headings, default => 'UniProt' );

#  $table .= $atlas->encodeSectionHeader(
#      text => 'List Proteins',
#      width => 920
#  );

  $table .= $atlas->encodeSectionTable( rows => [ $headings_ref, @samples ],
                                        header => 1,
                                        nowrap => [1..scalar(@headings)],
                                        table_id => 'protein_list_table',
                                        class => 'filterable',
                                        align => [ qw(center left right right right right right right right right right center) ],
                                        bg_color => '#EAEAEA',
                                        sortable => 1 );


  $table .= '</table>';

 my $btxt = get_btxt( qw( Selected All Uncheck Check Search ) );
# die Dumper( $btxt );
  my $fbox_help = '<td> ' . $sbeams->makeInfoText( "Text entered into the box will filter the protein list (all fields)" ) . '</td>';
  my $cbox_help = '<td> ' . $sbeams->makeInfoText( "Use these buttons to check or uncheck the visible proteins" ) . '</td>';
  my $show_help = '<td> ' . $sbeams->makeInfoText( "Use these buttons to show all your selected proteins or the entire list (resets filter box)" ) . '</td>';
  my $submit_help = '<td> ' . $sbeams->makeInfoText( "This will submit your list of selected proteins to the SRM Atlas for a transitions query" ) . '</td>';


  my $form = qq~
  <script type="text/javascript">
  function set_toggle_box( table ) {
    toggle_table = document.getElementById( table );
    toggle_table.rows[0].cells[0].innerHTML = "<input type=checkbox id=togglebox onclick=toggle_togglebox('" + table + "');return false; />";
    return false;
  }

  function toggle_togglebox(table) {
    toggle_table = document.getElementById( table );
    if ( toggle_table.rows[0].cells[0].getElementsByTagName('input')[0].checked ) {
      check_boxes( table );
    } else {
      uncheck_boxes( table );
    }
    return false;
  }

  function toggle_boxes( table ) {
    toggle_table = document.getElementById( table );
	  for (var r = 1; r < toggle_table.rows.length; r++) {
      display = toggle_table.rows[r].style.display;
      if ( display == "none" ) {
        continue;
      }
      if ( toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked ) {
        toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked = false;
      } else {
        toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked = true;
      }
	  }
    return false;
  }
  function check_boxes( table ) {
  toggle_table = document.getElementById( table );
	  for (var r = 0; r < toggle_table.rows.length; r++) {
      if ( toggle_table.rows[r].style.display == 'none' ) {
        continue;
      }
      toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked = true;
	  }
    cnt_checked( table );
    return false;
  }
  function uncheck_boxes( table ) {
  toggle_table = document.getElementById( table );
	  for (var r = 0; r < toggle_table.rows.length; r++) {
      if ( toggle_table.rows[r].style.display == 'none' ) {
        continue;
      }
      toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked = false;
	  }
    cnt_checked( table );
    return false;
  }

  function cnt_checked ( table ) {
    var tot = 0;
    var chk = 0;
    var toggle_table = document.getElementById( table );
	  for (var r = 1; r < toggle_table.rows.length; r++) {
      tot += 1;
      if ( toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked ) {
        chk += 1;
      }
    }
    document.getElementById( 'chk_status' ).innerHTML = chk + ' of ' + tot + ' proteins are currently selected';
    return false;
  }

  function show_selected(table) {
    document.getElementById( 'filterbox' ).value = '';
    var toggle_table = document.getElementById( table );
    dehighlight( toggle_table );
	  for (var r = 1; r < toggle_table.rows.length; r++) {
      if ( toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked ) {
        toggle_table.rows[r].style.display = '';
      } else {
        toggle_table.rows[r].style.display = 'none';
      }
    }
    return false;
  }
  function show_all(table)  {
    document.getElementById( 'filterbox' ).value = '';
    toggle_table = document.getElementById( table );
    dehighlight( toggle_table );
	  for (var r = 1; r < toggle_table.rows.length; r++) {
      if ( toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked ) {
      }
      toggle_table.rows[r].style.display = '';
    }
    return false;
  }

  function submit_form ( table ) {
    toggle_table = document.getElementById( table );
    var chk = 0;
    var proteins = '';
	  for (var r = 1; r < toggle_table.rows.length; r++) {
      if ( toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked ) {
        if ( proteins == '' ) {
          proteins = toggle_table.rows[r].cells[1].innerHTML;
        } else {
          proteins = proteins + ';' + toggle_table.rows[r].cells[1].innerHTML;
        }
        chk += 1;
      }
    }
    var protein_constraint = document.getElementById( 'protein_name' );
    protein_constraint.value = proteins;
    if ( chk > 50 ) {
      alert( 'You submitted ' + chk + ' proteins, interface is currently limited to 50 or fewer' );
      return false;
    }
	  for (var r = 0; r < toggle_table.rows.length; r++) {
      toggle_table.rows[r].cells[0].getElementsByTagName('input')[0].checked = false;
    }
    return true;
  }


 </script>

  <style>
		.highlighted { background: lightskyblue; }
    .protein_list_button { -moz-box-shadow:inset 0px 1px 14px -1px #bbdaf7; -webkit-box-shadow:inset 0px 1px 14px -1px #bbdaf7; box-shadow:inset 0px 1px 14px -1px #bbdaf7; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #79bbff), color-stop(1, #378de5) ); background:-moz-linear-gradient( center top, #79bbff 5%, #378de5 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#79bbff', endColorstr='#378de5'); background-color:#79bbff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #84bbf3; display:inline-block; color:#ffffff; font-family:Monospace; font-size:12px; font-weight:bold; padding:4px 22px; text-decoration:none; text-shadow:1px 1px 5px #528ecc; }
    .protein_list_button:hover { background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #378de5), color-stop(1, #79bbff) ); background:-moz-linear-gradient( center top, #378de5 5%, #79bbff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#378de5', endColorstr='#79bbff'); background-color:#378de5; }
    .protein_list_button:active { position:relative; top:1px; }
    /* This imageless css button was generated by CSSButtonGenerator.com */
	</style>

 </script>

  <form name=working_list action='GetTransitions' target='_GetTransitions' method='post'>

  <script type="text/javascript" src="$HTML_BASE_DIR/usr/javascript/filterTable/filterTable.js"></script>
 
  <table>
  <tr> <td class=bold_text> Filter Protein List: </td> <td colspan=2> <input type="text" size=32 id="filterbox" onkeyup="filterTable(this, protein_list_table)"></input> </td>$fbox_help  </tr>
  <tr> <td class=bold_text> Visible Checkboxes: </td><td> <button class='protein_list_button' onclick="check_boxes('protein_list_table');return false;">$btxt->{Check}</button></td><td><button class='protein_list_button' onclick="uncheck_boxes('protein_list_table');return false;">$btxt->{Uncheck}</button> </td>$cbox_help </tr>
  <tr> <td class=bold_text> Show: </td><td> <button class='protein_list_button' onclick="show_selected('protein_list_table');return false;">$btxt->{Selected}</button> </td><td> <button class='protein_list_button' onclick="show_all('protein_list_table');return false;">$btxt->{All}</button> </td>$show_help </tr>
  <tr> <td class=bold_text> SRM Atlas:  </td><td colspan=1> <button class='protein_list_button' onclick="return submit_form('protein_list_table');">$btxt->{Search}</button> </td> <td> </td>$submit_help </tr>
  <tr><td colspan=4 align=left><div class=description id=chk_status></div></td></tr>
  $table
  <input type=hidden name=pabst_build_id value=146>
  <input type=hidden name=protein_name_constraint id=protein_name value='tmp'>
  <input type=hidden name=default_search value=yes>
  <input type=hidden name=action value=QUERY>
  </form>
  ~;
  return ( "$form" );

}

sub get_btxt {
  my @tags = @_;
  my $max = 0;
  for my $tag ( @tags ) {
    $max = length( $tag ) if length( $tag ) > $max;
  }
  my %btxt;
  for my $tag ( @tags ) {
    my $len = length( $tag );
    my $delta = $max - $len;
    my $pad = 0;
    if ( $delta ) {
      $pad = int($delta/2 + 0.5);
    }
    my $prepad = '&nbsp;' x $pad; 
    my $postpad = '&nbsp;' x ($max - $len - $pad); 
    $btxt{$tag} = $prepad . $tag . $postpad;
  }
  return \%btxt; 

}
sub get_filter_js {
my $filter_js = qq~
~;
return $filter_js;
}

sub process_params {
  my $params = {};
  $sbeams->parse_input_parameters( q => $q, parameters_ref => $params );
  $sbeams->processStandardParameters( parameters_ref => $params );
  $params->{protein_list_id} ||= 1;
  return( $params );
}

sub get_build_path {
  my %args = @_;
  return unless $args{build_id};
  my $path = $atlas->getAtlasBuildDirectory( atlas_build_id => $args{build_id} );
  $path =~ s/DATA_FILES//;
  return $path;
}

sub get_draw_chart_function {
	my $sample_arrayref = shift || return '';

	my @samples;
	for my $s ( @{$sample_arrayref} ) {
		push @samples, [ $s->[1], $s->[4], $s->[7] ];
	}
	my $GV = SBEAMS::Connection::GoogleVisualization->new();
  my ( $chart ) = $GV->setDrawBarChart(  samples => \@samples,
                                    	data_types => [ 'string', 'number', 'number' ],
                                      	headings => [ 'Sample', 'Distinct peptides (n_obs > 1)', 'Cumulative peptides (n_obs > 1)' ],
                                      show_table => 0,
                                 truncate_labels => 24
 	);
	my $header = $GV->getHeaderInfo();
  return ( $chart, $header );
}

