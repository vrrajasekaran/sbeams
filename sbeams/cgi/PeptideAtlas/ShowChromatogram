#!/usr/local/bin/perl

###############################################################################
# Program     : ShowChromatogram
#
# Description : This CGI program displays a single chromatogram in PeptideAtlas
#
# Terry Farrah
#
###############################################################################


###############################################################################
# Basic SBEAMS setup
###############################################################################
use strict;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($q $sbeams $sbeamsMOD $PROG_NAME
             $current_username $massCalculator );

use SBEAMS::Connection qw($q);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;

use SBEAMS::Proteomics::ChromatogramViewer;
use SBEAMS::Proteomics::PeptideMassCalculator;

use SBEAMS::PeptideAtlas;
use SBEAMS::PeptideAtlas::Settings;
use SBEAMS::PeptideAtlas::Tables;
use SBEAMS::PeptideAtlas::Chromatogram;

use File::Basename;

use Carp;
$SIG{__DIE__} = sub { &Carp::confess };
use CGI::Carp qw (fatalsToBrowser);

#$q = new CGI;
$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::PeptideAtlas;
$sbeamsMOD->setSBEAMS($sbeams);


$PROG_NAME="ShowChromatogram";

# Allowable neutral losses
my @neutral_loss_masses = ();

###############################################################################
# Define global variables if any and execute main()
###############################################################################
main();


###############################################################################
# Main Program:
#
# If $sbeams->Authenticate() succeeds, print header, process the CGI request,
# print the footer, and end.
###############################################################################
sub main {

  #### Do the SBEAMS authentication and exit if a username is not returned
  exit unless ($current_username = $sbeams->Authenticate(
    permitted_work_groups_ref=>['PeptideAtlas_user','PeptideAtlas_admin',
      'PeptideAtlas_readonly', 'PeptideAtlas_exec'],
    #connect_read_only=>1,
    allow_anonymous_access=>1,
  ));

  #### Read in the default input parameters
  my %parameters;
  my $n_params_found = 
  $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);

  #### Process generic "state" parameters before we start
  $sbeams->processStandardParameters(parameters_ref=>\%parameters);

  my $apply_action  = $q->param('apply_action');


  #### Process certain actions, then print the header, figure and do what the user wants, and print footer
  $sbeamsMOD->display_page_header();
  #processRequest();
  processRequest(ref_parameters=>\%parameters);
  $sbeamsMOD->display_page_footer();

  $sbeams->display_page_footer(close_tables=>'YES',
    separator_bar=>'YES',display_footer=>'NO');

} # end main



###############################################################################
# processRequest
###############################################################################
sub processRequest {

  #### Process the arguments list
  my %args = @_;
  my $ref_parameters = $args{'ref_parameters'}
    || die "ref_parameters not passed";

  # Create a chromatogram object so we can use its methods
  my $cgram = new SBEAMS::PeptideAtlas::Chromatogram;
  $cgram->setSBEAMS($sbeams);

  # The function below may add to the contents of the parameters hash.
  my $json_string = $cgram->getChromatogramInfo($ref_parameters);

  # Fetch some of the parameters into scalar variables.
  my $precursor_charge = $ref_parameters->{'precursor_charge'};
  my $pepseq = $ref_parameters->{'pepseq'};
  my $modified_pepseq = $ref_parameters->{'modified_pepseq'} || $pepseq;
  my $spectrum_pathname = $ref_parameters->{'spectrum_pathname'} ||
    die 'ShowChromatogram; Need parameter spectrum_pathname';
  my $spectrum_basename = $ref_parameters->{'spectrum_basename'};
  $spectrum_pathname =~ /.*(\..*)/; my $filename_extension = $1;
  if (! $spectrum_basename ) {
    $spectrum_pathname =~ /.*\/(\S+?)\.${filename_extension}/;
    $spectrum_basename = $1;
  }
  my $precursor_neutral_mass = $ref_parameters->{'precursor_neutral_mass'};
  if ($ref_parameters->{'isotype'} =~ /heavy/i) {
    $precursor_neutral_mass += $ref_parameters->{'isotype_delta_mass'};
  }
  my $machine = $ref_parameters->{'machine'};


  #### Display the Chromatogram Viewer page.

  # Print the HTML for the top of the chromatogram viewer page
  my $seq = (defined $modified_pepseq) ? $modified_pepseq : $pepseq;
  my $top_html = $cgram->getTopHTMLforChromatogramViewer (
    param_href => $ref_parameters,
    seq => $seq,
    precursor_neutral_mass => $precursor_neutral_mass,
    precursor_charge => $precursor_charge,
    spectrum_pathname => $spectrum_pathname,
  );
  print $top_html;

  # Generate the Chromavis javascript chromatogram viewer
  my $chromavis = new SBEAMS::Proteomics::ChromatogramViewer;
  print $chromavis->generateChromatogram(
    chromatogram_id => $ref_parameters->{'SEL_chromatogram_id'},
    spectrum_pathname         => $spectrum_pathname,
    precursor_neutral_mass=> $precursor_neutral_mass,
    precursor_charge      => $precursor_charge,
    seq                   => $seq,
    precursor_rt          => $ref_parameters->{rt},
    best_peak_group_rt    => $ref_parameters->{Tr},
    m_score               => $ref_parameters->{m_score},
    json_string           => $json_string,
  );

  # Read the data from the JSON object into a hash of the
  # format required by writeResultSet
  my $cgram_href = $cgram->readJsonChromatogramIntoResultsetHash (
    param_href => $ref_parameters,
    json_string => $json_string,
    #json_physical_pathname => $json_physical_pathname,
  );

  # Store chromatogram data as a recallable resultset
  my $rs_set_name = "SETME";
  $sbeams->writeResultSet(
    resultset_file_ref=>\$rs_set_name,
    resultset_ref=>$cgram_href,
    file_prefix=>'chromgram_',
    query_parameters_ref=>$ref_parameters,
  );

  # Print the HTML that allows user to recall and download resultset
  print $cgram->getBottomHTMLforChromatogramViewer(
    param_href => $ref_parameters,
    rs_set_name => $rs_set_name,
  );

} # end processRequest
