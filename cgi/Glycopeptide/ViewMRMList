#!/usr/local/bin/perl

###############################################################################
# Program     : ViewMRMList
#
# Description : retrieves a list of peptides and MS/MS fragment ions given
#               and displays the spectra for each...
###############################################################################


###############################################################################
# Set up all needed modules and objects
###############################################################################
use strict;
use Getopt::Long;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($sbeams $sbeamsMOD $q $current_contact_id $current_username
$PROG_NAME $USAGE %OPTIONS $QUIET $VERBOSE $DEBUG $DATABASE
$TABLE_NAME $PROGRAM_FILE_NAME $CATEGORY $DB_TABLE_NAME
@MENU_OPTIONS $modification_helper);

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::TabMenu;

use SBEAMS::Glycopeptide;
use SBEAMS::Glycopeptide::Tables;
use SBEAMS::Glycopeptide::Settings;
use SBEAMS::PeptideAtlas::Tables;
use SBEAMS::PeptideAtlas::ModificationHelper;

$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::Glycopeptide;
$sbeamsMOD->setSBEAMS($sbeams);
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);

use PGPLOT;
use PDL;
use PDL::Graphics::PGPLOT;

$PROG_NAME="ViewMRMList";

###############################################################################
# Set program name and usage banner for command like use
###############################################################################
$PROG_NAME = $FindBin::Script;
$USAGE = <<EOU;
Usage: $PROG_NAME [OPTIONS] key=value key=value ...
Options:
    --verbose n    Set verbosity level.    default is 0
    --quiet        Set flag to print nothing at all except errors
    --debug n      Set debug flag

 e.g.:  $PROG_NAME [OPTIONS] [keyword=value],...

EOU

#### Process options
unless (GetOptions(\%OPTIONS,"verbose:s","quiet","debug:s")) 
{
    print "$USAGE";
    exit;
}

$VERBOSE = $OPTIONS{"verbose"} || 0;
$QUIET = $OPTIONS{"quiet"} || 0;
$DEBUG = $OPTIONS{"debug"} || 0;
if ($DEBUG) 
{
    print "Options settings:\n";
    print "    VERBOSE = $VERBOSE\n";
    print "    QUIET = $QUIET\n";
    print "    DEBUG = $DEBUG\n";
}


main();
exit(0);


###############################################################################
# Main Program:
#
# Call $sbeams->Authenticate() and exit if it fails or continue if it works.
###############################################################################
sub main 
{
    #### Do the SBEAMS authentication and exit if a username is not returned
    exit unless ($current_username = $sbeams->Authenticate(
        allow_anonymous_access=>1,
    ));
      

    #### Read in the default input parameters
    my %parameters;

    $parameters{uploaded_file_not_saved} = 1;

    $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%parameters);

    $sbeams->processStandardParameters(parameters_ref=>\%parameters);

    #$sbeams->printDebuggingInfo($q);

    #### Decide what action to take based on information so far
    if ($parameters{action} eq "???") 
    {
        # Some action
    } else 
    {
          $sbeamsMOD->printPageHeader();
    print $sbeams->getGifSpacer(800);

        handle_request(ref_parameters=>\%parameters);

        $sbeamsMOD->display_page_footer();
    }

    #### Finish the upper part of the page and go begin the full-width
    #### data portion of the page
    $sbeams->display_page_footer(close_tables=>'YES',
        separator_bar=>'YES',display_footer=>'NO');

} # end main


###############################################################################
# Handle Request
###############################################################################
sub handle_request 
{
  my %args = @_;

  #### Process the arguments list
  my $ref_parameters = $args{'ref_parameters'} || die "ref_parameters not passed";

  my %params = %{$ref_parameters};

  #### Show current user context information
  print "<BR>\n" if ($sbeams->output_mode() eq 'html');

  #$sbeams->printUserContext();

  #### Define some generic variables
  my ($i,$element,$key,$value,$line,$result,$sql);


#### Define some variables for a query and resultset
  my %resultset = ();
  my $resultset_ref = \%resultset;
  my (%url_cols,%hidden_cols,%max_widths,$show_sql);

  #### Read in the standard form values
  my $apply_action    = $params{'action'} || $params{'apply_action'};
  my $TABLE_NAME = $params{'QUERY_NAME'};

  #### If the apply action was to recall a previous resultset, do it
  my %rs_params = $sbeams->parseResultSetParams(q=>$q);


  #########################################################################
  #### Process all the constraints

  my $build_id = $sbeamsMOD->get_current_build();
  my $cutoff = $sbeamsMOD->get_current_prophet_cutoff();

  unless ( $params{NIST_library_id} && ( $params{NIST_library_id} =~ /^[\d]+$/) ) {
      $sbeams->reportException(
          state => 'ERROR',
          type => 'INSUFFICIENT CONSTRAINTS',
          message => 'You must select at least one NIST library',
      );
      return;
  }

  #### Build NIST_library_id constraint
  my $NIST_library_where_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"NL.NIST_library_id",
      constraint_type=>"int_list",
      constraint_name=>"NIST Library",
      constraint_value=>$params{NIST_library_id} );
  return if ($NIST_library_where_clause eq '-1');

  #### Build PEPTIDE_SEQUENCE constraint
  my $peptide_sequence_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"OP.matching_sequence",
      constraint_type=>"plain_text",
      constraint_name=>"Peptide Sequence",
      constraint_value=>$params{peptide_sequence_constraint} );
  return if ($peptide_sequence_clause eq '-1');

  #### Build BEST_PROBABILITY constraint
  my $best_probability_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"OP.peptide_prophet_score",
      constraint_type=>"flexible_float",
      constraint_name=>"Best Probability",
      constraint_value=>$params{best_probability_constraint} );
  return if ($best_probability_clause eq '-1');

  #### Build peptide_length constraint
  my $op = ( $params{peptide_length} =~ /\<|\>|=/ ) ? '' : '>';
  my $peptide_length_clause = ( $params{peptide_length} ) ? 
         " AND LEN( OP.matching_sequence ) $op $params{peptide_length} \n" : '';

  #### Build PROTEIN_NAME constraint
    my $protein_name_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"ID.ipi_accession_number",
        constraint_type=>"plain_text",
        constraint_name=>"Protein Name",
        constraint_value=>$params{protein_name_constraint} );
    return if ($protein_name_clause eq '-1');

  my $n_highest_intensity_fragment_ions = $params{n_highest_intensity_fragment_ions} || 25;

  my @column_array;


  #### If QUERY or VIEWRESULTSET was selected, display the data
  if ($apply_action =~ /QUERY/i ) {
    my $ed = "<td>&nbsp;</td>";

    print qq~
    Note: masses are mono-isotopic;  results are from query to
    PeptideAtlas followed by peptide sequence query to NIST consensus spectra.
    <br/><br/>
    ~;

    $modification_helper = new ModificationHelper();

    ## look up peptides and nab the NIST spectra with similar peptide sequences
    $sql = qq~
    SELECT distinct NLS.NIST_library_spectrum_id, NLS.sequence,
    NLS.modified_sequence, NLS.protein_name, NLS.mz_exact, NLS.charge,
    NLS.protein_name_alt, OP.peptide_prophet_score, 1,
    OP.observed_peptide_sequence, ID.ipi_data_id 
    FROM $TBAT_NIST_LIBRARY_SPECTRUM NLS
    LEFT JOIN $TBAT_NIST_LIBRARY NL
    ON (NLS.NIST_library_id = NL.NIST_library_id)
    LEFT JOIN $TBGP_OBSERVED_PEPTIDE OP
    ON ( OP.matching_sequence = NLS.sequence)
    LEFT JOIN $TBGP_OBSERVED_TO_IPI OTI
    ON (OP.observed_peptide_id = OTI.observed_peptide_id)
    LEFT JOIN $TBGP_IPI_DATA ID
    ON ( OTI.ipi_data_id = ID.ipi_data_id)
    JOIN $TBAT_NIST_SPECTRUM_TYPE NST
    ON (NST.NIST_spectrum_type_id = NLS.NIST_spectrum_type_id)
    JOIN $TBGP_PEPTIDE_SEARCH PS ON PS.peptide_search_id = OP.peptide_search_id
    JOIN $TBGP_BUILD_TO_SEARCH BTS ON BTS.search_id = PS.peptide_search_id
    WHERE peptide_prophet_score >= $cutoff
    AND BTS.build_id = $build_id
    $NIST_library_where_clause
    $peptide_sequence_clause
    $best_probability_clause
    $peptide_length_clause
    $protein_name_clause
    AND NST.NIST_spectrum_type_name='Consensus'
    ~;

#           $log->debug( $sql );
    my @rows = $sbeams->selectSeveralColumns($sql);
        
    my $max_cnt = 400;
    foreach my $row (@rows) {
    my ($nlsid, $seq, $mod_seq, $prot, $precur_mz, $pep_chg, 
    $alt_name, $prob, $n_obs, $obs_seq, $ipi_id) = @{$row};
        
    $obs_seq = substitute_mods( $obs_seq );
    unless ( $obs_seq eq $mod_seq ) {
      $log->debug ( "skipping because obs is $obs_seq, seq is $mod_seq" );
      next;
    }


    my $sql2 = qq~
    SELECT NLSP.mz,
    NLSP.relative_intensity, NLSP.ion_label, NLSP.charge
    FROM $TBAT_NIST_LIBRARY_SPECTRUM_PEAK NLSP
    WHERE NIST_library_spectrum_id = '$nlsid'
    AND ( NLSP.ion_label IS NOT NULL 
    AND NLSP.ion_label <> ''
    AND NLSP.ion_label NOT LIKE '%-%' ) 
    ORDER BY NLSP.relative_intensity DESC
    ~;
    
    my @rows2 = $sbeams->selectSeveralColumns($sql2);
        
    print qq~
    <table border=2>
    <tr>
    <th>protein</th> <th>alt name</th>
    <th>CID precursor m/z</th> <th>CID charge</th> <th>Prob</th> <th>n obs</th>
    <th>b<sup>+</sup></th> <th>#</th> <th>AA</th> <th>#</th>
    <th>y<sup>+</sup></th> <th>y<sup>2+</sup></th>
    <th>b<sup>+</sup> NIST</th><th>b<sup>+</sup> NIST rel. inten</th>
    <th>y<sup>+</sup> NIST</th><th>y<sup>+</sup> NIST rel. inten</th>
    <th>y<sup>+2</sup> NIST</th><th>y<sup>+</sup> NIST rel. inten</th>
    </tr>
    ~;
        
    $prob = sprintf("%.2f", $prob);

    my @masses;
        
    if ($mod_seq) {
      @masses = $modification_helper->getMasses($mod_seq);
    } else {
      @masses = $modification_helper->getMasses($seq);
    }

                my @aa = split(//,$seq);
                my @b1 = getB1FragMassArray(masses_ref => \@masses);
                my @y1 = getY1FragMassArray(masses_ref => \@masses);
                my @y2 = getY2FragMassArray( y1_ref => \@y1 );
                my @b1_nist = initArray( li => $#aa);
                my @y1_nist = initArray( li => $#aa);
                my @y2_nist = initArray( li => $#aa);
                my @b1_nist_inten = initArray( li => $#aa);
                my @y1_nist_inten = initArray( li => $#aa);
                my @y2_nist_inten = initArray( li => $#aa);
               
                print qq~
                <tr><td>$prot</td><td>$alt_name</td>
                <td>$precur_mz</td><td>$pep_chg</td><td>$prob</td><td>$n_obs</td>
                ~;
                

                my $fragment_cnt = 1;
                foreach my $row2 (@rows2) {

                    my ($frag_mz, $inten, $ion_label, $frag_chg)
                    = @{$row2};

                    ## parse ion label to store in parallel arrays
                    ## will print these alongside the fragment ion m/z calculated
                    ## from sequence
                    if ( $ion_label =~ /y(\d+)(.*)/)
                    {
                        my $ind = $1;

                        my $rem = $2;

                        ## ignore ions with -I and -num or i
                        unless ( $rem =~ /(.*)[\-i](.*)/ )
                        {
                            if ($frag_chg == 1)
                            {
                                $y1_nist[$#aa - $ind + 1] = $frag_mz;
                                $y1_nist_inten[$#aa - $ind + 1] = $inten;
                            } elsif ( $frag_chg == 2)
                            {
                                $y2_nist[$#aa - $ind + 1] = $frag_mz;
                                $y2_nist_inten[$#aa - $ind + 1] = $inten;
                            }
                        }
                    } elsif ( $ion_label =~ /b(\d+)(.*)/)
                    {
                        my $ind = $1;

                        my $rem = $2;

                        ## ignore ions with -I and -num or i
                        if ($rem !~ /(.*)[\-i](.*)/) {
                              $log->debug( "Flipper" );
                            if ($frag_chg == 1) {
                                $b1_nist[$ind - 1] = $frag_mz;
                                $b1_nist_inten[$ind - 1] = $inten;
                            }
                        } else {
                           $log->debug( "Skipper" );
                        }
                    }
                    if ( $fragment_cnt++ >= $n_highest_intensity_fragment_ions ) {
                      $log->debug( "frag cnt is at $fragment_cnt" );
                      last;
                    }
                }

                ## replace @aa with modified sequence array if possible
                @aa = $modification_helper->getModifiedAAs($mod_seq) if ($mod_seq);

                for (my $i=0; $i <= $#aa; $i++)
                {
                    my $bn = $i + 1;
                    my $yn = $#aa - $i + 1;
                    print "<tr> $ed $ed $ed $ed $ed $ed" if ($i > 0);
                    print qq~
                    <td>$b1[$i]</td> <td>$bn</td> <td>$aa[$i]</td> <td>$yn</td> <td>$y1[$yn-1]</td> <td>$y2[$yn-1]</td>
                    <td>$b1_nist[$i]</td> <td>$b1_nist_inten[$i]</td>
                    <td>$y1_nist[$i]</td> <td>$y1_nist_inten[$i]</td>
                    <td>$y2_nist[$i]</td> <td>$y2_nist_inten[$i]</td>
                    </tr>
                    ~;
                }
                print qq~
                    <tr><td colspan='18' style='text-align:center'>
                    <a href='$CGI_BASE_DIR/$SBEAMS_SUBDIR/ShowOneSpectrum?NIST_library_spectrum_id=$nlsid' target='_blank'><b>SHOW SPECTRUM</b></a></td></tr>
                ~;
                print "</table>";
                print "<br/>";
                last if !$max_cnt-- ;
            }



    #### If QUERY was not selected, then tell the user to enter some parameters
    } else {
        if ($sbeams->invocation_mode() eq 'http') 
        {
            print "<H4>Select parameters above and press QUERY</H4>\n";
        } else 
        {
            print "You need to supply some parameters to contrain the query\n";
        }
    }

    ###################################################################
    # getB1FragMassArray - get array of frag masses for b+
    #
    # @param masses_ref - ref to array of masses that alredy include modifications
    # @return @b1
    ###################################################################
    sub getB1FragMassArray
    {
        my %args = @_;
      
        my $masses_ref = $args{masses_ref};

        my @masses = @{$masses_ref};

        my @b1; 

        ## calc b+ ions:
        my $b1_sum = 1.0078;

        for (my $i=0; $i <= $#masses; $i++)
        {
            $b1_sum = $b1_sum + $masses[$i];

            if ($i == $#masses)
            {
                push(@b1, "&nbsp;");
            } else
            {
                push(@b1, sprintf("%.4f",$b1_sum));
            }
        }

        return @b1;
    }

    ###################################################################
    # getY1FragMassArray - get array of frag masses for y+
    #
    # @param masses_ref - ref to array of masses that alredy include modifications
    # @return @y1
    ###################################################################
    sub getY1FragMassArray
    {
        my %args = @_;
      
        my $masses_ref = $args{masses_ref};

        my @masses = @{$masses_ref};

        my @y1 = @masses; ## initialize y1 to be same size array 

        ## calc y+ ions:
        my $y1_sum = 19.0184;

        for (my $i = $#masses; $i >= 0; $i--)
        {
            $y1_sum = $y1_sum + $masses[$i];

            my $ind = $#masses - $i;

            if ($ind == $#masses)
            {
                $y1[$ind] = "&nbsp;";
            } else
            {
                $y1[$ind] = sprintf("%.4f",$y1_sum);
            }
        }

        return @y1;
    }

    ###################################################################
    # getY2FragMassArray - get array of frag masses for y+
    #
    # @param y1_ref - ref to array of y1 masses
    # @return @y2
    ###################################################################
    sub getY2FragMassArray
    {
        my %args = @_;
      
        my $y1_ref = $args{y1_ref};

        my @y1 = @{$y1_ref};

        my @y2 = @y1; ## initialize y2 to be same size array 

        for (my $i=0; $i <= $#y1; $i++)
        {
            unless ($y1[$i] eq "&nbsp;") 
            {
                my $t = ($y1[$i] + 1.0078)/2.;

                $y2[$i] = sprintf("%.4f",$t);
            }
        }

        return @y2;
    }

    ###################################################################
    # initArray - initialize array to size li
    # @param li - size of array
    # @return ia - array initialized to hold &nbsp; for each element
    ###################################################################
    sub initArray
    {
        my %args = @_;
        
        my $li = $args{li};

        my @ia;

        for (my $i=0; $i <= $li; $i++)
        {
            push(@ia, "&nbsp;"); 
        }

        return @ia;
    }

} # end handle_request

sub substitute_mods {
  my $seq = shift;
  $seq =~ s/S\*/S\[167\]/g;
  $seq =~ s/S\&/S\[167\]/g;
  $seq =~ s/T\*/T\[181\]/g;
  $seq =~ s/T\&/T\[181\]/g;
  $seq =~ s/Y\*/Y\[243\]/g;
  $seq =~ s/Y\&/Y\[243\]/g;
  return $seq;
}

