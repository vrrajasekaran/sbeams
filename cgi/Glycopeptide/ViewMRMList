#!/usr/local/bin/perl

###############################################################################
# Program     : ViewMRMList
#
# Description : retrieves a list of peptides and MS/MS fragment ions given
#               and displays the spectra for each...
###############################################################################


###############################################################################
# Set up all needed modules and objects
###############################################################################
use strict;
use Getopt::Long;
use FindBin;

use lib "$FindBin::Bin/../../lib/perl";
use vars qw ($sbeams $sbeamsMOD $q $current_contact_id 
$PROG_NAME $USAGE %OPTIONS $QUIET $VERBOSE $DEBUG $DATABASE
$TABLE_NAME $PROGRAM_FILE_NAME $CATEGORY $DB_TABLE_NAME
@MENU_OPTIONS );

use SBEAMS::Connection qw($q $log);
use SBEAMS::Connection::Settings;
use SBEAMS::Connection::Tables;
use SBEAMS::Connection::DataTable;

use SBEAMS::Glycopeptide;
use SBEAMS::Glycopeptide::Settings;
use SBEAMS::Glycopeptide::Tables;

use SBEAMS::PeptideAtlas::Tables;

$sbeams = new SBEAMS::Connection;
$sbeamsMOD = new SBEAMS::Glycopeptide;
$sbeamsMOD->setSBEAMS($sbeams);
$sbeams->setSBEAMS_SUBDIR($SBEAMS_SUBDIR);

use PGPLOT;
use PDL;
use PDL::Graphics::PGPLOT;

$PROG_NAME="ViewMRMList";

###############################################################################
# Set program name and usage banner for command like use
###############################################################################
$PROG_NAME = $FindBin::Script;
$USAGE = <<EOU;
Usage: $PROG_NAME [OPTIONS] key=value key=value ...
Options:
    --verbose n    Set verbosity level.    default is 0
    --quiet        Set flag to print nothing at all except errors
    --debug n      Set debug flag

 e.g.:  $PROG_NAME [OPTIONS] [keyword=value],...

EOU

#### Process options
unless (GetOptions(\%OPTIONS,"verbose:s","quiet","debug:s")) 
{
    print "$USAGE";
    exit;
}

$VERBOSE = $OPTIONS{"verbose"} || 0;
$QUIET = $OPTIONS{"quiet"} || 0;
$DEBUG = $OPTIONS{"debug"} || 0;
if ($DEBUG) 
{
    print "Options settings:\n";
    print "    VERBOSE = $VERBOSE\n";
    print "    QUIET = $QUIET\n";
    print "    DEBUG = $DEBUG\n";
}


main();
exit(0);


###############################################################################
# Main Program:
#
# Call $sbeams->Authenticate() and exit if it fails or continue if it works.
###############################################################################
sub main 
{
  # Attempt authentication and exit if a username is not returned
  my $user = $sbeams->Authenticate( allow_anonymous_access => 1 ) || exit;

  # Read in the default input parameters
  my %params;

  $params{uploaded_file_not_saved} = 1;

  $sbeams->parse_input_parameters(q=>$q,parameters_ref=>\%params);

  $sbeams->processStandardParameters(parameters_ref=>\%params);

  my $project_id = $sbeams->getCurrent_project_id();
  $sbeamsMOD->display_page_header(project_id => $project_id);
  handle_request(ref_parameters=>\%params);
  $sbeamsMOD->display_page_footer();

} # end main


###############################################################################
# Handle Request
###############################################################################
sub handle_request 
{
  my %args = @_;
  my $build_id = $sbeamsMOD->get_current_build();
  my $cutoff = $sbeamsMOD->get_current_prophet_cutoff();

  #### Process the arguments list
  my $ref_parameters = $args{'ref_parameters'} || die "ref_parameters not passed";

  my %params = %{$ref_parameters};

  #### Show current user context information
  print "<BR>\n" if ($sbeams->output_mode() eq 'html');

  #$sbeams->printUserContext();

  #### Get the HTML to display the tabs

  #### Define some generic variables
  my ($i,$element,$key,$value,$line,$result,$sql);


  #### Define some variables for a query and resultset
  my %resultset = ();
  my $resultset_ref = \%resultset;
  my (%url_cols,%hidden_cols,%max_widths,$show_sql);

  #### Read in the standard form values
  my $apply_action    = $params{'action'} || $params{'apply_action'};
  my $TABLE_NAME = $params{'QUERY_NAME'};

  # If the apply action was to recall a previous resultset, do it
  my %rs_params = $sbeams->parseResultSetParams(q=>$q);


  # Process all the constraints

  my $lib_id = $params{NIST_library_id};

  unless ( $lib_id && $lib_id =~ /^[\d]+$/ ) {
    $sbeams->reportException( state => 'ERROR', 
                               type => 'INSUFFICIENT CONSTRAINTS',
                            message => 'You must select at least one NIST library' );
      return;
  }


  # Build NIST_library_id constraint
  my $NIST_library_where_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"NL.NIST_library_id",
      constraint_type=>"int_list",
      constraint_name=>"NIST Library",
      constraint_value=>$params{NIST_library_id} );
  return if ($NIST_library_where_clause eq '-1');

  #### Build PEPTIDE_SEQUENCE constraint
  my $peptide_sequence_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"OP.matching_sequence",
      constraint_type=>"plain_text",
      constraint_name=>"Peptide Sequence",
      constraint_value=>$params{peptide_sequence_constraint} );
  return if ($peptide_sequence_clause eq '-1');

  #### Build BEST_PROBABILITY constraint
  my $best_probability_clause = $sbeams->parseConstraint2SQL(
      constraint_column=>"OP.peptide_prophet_score",
      constraint_type=>"flexible_float",
      constraint_name=>"Best Probability",
      constraint_value=>$params{best_probability_constraint} );
  return if ($best_probability_clause eq '-1');

  #### Build peptide_length constraint
  my $op = ( $params{peptide_length} =~ /\<|\>|=/ ) ? '' : '>';
  my $peptide_length_clause = ( $params{peptide_length} ) ? 
         " AND LEN( OP.matching_sequence ) $op $params{peptide_length} \n" : '';

  #### Build PROTEIN_NAME constraint
    my $protein_name_clause = $sbeams->parseConstraint2SQL(
        constraint_column=>"ID.ipi_accession_number",
        constraint_type=>"plain_text",
        constraint_name=>"Protein Name",
        constraint_value=>$params{protein_name_constraint} );
    return if ($protein_name_clause eq '-1');



    ## handle file upload and clause for sql for $parameters{upload_file}
    my ($biosequence_names_clause_nist, $biosequence_names_clause_pa,
    $biosequence_names_mapping_join, $biosequence_name_clause_pa);

    my $n_highest_intensity_fragment_ions;

    my %protein_hash;

    my $n_highest_intensity_fragment_ions = $params{n_highest_intensity_fragment_ions} || 25;
    my @column_array;


    #########################################################################
    #### If QUERY or VIEWRESULTSET was selected, display the data
    if ($apply_action =~ /QUERY/i ) 
    {
        my $ed = "<td>&nbsp;</td>";

        print qq~
            Note: masses are mono-isotopic;  results are from query to
            Glycopeptide followed by peptide sequence query to NIST consensus spectra.
            <br/><br/>
        ~;


        ## look up PA peptides and nab the NIST spectra with similar peptide sequences


            $sql = qq~
            SELECT distinct NLS.NIST_library_spectrum_id, NLS.sequence,
            NLS.modified_sequence, NLS.protein_name, NLS.mz_exact, NLS.charge,
            NLS.protein_name_alt, OP.peptide_prophet_score, 1,
            OP.observed_peptide_sequence, ID.ipi_data_id 
            FROM $TBAT_NIST_LIBRARY_SPECTRUM NLS
            LEFT JOIN $TBAT_NIST_LIBRARY NL
            ON (NLS.NIST_library_id = NL.NIST_library_id)
            LEFT JOIN $TBGP_OBSERVED_PEPTIDE OP
            ON ( OP.matching_sequence = NLS.sequence)
            LEFT JOIN $TBGP_OBSERVED_TO_IPI OTI
            ON (OP.observed_peptide_id = OTI.observed_peptide_id)
            LEFT JOIN $TBGP_IPI_DATA ID
            ON ( OTI.ipi_data_id = ID.ipi_data_id)
            JOIN $TBAT_NIST_SPECTRUM_TYPE NST
            ON (NST.NIST_spectrum_type_id = NLS.NIST_spectrum_type_id)
            JOIN $TBGP_PEPTIDE_SEARCH PS ON PS.peptide_search_id = OP.peptide_search_id
            JOIN $TBGP_BUILD_TO_SEARCH BTS ON BTS.search_id = PS.peptide_search_id
            WHERE peptide_prophet_score >= $cutoff
            AND BTS.build_id = $build_id
            $NIST_library_where_clause
            $peptide_sequence_clause
            $best_probability_clause
            $peptide_length_clause
            $protein_name_clause
            AND NST.NIST_spectrum_type_name='Consensus'
            ~;

            $log->debug( "Going to exec SQL" );
            $log->debug( $sbeams->evalSQL( $sql ) );
            my @rows = $sbeams->selectSeveralColumns($sql);
            $log->debug( "SQL done, returned " . scalar(@rows) );

            my @display_rows = ( [qw( Protein Sequence Chg q1_mz q3_mz Intensity Ion SSRCalc n_obs Spectrum ) ] );
            my $idx = 0;
            foreach my $row (@rows) {
                $idx++;
                $log->debug( "processed $idx rows" ) unless $idx % 10;
                my ($nlsid, $seq, $mod_seq, $prot, $precur_mz, $pep_chg, 
                $alt_name, $prob, $n_obs, $n_samples, $n_prot_map,
                $n_gen_map, $ssrcalc ) = @{$row};

                my $sql2 = qq~
                SELECT top $n_highest_intensity_fragment_ions NLSP.mz,
                NLSP.relative_intensity, NLSP.ion_label, NLSP.charge
                FROM $TBAT_NIST_LIBRARY_SPECTRUM_PEAK NLSP
                WHERE NIST_library_spectrum_id = '$nlsid'
                ORDER BY NLSP.relative_intensity DESC
                ~;

                my @rows2 = $sbeams->selectSeveralColumns($sql2);
                my $spec = "<a href='$CGI_BASE_DIR/$SBEAMS_SUBDIR/ShowOneSpectrum?NIST_library_spectrum_id=$nlsid' target='_blank'><b>SHOW SPECTRUM</b></a>";
                my $spec = "<A HREF='ShowOneSpectrum?NIST_library_spectrum_id=$nlsid' TARGET=blank><IMG BORDER=0 SRC='$HTML_BASE_DIR/images/spectrum.gif' TITLE='Show spectrum'></A>";

                my $maxrows = 4;
                my $idx = 0;
                for my $nist ( @rows2 ) {
                  $ssrcalc = sprintf( "%0.2f", $ssrcalc );
                  $nist->[0] = sprintf( "%0.3f", $nist->[0] );
                  $precur_mz = sprintf( "%0.3f", $precur_mz );
                  push @display_rows, [ $prot, $mod_seq, $pep_chg, $precur_mz, $nist->[0], $nist->[1], $nist->[2], $ssrcalc, $n_obs, $spec ] if $nist->[2];
                  last if $idx >= $maxrows;
                  $idx++;
                }
            }

#            my $html = $sbeamsMOD->encodeSectionTable(  header => 1, width => '600', align  => [qw(left left center right right right center right center center)], rows => \@display_rows, rows_to_show => 50, chg_bkg_idx => 1, nowrap => [1..10], max_rows => 500, set_download => 1); print "<TABLE>$html</TABLE>";
            my $table = new SBEAMS::Connection::DataTable( border => 1 );            
            for my $row ( @display_rows ) {
              $table->addRow( $row );
            }
            print "$table";

        } else {


    #### If QUERY was not selected, then tell the user to enter some parameters
        if ($sbeams->invocation_mode() eq 'http') {
            print "<H4>Select parameters above and press QUERY</H4>\n";
        } else 
        {
            print "You need to supply some parameters to contrain the query\n";
        }

      }


    ###################################################################
    # getB1FragMassArray - get array of frag masses for b+
    #
    # @param masses_ref - ref to array of masses that alredy include modifications
    # @return @b1
    ###################################################################
    sub getB1FragMassArray
    {
        my %args = @_;
      
        my $masses_ref = $args{masses_ref};

        my @masses = @{$masses_ref};

        my @b1; 

        ## calc b+ ions:
        my $b1_sum = 1.0078;

        for (my $i=0; $i <= $#masses; $i++)
        {
            $b1_sum = $b1_sum + $masses[$i];

            if ($i == $#masses)
            {
                push(@b1, "&nbsp;");
            } else
            {
                push(@b1, sprintf("%.4f",$b1_sum));
            }
        }

        return @b1;
    }

    ###################################################################
    # getY1FragMassArray - get array of frag masses for y+
    #
    # @param masses_ref - ref to array of masses that alredy include modifications
    # @return @y1
    ###################################################################
    sub getY1FragMassArray
    {
        my %args = @_;
      
        my $masses_ref = $args{masses_ref};

        my @masses = @{$masses_ref};

        my @y1 = @masses; ## initialize y1 to be same size array 

        ## calc y+ ions:
        my $y1_sum = 19.0184;

        for (my $i = $#masses; $i >= 0; $i--)
        {
            $y1_sum = $y1_sum + $masses[$i];

            my $ind = $#masses - $i;

            if ($ind == $#masses)
            {
                $y1[$ind] = "&nbsp;";
            } else
            {
                $y1[$ind] = sprintf("%.4f",$y1_sum);
            }
        }

        return @y1;
    }

    ###################################################################
    # getY2FragMassArray - get array of frag masses for y+
    #
    # @param y1_ref - ref to array of y1 masses
    # @return @y2
    ###################################################################
    sub getY2FragMassArray
    {
        my %args = @_;
      
        my $y1_ref = $args{y1_ref};

        my @y1 = @{$y1_ref};

        my @y2 = @y1; ## initialize y2 to be same size array 

        for (my $i=0; $i <= $#y1; $i++)
        {
            unless ($y1[$i] eq "&nbsp;") 
            {
                my $t = ($y1[$i] + 1.0078)/2.;

                $y2[$i] = sprintf("%.4f",$t);
            }
        }

        return @y2;
    }

    ###################################################################
    # initArray - initialize array to size li
    # @param li - size of array
    # @return ia - array initialized to hold &nbsp; for each element
    ###################################################################
    sub initArray
    {
        my %args = @_;
        
        my $li = $args{li};

        my @ia;

        for (my $i=0; $i <= $li; $i++)
        {
            push(@ia, "&nbsp;"); 
        }

        return @ia;
    }

} # end handle_request

